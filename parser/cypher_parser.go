// Generated from Cypher.g4 by ANTLR 4.7.

package parser // Cypher

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa


var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 129, 1577, 
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13, 
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9, 
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23, 
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4, 
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34, 
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9, 
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44, 
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4, 
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55, 
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9, 
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65, 
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4, 
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76, 
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9, 
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86, 
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4, 
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97, 
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102, 
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 3, 2, 5, 2, 210, 10, 2, 3, 2, 3, 
	2, 5, 2, 214, 10, 2, 3, 2, 5, 2, 217, 10, 2, 3, 2, 5, 2, 220, 10, 2, 3, 
	2, 3, 2, 3, 3, 3, 3, 3, 4, 3, 4, 5, 4, 228, 10, 4, 3, 5, 3, 5, 5, 5, 232, 
	10, 5, 3, 5, 7, 5, 235, 10, 5, 12, 5, 14, 5, 238, 11, 5, 3, 6, 3, 6, 3, 
	6, 3, 6, 5, 6, 244, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 249, 10, 6, 3, 6, 5, 
	6, 252, 10, 6, 3, 7, 3, 7, 5, 7, 256, 10, 7, 3, 8, 3, 8, 5, 8, 260, 10, 
	8, 7, 8, 262, 10, 8, 12, 8, 14, 8, 265, 11, 8, 3, 8, 3, 8, 3, 8, 5, 8, 
	270, 10, 8, 7, 8, 272, 10, 8, 12, 8, 14, 8, 275, 11, 8, 3, 8, 3, 8, 5, 
	8, 279, 10, 8, 3, 8, 7, 8, 282, 10, 8, 12, 8, 14, 8, 285, 11, 8, 3, 8, 
	5, 8, 288, 10, 8, 3, 8, 5, 8, 291, 10, 8, 5, 8, 293, 10, 8, 3, 9, 3, 9, 
	5, 9, 297, 10, 9, 7, 9, 299, 10, 9, 12, 9, 14, 9, 302, 11, 9, 3, 9, 3, 
	9, 5, 9, 306, 10, 9, 7, 9, 308, 10, 9, 12, 9, 14, 9, 311, 11, 9, 3, 9, 
	3, 9, 5, 9, 315, 10, 9, 6, 9, 317, 10, 9, 13, 9, 14, 9, 318, 3, 9, 3, 9, 
	3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 328, 10, 10, 3, 11, 3, 11, 3, 
	11, 5, 11, 333, 10, 11, 3, 12, 3, 12, 5, 12, 337, 10, 12, 3, 12, 3, 12, 
	5, 12, 341, 10, 12, 3, 12, 3, 12, 5, 12, 345, 10, 12, 3, 12, 5, 12, 348, 
	10, 12, 3, 13, 3, 13, 5, 13, 352, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 
	13, 3, 13, 3, 14, 3, 14, 5, 14, 362, 10, 14, 3, 14, 3, 14, 3, 14, 7, 14, 
	367, 10, 14, 12, 14, 14, 14, 370, 11, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 
	15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 382, 10, 15, 3, 16, 3, 16, 
	5, 16, 386, 10, 16, 3, 16, 3, 16, 3, 17, 3, 17, 5, 17, 392, 10, 17, 3, 
	17, 3, 17, 5, 17, 396, 10, 17, 3, 17, 3, 17, 5, 17, 400, 10, 17, 3, 17, 
	7, 17, 403, 10, 17, 12, 17, 14, 17, 406, 11, 17, 3, 18, 3, 18, 5, 18, 410, 
	10, 18, 3, 18, 3, 18, 5, 18, 414, 10, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 
	18, 420, 10, 18, 3, 18, 3, 18, 5, 18, 424, 10, 18, 3, 18, 3, 18, 3, 18, 
	3, 18, 5, 18, 430, 10, 18, 3, 18, 3, 18, 5, 18, 434, 10, 18, 3, 18, 3, 
	18, 3, 18, 3, 18, 5, 18, 440, 10, 18, 3, 18, 3, 18, 5, 18, 444, 10, 18, 
	3, 19, 3, 19, 5, 19, 448, 10, 19, 3, 19, 3, 19, 5, 19, 452, 10, 19, 3, 
	19, 3, 19, 5, 19, 456, 10, 19, 3, 19, 3, 19, 5, 19, 460, 10, 19, 3, 19, 
	7, 19, 463, 10, 19, 12, 19, 14, 19, 466, 11, 19, 3, 20, 3, 20, 3, 20, 3, 
	20, 5, 20, 472, 10, 20, 3, 20, 3, 20, 5, 20, 476, 10, 20, 3, 20, 7, 20, 
	479, 10, 20, 12, 20, 14, 20, 482, 11, 20, 3, 21, 3, 21, 3, 21, 3, 21, 5, 
	21, 488, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 494, 10, 22, 3, 22, 
	3, 22, 3, 22, 5, 22, 499, 10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 505, 
	10, 23, 3, 23, 5, 23, 508, 10, 23, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 514, 
	10, 23, 5, 23, 516, 10, 23, 3, 24, 3, 24, 5, 24, 520, 10, 24, 3, 24, 3, 
	24, 5, 24, 524, 10, 24, 3, 24, 7, 24, 527, 10, 24, 12, 24, 14, 24, 530, 
	11, 24, 3, 24, 5, 24, 533, 10, 24, 3, 24, 5, 24, 536, 10, 24, 3, 25, 3, 
	25, 3, 25, 3, 25, 3, 25, 5, 25, 543, 10, 25, 3, 25, 3, 25, 3, 26, 3, 26, 
	3, 26, 5, 26, 550, 10, 26, 3, 26, 5, 26, 553, 10, 26, 3, 27, 3, 27, 3, 
	27, 3, 28, 5, 28, 559, 10, 28, 3, 28, 5, 28, 562, 10, 28, 3, 28, 3, 28, 
	3, 28, 3, 28, 5, 28, 568, 10, 28, 3, 28, 3, 28, 5, 28, 572, 10, 28, 3, 
	28, 3, 28, 5, 28, 576, 10, 28, 3, 29, 3, 29, 5, 29, 580, 10, 29, 3, 29, 
	3, 29, 5, 29, 584, 10, 29, 3, 29, 7, 29, 587, 10, 29, 12, 29, 14, 29, 590, 
	11, 29, 3, 29, 3, 29, 5, 29, 594, 10, 29, 3, 29, 3, 29, 5, 29, 598, 10, 
	29, 3, 29, 7, 29, 601, 10, 29, 12, 29, 14, 29, 604, 11, 29, 5, 29, 606, 
	10, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 615, 10, 
	30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 624, 10, 31, 
	3, 31, 7, 31, 627, 10, 31, 12, 31, 14, 31, 630, 11, 31, 3, 32, 3, 32, 3, 
	32, 3, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 34, 3, 34, 5, 34, 642, 10, 34, 
	3, 34, 5, 34, 645, 10, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 36, 3, 36, 5, 
	36, 653, 10, 36, 3, 36, 3, 36, 5, 36, 657, 10, 36, 3, 36, 7, 36, 660, 10, 
	36, 12, 36, 14, 36, 663, 11, 36, 3, 37, 3, 37, 5, 37, 667, 10, 37, 3, 37, 
	3, 37, 5, 37, 671, 10, 37, 3, 37, 3, 37, 3, 37, 5, 37, 676, 10, 37, 3, 
	38, 3, 38, 3, 39, 3, 39, 5, 39, 682, 10, 39, 3, 39, 7, 39, 685, 10, 39, 
	12, 39, 14, 39, 688, 11, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 694, 10, 
	39, 3, 40, 3, 40, 5, 40, 698, 10, 40, 3, 40, 6, 40, 701, 10, 40, 13, 40, 
	14, 40, 702, 3, 41, 3, 41, 5, 41, 707, 10, 41, 3, 41, 3, 41, 5, 41, 711, 
	10, 41, 5, 41, 713, 10, 41, 3, 41, 3, 41, 5, 41, 717, 10, 41, 5, 41, 719, 
	10, 41, 3, 41, 3, 41, 5, 41, 723, 10, 41, 5, 41, 725, 10, 41, 3, 41, 3, 
	41, 3, 42, 3, 42, 5, 42, 731, 10, 42, 3, 42, 3, 42, 3, 43, 3, 43, 5, 43, 
	737, 10, 43, 3, 43, 3, 43, 5, 43, 741, 10, 43, 3, 43, 5, 43, 744, 10, 43, 
	3, 43, 5, 43, 747, 10, 43, 3, 43, 3, 43, 5, 43, 751, 10, 43, 3, 43, 3, 
	43, 3, 43, 3, 43, 5, 43, 757, 10, 43, 3, 43, 3, 43, 5, 43, 761, 10, 43, 
	3, 43, 5, 43, 764, 10, 43, 3, 43, 5, 43, 767, 10, 43, 3, 43, 3, 43, 3, 
	43, 3, 43, 5, 43, 773, 10, 43, 3, 43, 5, 43, 776, 10, 43, 3, 43, 5, 43, 
	779, 10, 43, 3, 43, 3, 43, 5, 43, 783, 10, 43, 3, 43, 3, 43, 3, 43, 3, 
	43, 5, 43, 789, 10, 43, 3, 43, 5, 43, 792, 10, 43, 3, 43, 5, 43, 795, 10, 
	43, 3, 43, 3, 43, 5, 43, 799, 10, 43, 3, 44, 3, 44, 5, 44, 803, 10, 44, 
	3, 44, 3, 44, 5, 44, 807, 10, 44, 5, 44, 809, 10, 44, 3, 44, 3, 44, 5, 
	44, 813, 10, 44, 5, 44, 815, 10, 44, 3, 44, 5, 44, 818, 10, 44, 3, 44, 
	3, 44, 5, 44, 822, 10, 44, 5, 44, 824, 10, 44, 3, 44, 3, 44, 3, 45, 3, 
	45, 5, 45, 830, 10, 45, 3, 46, 3, 46, 5, 46, 834, 10, 46, 3, 46, 3, 46, 
	5, 46, 838, 10, 46, 3, 46, 3, 46, 5, 46, 842, 10, 46, 3, 46, 5, 46, 845, 
	10, 46, 3, 46, 7, 46, 848, 10, 46, 12, 46, 14, 46, 851, 11, 46, 3, 47, 
	3, 47, 5, 47, 855, 10, 47, 3, 47, 7, 47, 858, 10, 47, 12, 47, 14, 47, 861, 
	11, 47, 3, 48, 3, 48, 5, 48, 865, 10, 48, 3, 48, 3, 48, 3, 49, 3, 49, 5, 
	49, 871, 10, 49, 3, 49, 3, 49, 5, 49, 875, 10, 49, 5, 49, 877, 10, 49, 
	3, 49, 3, 49, 5, 49, 881, 10, 49, 3, 49, 3, 49, 5, 49, 885, 10, 49, 5, 
	49, 887, 10, 49, 5, 49, 889, 10, 49, 3, 50, 3, 50, 3, 51, 3, 51, 3, 52, 
	3, 52, 5, 52, 897, 10, 52, 3, 52, 6, 52, 900, 10, 52, 13, 52, 14, 52, 901, 
	3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 7, 54, 911, 10, 54, 12, 
	54, 14, 54, 914, 11, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 7, 55, 921, 
	10, 55, 12, 55, 14, 55, 924, 11, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 
	7, 56, 931, 10, 56, 12, 56, 14, 56, 934, 11, 56, 3, 57, 3, 57, 5, 57, 938, 
	10, 57, 7, 57, 940, 10, 57, 12, 57, 14, 57, 943, 11, 57, 3, 57, 3, 57, 
	3, 58, 3, 58, 5, 58, 949, 10, 58, 3, 58, 7, 58, 952, 10, 58, 12, 58, 14, 
	58, 955, 11, 58, 3, 59, 3, 59, 5, 59, 959, 10, 59, 3, 59, 3, 59, 3, 59, 
	5, 59, 964, 10, 59, 3, 59, 3, 59, 3, 59, 5, 59, 969, 10, 59, 3, 59, 3, 
	59, 3, 59, 5, 59, 974, 10, 59, 3, 59, 3, 59, 3, 59, 5, 59, 979, 10, 59, 
	3, 59, 3, 59, 3, 59, 5, 59, 984, 10, 59, 3, 59, 5, 59, 987, 10, 59, 3, 
	60, 3, 60, 3, 60, 3, 60, 7, 60, 993, 10, 60, 12, 60, 14, 60, 996, 11, 60, 
	3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 5, 
	61, 1008, 10, 61, 3, 61, 5, 61, 1011, 10, 61, 3, 61, 3, 61, 3, 62, 3, 62, 
	3, 62, 5, 62, 1018, 10, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 
	63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 5, 63, 1032, 10, 63, 3, 64, 3, 64, 
	5, 64, 1036, 10, 64, 3, 64, 3, 64, 5, 64, 1040, 10, 64, 3, 64, 3, 64, 5, 
	64, 1044, 10, 64, 3, 64, 3, 64, 5, 64, 1048, 10, 64, 3, 64, 7, 64, 1051, 
	10, 64, 12, 64, 14, 64, 1054, 11, 64, 3, 65, 3, 65, 5, 65, 1058, 10, 65, 
	3, 65, 3, 65, 5, 65, 1062, 10, 65, 3, 65, 3, 65, 5, 65, 1066, 10, 65, 3, 
	65, 3, 65, 5, 65, 1070, 10, 65, 3, 65, 3, 65, 5, 65, 1074, 10, 65, 3, 65, 
	3, 65, 5, 65, 1078, 10, 65, 3, 65, 7, 65, 1081, 10, 65, 12, 65, 14, 65, 
	1084, 11, 65, 3, 66, 3, 66, 5, 66, 1088, 10, 66, 3, 66, 3, 66, 5, 66, 1092, 
	10, 66, 3, 66, 7, 66, 1095, 10, 66, 12, 66, 14, 66, 1098, 11, 66, 3, 67, 
	3, 67, 3, 67, 5, 67, 1103, 10, 67, 3, 67, 5, 67, 1106, 10, 67, 3, 68, 3, 
	68, 5, 68, 1110, 10, 68, 3, 68, 3, 68, 5, 68, 1114, 10, 68, 3, 68, 7, 68, 
	1117, 10, 68, 12, 68, 14, 68, 1120, 11, 68, 3, 68, 5, 68, 1123, 10, 68, 
	3, 68, 5, 68, 1126, 10, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 
	69, 1134, 10, 69, 3, 69, 3, 69, 5, 69, 1138, 10, 69, 3, 69, 5, 69, 1141, 
	10, 69, 3, 70, 3, 70, 5, 70, 1145, 10, 70, 3, 70, 3, 70, 3, 71, 3, 71, 
	3, 71, 3, 71, 3, 71, 5, 71, 1154, 10, 71, 3, 71, 3, 71, 5, 71, 1158, 10, 
	71, 3, 71, 3, 71, 5, 71, 1162, 10, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 
	3, 71, 3, 71, 3, 71, 3, 71, 5, 71, 1173, 10, 71, 3, 72, 3, 72, 5, 72, 1177, 
	10, 72, 3, 72, 6, 72, 1180, 10, 72, 13, 72, 14, 72, 1181, 3, 72, 3, 72, 
	5, 72, 1186, 10, 72, 3, 72, 3, 72, 5, 72, 1190, 10, 72, 3, 72, 6, 72, 1193, 
	10, 72, 13, 72, 14, 72, 1194, 5, 72, 1197, 10, 72, 3, 72, 5, 72, 1200, 
	10, 72, 3, 72, 3, 72, 5, 72, 1204, 10, 72, 3, 72, 5, 72, 1207, 10, 72, 
	3, 72, 5, 72, 1210, 10, 72, 3, 72, 3, 72, 3, 73, 3, 73, 5, 73, 1216, 10, 
	73, 3, 73, 3, 73, 5, 73, 1220, 10, 73, 3, 73, 3, 73, 5, 73, 1224, 10, 73, 
	3, 73, 3, 73, 3, 74, 3, 74, 5, 74, 1230, 10, 74, 3, 74, 3, 74, 5, 74, 1234, 
	10, 74, 3, 74, 3, 74, 5, 74, 1238, 10, 74, 3, 74, 5, 74, 1241, 10, 74, 
	3, 74, 5, 74, 1244, 10, 74, 3, 74, 3, 74, 3, 75, 3, 75, 5, 75, 1250, 10, 
	75, 3, 75, 3, 75, 5, 75, 1254, 10, 75, 3, 75, 3, 75, 5, 75, 1258, 10, 75, 
	5, 75, 1260, 10, 75, 3, 75, 3, 75, 5, 75, 1264, 10, 75, 3, 75, 3, 75, 5, 
	75, 1268, 10, 75, 5, 75, 1270, 10, 75, 3, 75, 3, 75, 5, 75, 1274, 10, 75, 
	3, 75, 3, 75, 5, 75, 1278, 10, 75, 3, 75, 3, 75, 3, 76, 3, 76, 5, 76, 1284, 
	10, 76, 3, 76, 3, 76, 5, 76, 1288, 10, 76, 3, 76, 3, 76, 5, 76, 1292, 10, 
	76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 1298, 10, 76, 3, 76, 3, 76, 5, 76, 
	1302, 10, 76, 3, 76, 3, 76, 5, 76, 1306, 10, 76, 3, 76, 3, 76, 3, 76, 3, 
	76, 5, 76, 1312, 10, 76, 3, 76, 3, 76, 5, 76, 1316, 10, 76, 3, 76, 3, 76, 
	5, 76, 1320, 10, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 1326, 10, 76, 3, 
	76, 3, 76, 5, 76, 1330, 10, 76, 3, 76, 3, 76, 5, 76, 1334, 10, 76, 3, 76, 
	3, 76, 5, 76, 1338, 10, 76, 3, 77, 3, 77, 5, 77, 1342, 10, 77, 3, 77, 5, 
	77, 1345, 10, 77, 3, 78, 3, 78, 3, 79, 3, 79, 5, 79, 1351, 10, 79, 3, 79, 
	3, 79, 5, 79, 1355, 10, 79, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 
	80, 3, 80, 3, 81, 3, 81, 5, 81, 1367, 10, 81, 3, 81, 3, 81, 5, 81, 1371, 
	10, 81, 3, 81, 3, 81, 5, 81, 1375, 10, 81, 5, 81, 1377, 10, 81, 3, 81, 
	3, 81, 5, 81, 1381, 10, 81, 3, 81, 3, 81, 5, 81, 1385, 10, 81, 3, 81, 3, 
	81, 5, 81, 1389, 10, 81, 7, 81, 1391, 10, 81, 12, 81, 14, 81, 1394, 11, 
	81, 5, 81, 1396, 10, 81, 3, 81, 3, 81, 3, 82, 3, 82, 3, 82, 3, 83, 3, 83, 
	5, 83, 1405, 10, 83, 3, 83, 3, 83, 5, 83, 1409, 10, 83, 3, 83, 3, 83, 3, 
	83, 5, 83, 1414, 10, 83, 3, 83, 5, 83, 1417, 10, 83, 5, 83, 1419, 10, 83, 
	3, 83, 5, 83, 1422, 10, 83, 3, 83, 3, 83, 3, 84, 3, 84, 5, 84, 1428, 10, 
	84, 3, 84, 3, 84, 5, 84, 1432, 10, 84, 3, 84, 3, 84, 5, 84, 1436, 10, 84, 
	3, 84, 3, 84, 5, 84, 1440, 10, 84, 3, 84, 3, 84, 5, 84, 1444, 10, 84, 7, 
	84, 1446, 10, 84, 12, 84, 14, 84, 1449, 11, 84, 5, 84, 1451, 10, 84, 3, 
	84, 3, 84, 3, 85, 3, 85, 3, 86, 3, 86, 3, 87, 3, 87, 3, 87, 3, 88, 3, 88, 
	3, 88, 7, 88, 1465, 10, 88, 12, 88, 14, 88, 1468, 11, 88, 3, 89, 3, 89, 
	3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 5, 90, 1478, 10, 90, 3, 91, 3, 
	91, 3, 92, 3, 92, 5, 92, 1484, 10, 92, 3, 93, 3, 93, 3, 94, 3, 94, 3, 95, 
	3, 95, 5, 95, 1492, 10, 95, 3, 95, 3, 95, 5, 95, 1496, 10, 95, 3, 95, 3, 
	95, 5, 95, 1500, 10, 95, 3, 95, 3, 95, 5, 95, 1504, 10, 95, 7, 95, 1506, 
	10, 95, 12, 95, 14, 95, 1509, 11, 95, 5, 95, 1511, 10, 95, 3, 95, 3, 95, 
	3, 96, 3, 96, 5, 96, 1517, 10, 96, 3, 96, 3, 96, 5, 96, 1521, 10, 96, 3, 
	96, 3, 96, 5, 96, 1525, 10, 96, 3, 96, 3, 96, 5, 96, 1529, 10, 96, 3, 96, 
	3, 96, 5, 96, 1533, 10, 96, 3, 96, 3, 96, 5, 96, 1537, 10, 96, 3, 96, 3, 
	96, 5, 96, 1541, 10, 96, 3, 96, 3, 96, 5, 96, 1545, 10, 96, 7, 96, 1547, 
	10, 96, 12, 96, 14, 96, 1550, 11, 96, 5, 96, 1552, 10, 96, 3, 96, 3, 96, 
	3, 97, 3, 97, 3, 98, 3, 98, 3, 98, 5, 98, 1561, 10, 98, 3, 99, 3, 99, 5, 
	99, 1565, 10, 99, 3, 100, 3, 100, 3, 101, 3, 101, 3, 102, 3, 102, 3, 103, 
	3, 103, 3, 104, 3, 104, 3, 104, 2, 2, 105, 2, 4, 6, 8, 10, 12, 14, 16, 
	18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 
	54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 
	90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 
	122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 
	152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 
	182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 2, 12, 
	3, 2, 70, 73, 3, 2, 20, 21, 3, 2, 95, 96, 3, 2, 97, 99, 3, 2, 107, 108, 
	7, 2, 48, 60, 63, 84, 86, 90, 94, 96, 111, 120, 7, 2, 85, 85, 91, 93, 100, 
	100, 121, 123, 126, 126, 4, 2, 16, 16, 29, 32, 4, 2, 17, 17, 33, 36, 4, 
	2, 21, 21, 37, 47, 2, 1795, 2, 209, 3, 2, 2, 2, 4, 223, 3, 2, 2, 2, 6, 
	227, 3, 2, 2, 2, 8, 229, 3, 2, 2, 2, 10, 251, 3, 2, 2, 2, 12, 255, 3, 2, 
	2, 2, 14, 292, 3, 2, 2, 2, 16, 316, 3, 2, 2, 2, 18, 327, 3, 2, 2, 2, 20, 
	332, 3, 2, 2, 2, 22, 336, 3, 2, 2, 2, 24, 349, 3, 2, 2, 2, 26, 359, 3, 
	2, 2, 2, 28, 381, 3, 2, 2, 2, 30, 383, 3, 2, 2, 2, 32, 389, 3, 2, 2, 2, 
	34, 443, 3, 2, 2, 2, 36, 447, 3, 2, 2, 2, 38, 467, 3, 2, 2, 2, 40, 487, 
	3, 2, 2, 2, 42, 489, 3, 2, 2, 2, 44, 500, 3, 2, 2, 2, 46, 517, 3, 2, 2, 
	2, 48, 542, 3, 2, 2, 2, 50, 546, 3, 2, 2, 2, 52, 554, 3, 2, 2, 2, 54, 561, 
	3, 2, 2, 2, 56, 605, 3, 2, 2, 2, 58, 614, 3, 2, 2, 2, 60, 616, 3, 2, 2, 
	2, 62, 631, 3, 2, 2, 2, 64, 635, 3, 2, 2, 2, 66, 639, 3, 2, 2, 2, 68, 646, 
	3, 2, 2, 2, 70, 650, 3, 2, 2, 2, 72, 675, 3, 2, 2, 2, 74, 677, 3, 2, 2, 
	2, 76, 693, 3, 2, 2, 2, 78, 695, 3, 2, 2, 2, 80, 704, 3, 2, 2, 2, 82, 728, 
	3, 2, 2, 2, 84, 798, 3, 2, 2, 2, 86, 800, 3, 2, 2, 2, 88, 829, 3, 2, 2, 
	2, 90, 831, 3, 2, 2, 2, 92, 852, 3, 2, 2, 2, 94, 862, 3, 2, 2, 2, 96, 868, 
	3, 2, 2, 2, 98, 890, 3, 2, 2, 2, 100, 892, 3, 2, 2, 2, 102, 894, 3, 2, 
	2, 2, 104, 903, 3, 2, 2, 2, 106, 905, 3, 2, 2, 2, 108, 915, 3, 2, 2, 2, 
	110, 925, 3, 2, 2, 2, 112, 941, 3, 2, 2, 2, 114, 946, 3, 2, 2, 2, 116, 
	986, 3, 2, 2, 2, 118, 988, 3, 2, 2, 2, 120, 1007, 3, 2, 2, 2, 122, 1014, 
	3, 2, 2, 2, 124, 1031, 3, 2, 2, 2, 126, 1033, 3, 2, 2, 2, 128, 1055, 3, 
	2, 2, 2, 130, 1085, 3, 2, 2, 2, 132, 1105, 3, 2, 2, 2, 134, 1107, 3, 2, 
	2, 2, 136, 1140, 3, 2, 2, 2, 138, 1142, 3, 2, 2, 2, 140, 1172, 3, 2, 2, 
	2, 142, 1196, 3, 2, 2, 2, 144, 1213, 3, 2, 2, 2, 146, 1227, 3, 2, 2, 2, 
	148, 1247, 3, 2, 2, 2, 150, 1337, 3, 2, 2, 2, 152, 1339, 3, 2, 2, 2, 154, 
	1346, 3, 2, 2, 2, 156, 1348, 3, 2, 2, 2, 158, 1358, 3, 2, 2, 2, 160, 1364, 
	3, 2, 2, 2, 162, 1399, 3, 2, 2, 2, 164, 1402, 3, 2, 2, 2, 166, 1425, 3, 
	2, 2, 2, 168, 1454, 3, 2, 2, 2, 170, 1456, 3, 2, 2, 2, 172, 1458, 3, 2, 
	2, 2, 174, 1466, 3, 2, 2, 2, 176, 1469, 3, 2, 2, 2, 178, 1477, 3, 2, 2, 
	2, 180, 1479, 3, 2, 2, 2, 182, 1483, 3, 2, 2, 2, 184, 1485, 3, 2, 2, 2, 
	186, 1487, 3, 2, 2, 2, 188, 1489, 3, 2, 2, 2, 190, 1514, 3, 2, 2, 2, 192, 
	1555, 3, 2, 2, 2, 194, 1557, 3, 2, 2, 2, 196, 1564, 3, 2, 2, 2, 198, 1566, 
	3, 2, 2, 2, 200, 1568, 3, 2, 2, 2, 202, 1570, 3, 2, 2, 2, 204, 1572, 3, 
	2, 2, 2, 206, 1574, 3, 2, 2, 2, 208, 210, 7, 127, 2, 2, 209, 208, 3, 2, 
	2, 2, 209, 210, 3, 2, 2, 2, 210, 211, 3, 2, 2, 2, 211, 216, 5, 4, 3, 2, 
	212, 214, 7, 127, 2, 2, 213, 212, 3, 2, 2, 2, 213, 214, 3, 2, 2, 2, 214, 
	215, 3, 2, 2, 2, 215, 217, 7, 3, 2, 2, 216, 213, 3, 2, 2, 2, 216, 217, 
	3, 2, 2, 2, 217, 219, 3, 2, 2, 2, 218, 220, 7, 127, 2, 2, 219, 218, 3, 
	2, 2, 2, 219, 220, 3, 2, 2, 2, 220, 221, 3, 2, 2, 2, 221, 222, 7, 2, 2, 
	3, 222, 3, 3, 2, 2, 2, 223, 224, 5, 6, 4, 2, 224, 5, 3, 2, 2, 2, 225, 228, 
	5, 8, 5, 2, 226, 228, 5, 44, 23, 2, 227, 225, 3, 2, 2, 2, 227, 226, 3, 
	2, 2, 2, 228, 7, 3, 2, 2, 2, 229, 236, 5, 12, 7, 2, 230, 232, 7, 127, 2, 
	2, 231, 230, 3, 2, 2, 2, 231, 232, 3, 2, 2, 2, 232, 233, 3, 2, 2, 2, 233, 
	235, 5, 10, 6, 2, 234, 231, 3, 2, 2, 2, 235, 238, 3, 2, 2, 2, 236, 234, 
	3, 2, 2, 2, 236, 237, 3, 2, 2, 2, 237, 9, 3, 2, 2, 2, 238, 236, 3, 2, 2, 
	2, 239, 240, 7, 48, 2, 2, 240, 241, 7, 127, 2, 2, 241, 243, 7, 49, 2, 2, 
	242, 244, 7, 127, 2, 2, 243, 242, 3, 2, 2, 2, 243, 244, 3, 2, 2, 2, 244, 
	245, 3, 2, 2, 2, 245, 252, 5, 12, 7, 2, 246, 248, 7, 48, 2, 2, 247, 249, 
	7, 127, 2, 2, 248, 247, 3, 2, 2, 2, 248, 249, 3, 2, 2, 2, 249, 250, 3, 
	2, 2, 2, 250, 252, 5, 12, 7, 2, 251, 239, 3, 2, 2, 2, 251, 246, 3, 2, 2, 
	2, 252, 11, 3, 2, 2, 2, 253, 256, 5, 14, 8, 2, 254, 256, 5, 16, 9, 2, 255, 
	253, 3, 2, 2, 2, 255, 254, 3, 2, 2, 2, 256, 13, 3, 2, 2, 2, 257, 259, 5, 
	20, 11, 2, 258, 260, 7, 127, 2, 2, 259, 258, 3, 2, 2, 2, 259, 260, 3, 2, 
	2, 2, 260, 262, 3, 2, 2, 2, 261, 257, 3, 2, 2, 2, 262, 265, 3, 2, 2, 2, 
	263, 261, 3, 2, 2, 2, 263, 264, 3, 2, 2, 2, 264, 266, 3, 2, 2, 2, 265, 
	263, 3, 2, 2, 2, 266, 293, 5, 52, 27, 2, 267, 269, 5, 20, 11, 2, 268, 270, 
	7, 127, 2, 2, 269, 268, 3, 2, 2, 2, 269, 270, 3, 2, 2, 2, 270, 272, 3, 
	2, 2, 2, 271, 267, 3, 2, 2, 2, 272, 275, 3, 2, 2, 2, 273, 271, 3, 2, 2, 
	2, 273, 274, 3, 2, 2, 2, 274, 276, 3, 2, 2, 2, 275, 273, 3, 2, 2, 2, 276, 
	283, 5, 18, 10, 2, 277, 279, 7, 127, 2, 2, 278, 277, 3, 2, 2, 2, 278, 279, 
	3, 2, 2, 2, 279, 280, 3, 2, 2, 2, 280, 282, 5, 18, 10, 2, 281, 278, 3, 
	2, 2, 2, 282, 285, 3, 2, 2, 2, 283, 281, 3, 2, 2, 2, 283, 284, 3, 2, 2, 
	2, 284, 290, 3, 2, 2, 2, 285, 283, 3, 2, 2, 2, 286, 288, 7, 127, 2, 2, 
	287, 286, 3, 2, 2, 2, 287, 288, 3, 2, 2, 2, 288, 289, 3, 2, 2, 2, 289, 
	291, 5, 52, 27, 2, 290, 287, 3, 2, 2, 2, 290, 291, 3, 2, 2, 2, 291, 293, 
	3, 2, 2, 2, 292, 263, 3, 2, 2, 2, 292, 273, 3, 2, 2, 2, 293, 15, 3, 2, 
	2, 2, 294, 296, 5, 20, 11, 2, 295, 297, 7, 127, 2, 2, 296, 295, 3, 2, 2, 
	2, 296, 297, 3, 2, 2, 2, 297, 299, 3, 2, 2, 2, 298, 294, 3, 2, 2, 2, 299, 
	302, 3, 2, 2, 2, 300, 298, 3, 2, 2, 2, 300, 301, 3, 2, 2, 2, 301, 309, 
	3, 2, 2, 2, 302, 300, 3, 2, 2, 2, 303, 305, 5, 18, 10, 2, 304, 306, 7, 
	127, 2, 2, 305, 304, 3, 2, 2, 2, 305, 306, 3, 2, 2, 2, 306, 308, 3, 2, 
	2, 2, 307, 303, 3, 2, 2, 2, 308, 311, 3, 2, 2, 2, 309, 307, 3, 2, 2, 2, 
	309, 310, 3, 2, 2, 2, 310, 312, 3, 2, 2, 2, 311, 309, 3, 2, 2, 2, 312, 
	314, 5, 50, 26, 2, 313, 315, 7, 127, 2, 2, 314, 313, 3, 2, 2, 2, 314, 315, 
	3, 2, 2, 2, 315, 317, 3, 2, 2, 2, 316, 300, 3, 2, 2, 2, 317, 318, 3, 2, 
	2, 2, 318, 316, 3, 2, 2, 2, 318, 319, 3, 2, 2, 2, 319, 320, 3, 2, 2, 2, 
	320, 321, 5, 14, 8, 2, 321, 17, 3, 2, 2, 2, 322, 328, 5, 30, 16, 2, 323, 
	328, 5, 26, 14, 2, 324, 328, 5, 36, 19, 2, 325, 328, 5, 32, 17, 2, 326, 
	328, 5, 38, 20, 2, 327, 322, 3, 2, 2, 2, 327, 323, 3, 2, 2, 2, 327, 324, 
	3, 2, 2, 2, 327, 325, 3, 2, 2, 2, 327, 326, 3, 2, 2, 2, 328, 19, 3, 2, 
	2, 2, 329, 333, 5, 22, 12, 2, 330, 333, 5, 24, 13, 2, 331, 333, 5, 42, 
	22, 2, 332, 329, 3, 2, 2, 2, 332, 330, 3, 2, 2, 2, 332, 331, 3, 2, 2, 2, 
	333, 21, 3, 2, 2, 2, 334, 335, 7, 50, 2, 2, 335, 337, 7, 127, 2, 2, 336, 
	334, 3, 2, 2, 2, 336, 337, 3, 2, 2, 2, 337, 338, 3, 2, 2, 2, 338, 340, 
	7, 51, 2, 2, 339, 341, 7, 127, 2, 2, 340, 339, 3, 2, 2, 2, 340, 341, 3, 
	2, 2, 2, 341, 342, 3, 2, 2, 2, 342, 347, 5, 70, 36, 2, 343, 345, 7, 127, 
	2, 2, 344, 343, 3, 2, 2, 2, 344, 345, 3, 2, 2, 2, 345, 346, 3, 2, 2, 2, 
	346, 348, 5, 68, 35, 2, 347, 344, 3, 2, 2, 2, 347, 348, 3, 2, 2, 2, 348, 
	23, 3, 2, 2, 2, 349, 351, 7, 52, 2, 2, 350, 352, 7, 127, 2, 2, 351, 350, 
	3, 2, 2, 2, 351, 352, 3, 2, 2, 2, 352, 353, 3, 2, 2, 2, 353, 354, 5, 104, 
	53, 2, 354, 355, 7, 127, 2, 2, 355, 356, 7, 53, 2, 2, 356, 357, 7, 127, 
	2, 2, 357, 358, 5, 176, 89, 2, 358, 25, 3, 2, 2, 2, 359, 361, 7, 54, 2, 
	2, 360, 362, 7, 127, 2, 2, 361, 360, 3, 2, 2, 2, 361, 362, 3, 2, 2, 2, 
	362, 363, 3, 2, 2, 2, 363, 368, 5, 72, 37, 2, 364, 365, 7, 127, 2, 2, 365, 
	367, 5, 28, 15, 2, 366, 364, 3, 2, 2, 2, 367, 370, 3, 2, 2, 2, 368, 366, 
	3, 2, 2, 2, 368, 369, 3, 2, 2, 2, 369, 27, 3, 2, 2, 2, 370, 368, 3, 2, 
	2, 2, 371, 372, 7, 55, 2, 2, 372, 373, 7, 127, 2, 2, 373, 374, 7, 51, 2, 
	2, 374, 375, 7, 127, 2, 2, 375, 382, 5, 32, 17, 2, 376, 377, 7, 55, 2, 
	2, 377, 378, 7, 127, 2, 2, 378, 379, 7, 56, 2, 2, 379, 380, 7, 127, 2, 
	2, 380, 382, 5, 32, 17, 2, 381, 371, 3, 2, 2, 2, 381, 376, 3, 2, 2, 2, 
	382, 29, 3, 2, 2, 2, 383, 385, 7, 56, 2, 2, 384, 386, 7, 127, 2, 2, 385, 
	384, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 387, 3, 2, 2, 2, 387, 388, 
	5, 70, 36, 2, 388, 31, 3, 2, 2, 2, 389, 391, 7, 57, 2, 2, 390, 392, 7, 
	127, 2, 2, 391, 390, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 393, 3, 2, 
	2, 2, 393, 404, 5, 34, 18, 2, 394, 396, 7, 127, 2, 2, 395, 394, 3, 2, 2, 
	2, 395, 396, 3, 2, 2, 2, 396, 397, 3, 2, 2, 2, 397, 399, 7, 4, 2, 2, 398, 
	400, 7, 127, 2, 2, 399, 398, 3, 2, 2, 2, 399, 400, 3, 2, 2, 2, 400, 401, 
	3, 2, 2, 2, 401, 403, 5, 34, 18, 2, 402, 395, 3, 2, 2, 2, 403, 406, 3, 
	2, 2, 2, 404, 402, 3, 2, 2, 2, 404, 405, 3, 2, 2, 2, 405, 33, 3, 2, 2, 
	2, 406, 404, 3, 2, 2, 2, 407, 409, 5, 102, 52, 2, 408, 410, 7, 127, 2, 
	2, 409, 408, 3, 2, 2, 2, 409, 410, 3, 2, 2, 2, 410, 411, 3, 2, 2, 2, 411, 
	413, 7, 5, 2, 2, 412, 414, 7, 127, 2, 2, 413, 412, 3, 2, 2, 2, 413, 414, 
	3, 2, 2, 2, 414, 415, 3, 2, 2, 2, 415, 416, 5, 104, 53, 2, 416, 444, 3, 
	2, 2, 2, 417, 419, 5, 176, 89, 2, 418, 420, 7, 127, 2, 2, 419, 418, 3, 
	2, 2, 2, 419, 420, 3, 2, 2, 2, 420, 421, 3, 2, 2, 2, 421, 423, 7, 5, 2, 
	2, 422, 424, 7, 127, 2, 2, 423, 422, 3, 2, 2, 2, 423, 424, 3, 2, 2, 2, 
	424, 425, 3, 2, 2, 2, 425, 426, 5, 104, 53, 2, 426, 444, 3, 2, 2, 2, 427, 
	429, 5, 176, 89, 2, 428, 430, 7, 127, 2, 2, 429, 428, 3, 2, 2, 2, 429, 
	430, 3, 2, 2, 2, 430, 431, 3, 2, 2, 2, 431, 433, 7, 6, 2, 2, 432, 434, 
	7, 127, 2, 2, 433, 432, 3, 2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 435, 3, 
	2, 2, 2, 435, 436, 5, 104, 53, 2, 436, 444, 3, 2, 2, 2, 437, 439, 5, 176, 
	89, 2, 438, 440, 7, 127, 2, 2, 439, 438, 3, 2, 2, 2, 439, 440, 3, 2, 2, 
	2, 440, 441, 3, 2, 2, 2, 441, 442, 5, 92, 47, 2, 442, 444, 3, 2, 2, 2, 
	443, 407, 3, 2, 2, 2, 443, 417, 3, 2, 2, 2, 443, 427, 3, 2, 2, 2, 443, 
	437, 3, 2, 2, 2, 444, 35, 3, 2, 2, 2, 445, 446, 7, 58, 2, 2, 446, 448, 
	7, 127, 2, 2, 447, 445, 3, 2, 2, 2, 447, 448, 3, 2, 2, 2, 448, 449, 3, 
	2, 2, 2, 449, 451, 7, 59, 2, 2, 450, 452, 7, 127, 2, 2, 451, 450, 3, 2, 
	2, 2, 451, 452, 3, 2, 2, 2, 452, 453, 3, 2, 2, 2, 453, 464, 5, 104, 53, 
	2, 454, 456, 7, 127, 2, 2, 455, 454, 3, 2, 2, 2, 455, 456, 3, 2, 2, 2, 
	456, 457, 3, 2, 2, 2, 457, 459, 7, 4, 2, 2, 458, 460, 7, 127, 2, 2, 459, 
	458, 3, 2, 2, 2, 459, 460, 3, 2, 2, 2, 460, 461, 3, 2, 2, 2, 461, 463, 
	5, 104, 53, 2, 462, 455, 3, 2, 2, 2, 463, 466, 3, 2, 2, 2, 464, 462, 3, 
	2, 2, 2, 464, 465, 3, 2, 2, 2, 465, 37, 3, 2, 2, 2, 466, 464, 3, 2, 2, 
	2, 467, 468, 7, 60, 2, 2, 468, 469, 7, 127, 2, 2, 469, 480, 5, 40, 21, 
	2, 470, 472, 7, 127, 2, 2, 471, 470, 3, 2, 2, 2, 471, 472, 3, 2, 2, 2, 
	472, 473, 3, 2, 2, 2, 473, 475, 7, 4, 2, 2, 474, 476, 7, 127, 2, 2, 475, 
	474, 3, 2, 2, 2, 475, 476, 3, 2, 2, 2, 476, 477, 3, 2, 2, 2, 477, 479, 
	5, 40, 21, 2, 478, 471, 3, 2, 2, 2, 479, 482, 3, 2, 2, 2, 480, 478, 3, 
	2, 2, 2, 480, 481, 3, 2, 2, 2, 481, 39, 3, 2, 2, 2, 482, 480, 3, 2, 2, 
	2, 483, 484, 5, 176, 89, 2, 484, 485, 5, 92, 47, 2, 485, 488, 3, 2, 2, 
	2, 486, 488, 5, 102, 52, 2, 487, 483, 3, 2, 2, 2, 487, 486, 3, 2, 2, 2, 
	488, 41, 3, 2, 2, 2, 489, 490, 7, 61, 2, 2, 490, 491, 7, 127, 2, 2, 491, 
	498, 5, 166, 84, 2, 492, 494, 7, 127, 2, 2, 493, 492, 3, 2, 2, 2, 493, 
	494, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 496, 7, 62, 2, 2, 496, 497, 
	7, 127, 2, 2, 497, 499, 5, 46, 24, 2, 498, 493, 3, 2, 2, 2, 498, 499, 3, 
	2, 2, 2, 499, 43, 3, 2, 2, 2, 500, 501, 7, 61, 2, 2, 501, 504, 7, 127, 
	2, 2, 502, 505, 5, 166, 84, 2, 503, 505, 5, 168, 85, 2, 504, 502, 3, 2, 
	2, 2, 504, 503, 3, 2, 2, 2, 505, 515, 3, 2, 2, 2, 506, 508, 7, 127, 2, 
	2, 507, 506, 3, 2, 2, 2, 507, 508, 3, 2, 2, 2, 508, 509, 3, 2, 2, 2, 509, 
	510, 7, 62, 2, 2, 510, 513, 7, 127, 2, 2, 511, 514, 7, 7, 2, 2, 512, 514, 
	5, 46, 24, 2, 513, 511, 3, 2, 2, 2, 513, 512, 3, 2, 2, 2, 514, 516, 3, 
	2, 2, 2, 515, 507, 3, 2, 2, 2, 515, 516, 3, 2, 2, 2, 516, 45, 3, 2, 2, 
	2, 517, 528, 5, 48, 25, 2, 518, 520, 7, 127, 2, 2, 519, 518, 3, 2, 2, 2, 
	519, 520, 3, 2, 2, 2, 520, 521, 3, 2, 2, 2, 521, 523, 7, 4, 2, 2, 522, 
	524, 7, 127, 2, 2, 523, 522, 3, 2, 2, 2, 523, 524, 3, 2, 2, 2, 524, 525, 
	3, 2, 2, 2, 525, 527, 5, 48, 25, 2, 526, 519, 3, 2, 2, 2, 527, 530, 3, 
	2, 2, 2, 528, 526, 3, 2, 2, 2, 528, 529, 3, 2, 2, 2, 529, 535, 3, 2, 2, 
	2, 530, 528, 3, 2, 2, 2, 531, 533, 7, 127, 2, 2, 532, 531, 3, 2, 2, 2, 
	532, 533, 3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534, 536, 5, 68, 35, 2, 535, 
	532, 3, 2, 2, 2, 535, 536, 3, 2, 2, 2, 536, 47, 3, 2, 2, 2, 537, 538, 5, 
	170, 86, 2, 538, 539, 7, 127, 2, 2, 539, 540, 7, 53, 2, 2, 540, 541, 7, 
	127, 2, 2, 541, 543, 3, 2, 2, 2, 542, 537, 3, 2, 2, 2, 542, 543, 3, 2, 
	2, 2, 543, 544, 3, 2, 2, 2, 544, 545, 5, 176, 89, 2, 545, 49, 3, 2, 2, 
	2, 546, 547, 7, 63, 2, 2, 547, 552, 5, 54, 28, 2, 548, 550, 7, 127, 2, 
	2, 549, 548, 3, 2, 2, 2, 549, 550, 3, 2, 2, 2, 550, 551, 3, 2, 2, 2, 551, 
	553, 5, 68, 35, 2, 552, 549, 3, 2, 2, 2, 552, 553, 3, 2, 2, 2, 553, 51, 
	3, 2, 2, 2, 554, 555, 7, 64, 2, 2, 555, 556, 5, 54, 28, 2, 556, 53, 3, 
	2, 2, 2, 557, 559, 7, 127, 2, 2, 558, 557, 3, 2, 2, 2, 558, 559, 3, 2, 
	2, 2, 559, 560, 3, 2, 2, 2, 560, 562, 7, 65, 2, 2, 561, 558, 3, 2, 2, 2, 
	561, 562, 3, 2, 2, 2, 562, 563, 3, 2, 2, 2, 563, 564, 7, 127, 2, 2, 564, 
	567, 5, 56, 29, 2, 565, 566, 7, 127, 2, 2, 566, 568, 5, 60, 31, 2, 567, 
	565, 3, 2, 2, 2, 567, 568, 3, 2, 2, 2, 568, 571, 3, 2, 2, 2, 569, 570, 
	7, 127, 2, 2, 570, 572, 5, 62, 32, 2, 571, 569, 3, 2, 2, 2, 571, 572, 3, 
	2, 2, 2, 572, 575, 3, 2, 2, 2, 573, 574, 7, 127, 2, 2, 574, 576, 5, 64, 
	33, 2, 575, 573, 3, 2, 2, 2, 575, 576, 3, 2, 2, 2, 576, 55, 3, 2, 2, 2, 
	577, 588, 7, 7, 2, 2, 578, 580, 7, 127, 2, 2, 579, 578, 3, 2, 2, 2, 579, 
	580, 3, 2, 2, 2, 580, 581, 3, 2, 2, 2, 581, 583, 7, 4, 2, 2, 582, 584, 
	7, 127, 2, 2, 583, 582, 3, 2, 2, 2, 583, 584, 3, 2, 2, 2, 584, 585, 3, 
	2, 2, 2, 585, 587, 5, 58, 30, 2, 586, 579, 3, 2, 2, 2, 587, 590, 3, 2, 
	2, 2, 588, 586, 3, 2, 2, 2, 588, 589, 3, 2, 2, 2, 589, 606, 3, 2, 2, 2, 
	590, 588, 3, 2, 2, 2, 591, 602, 5, 58, 30, 2, 592, 594, 7, 127, 2, 2, 593, 
	592, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 595, 3, 2, 2, 2, 595, 597, 
	7, 4, 2, 2, 596, 598, 7, 127, 2, 2, 597, 596, 3, 2, 2, 2, 597, 598, 3, 
	2, 2, 2, 598, 599, 3, 2, 2, 2, 599, 601, 5, 58, 30, 2, 600, 593, 3, 2, 
	2, 2, 601, 604, 3, 2, 2, 2, 602, 600, 3, 2, 2, 2, 602, 603, 3, 2, 2, 2, 
	603, 606, 3, 2, 2, 2, 604, 602, 3, 2, 2, 2, 605, 577, 3, 2, 2, 2, 605, 
	591, 3, 2, 2, 2, 606, 57, 3, 2, 2, 2, 607, 608, 5, 104, 53, 2, 608, 609, 
	7, 127, 2, 2, 609, 610, 7, 53, 2, 2, 610, 611, 7, 127, 2, 2, 611, 612, 
	5, 176, 89, 2, 612, 615, 3, 2, 2, 2, 613, 615, 5, 104, 53, 2, 614, 607, 
	3, 2, 2, 2, 614, 613, 3, 2, 2, 2, 615, 59, 3, 2, 2, 2, 616, 617, 7, 66, 
	2, 2, 617, 618, 7, 127, 2, 2, 618, 619, 7, 67, 2, 2, 619, 620, 7, 127, 
	2, 2, 620, 628, 5, 66, 34, 2, 621, 623, 7, 4, 2, 2, 622, 624, 7, 127, 2, 
	2, 623, 622, 3, 2, 2, 2, 623, 624, 3, 2, 2, 2, 624, 625, 3, 2, 2, 2, 625, 
	627, 5, 66, 34, 2, 626, 621, 3, 2, 2, 2, 627, 630, 3, 2, 2, 2, 628, 626, 
	3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 61, 3, 2, 2, 2, 630, 628, 3, 2, 
	2, 2, 631, 632, 7, 68, 2, 2, 632, 633, 7, 127, 2, 2, 633, 634, 5, 104, 
	53, 2, 634, 63, 3, 2, 2, 2, 635, 636, 7, 69, 2, 2, 636, 637, 7, 127, 2, 
	2, 637, 638, 5, 104, 53, 2, 638, 65, 3, 2, 2, 2, 639, 644, 5, 104, 53, 
	2, 640, 642, 7, 127, 2, 2, 641, 640, 3, 2, 2, 2, 641, 642, 3, 2, 2, 2, 
	642, 643, 3, 2, 2, 2, 643, 645, 9, 2, 2, 2, 644, 641, 3, 2, 2, 2, 644, 
	645, 3, 2, 2, 2, 645, 67, 3, 2, 2, 2, 646, 647, 7, 74, 2, 2, 647, 648, 
	7, 127, 2, 2, 648, 649, 5, 104, 53, 2, 649, 69, 3, 2, 2, 2, 650, 661, 5, 
	72, 37, 2, 651, 653, 7, 127, 2, 2, 652, 651, 3, 2, 2, 2, 652, 653, 3, 2, 
	2, 2, 653, 654, 3, 2, 2, 2, 654, 656, 7, 4, 2, 2, 655, 657, 7, 127, 2, 
	2, 656, 655, 3, 2, 2, 2, 656, 657, 3, 2, 2, 2, 657, 658, 3, 2, 2, 2, 658, 
	660, 5, 72, 37, 2, 659, 652, 3, 2, 2, 2, 660, 663, 3, 2, 2, 2, 661, 659, 
	3, 2, 2, 2, 661, 662, 3, 2, 2, 2, 662, 71, 3, 2, 2, 2, 663, 661, 3, 2, 
	2, 2, 664, 666, 5, 176, 89, 2, 665, 667, 7, 127, 2, 2, 666, 665, 3, 2, 
	2, 2, 666, 667, 3, 2, 2, 2, 667, 668, 3, 2, 2, 2, 668, 670, 7, 5, 2, 2, 
	669, 671, 7, 127, 2, 2, 670, 669, 3, 2, 2, 2, 670, 671, 3, 2, 2, 2, 671, 
	672, 3, 2, 2, 2, 672, 673, 5, 74, 38, 2, 673, 676, 3, 2, 2, 2, 674, 676, 
	5, 74, 38, 2, 675, 664, 3, 2, 2, 2, 675, 674, 3, 2, 2, 2, 676, 73, 3, 2, 
	2, 2, 677, 678, 5, 76, 39, 2, 678, 75, 3, 2, 2, 2, 679, 686, 5, 80, 41, 
	2, 680, 682, 7, 127, 2, 2, 681, 680, 3, 2, 2, 2, 681, 682, 3, 2, 2, 2, 
	682, 683, 3, 2, 2, 2, 683, 685, 5, 82, 42, 2, 684, 681, 3, 2, 2, 2, 685, 
	688, 3, 2, 2, 2, 686, 684, 3, 2, 2, 2, 686, 687, 3, 2, 2, 2, 687, 694, 
	3, 2, 2, 2, 688, 686, 3, 2, 2, 2, 689, 690, 7, 8, 2, 2, 690, 691, 5, 76, 
	39, 2, 691, 692, 7, 9, 2, 2, 692, 694, 3, 2, 2, 2, 693, 679, 3, 2, 2, 2, 
	693, 689, 3, 2, 2, 2, 694, 77, 3, 2, 2, 2, 695, 700, 5, 80, 41, 2, 696, 
	698, 7, 127, 2, 2, 697, 696, 3, 2, 2, 2, 697, 698, 3, 2, 2, 2, 698, 699, 
	3, 2, 2, 2, 699, 701, 5, 82, 42, 2, 700, 697, 3, 2, 2, 2, 701, 702, 3, 
	2, 2, 2, 702, 700, 3, 2, 2, 2, 702, 703, 3, 2, 2, 2, 703, 79, 3, 2, 2, 
	2, 704, 706, 7, 8, 2, 2, 705, 707, 7, 127, 2, 2, 706, 705, 3, 2, 2, 2, 
	706, 707, 3, 2, 2, 2, 707, 712, 3, 2, 2, 2, 708, 710, 5, 176, 89, 2, 709, 
	711, 7, 127, 2, 2, 710, 709, 3, 2, 2, 2, 710, 711, 3, 2, 2, 2, 711, 713, 
	3, 2, 2, 2, 712, 708, 3, 2, 2, 2, 712, 713, 3, 2, 2, 2, 713, 718, 3, 2, 
	2, 2, 714, 716, 5, 92, 47, 2, 715, 717, 7, 127, 2, 2, 716, 715, 3, 2, 2, 
	2, 716, 717, 3, 2, 2, 2, 717, 719, 3, 2, 2, 2, 718, 714, 3, 2, 2, 2, 718, 
	719, 3, 2, 2, 2, 719, 724, 3, 2, 2, 2, 720, 722, 5, 88, 45, 2, 721, 723, 
	7, 127, 2, 2, 722, 721, 3, 2, 2, 2, 722, 723, 3, 2, 2, 2, 723, 725, 3, 
	2, 2, 2, 724, 720, 3, 2, 2, 2, 724, 725, 3, 2, 2, 2, 725, 726, 3, 2, 2, 
	2, 726, 727, 7, 9, 2, 2, 727, 81, 3, 2, 2, 2, 728, 730, 5, 84, 43, 2, 729, 
	731, 7, 127, 2, 2, 730, 729, 3, 2, 2, 2, 730, 731, 3, 2, 2, 2, 731, 732, 
	3, 2, 2, 2, 732, 733, 5, 80, 41, 2, 733, 83, 3, 2, 2, 2, 734, 736, 5, 202, 
	102, 2, 735, 737, 7, 127, 2, 2, 736, 735, 3, 2, 2, 2, 736, 737, 3, 2, 2, 
	2, 737, 738, 3, 2, 2, 2, 738, 740, 5, 206, 104, 2, 739, 741, 7, 127, 2, 
	2, 740, 739, 3, 2, 2, 2, 740, 741, 3, 2, 2, 2, 741, 743, 3, 2, 2, 2, 742, 
	744, 5, 86, 44, 2, 743, 742, 3, 2, 2, 2, 743, 744, 3, 2, 2, 2, 744, 746, 
	3, 2, 2, 2, 745, 747, 7, 127, 2, 2, 746, 745, 3, 2, 2, 2, 746, 747, 3, 
	2, 2, 2, 747, 748, 3, 2, 2, 2, 748, 750, 5, 206, 104, 2, 749, 751, 7, 127, 
	2, 2, 750, 749, 3, 2, 2, 2, 750, 751, 3, 2, 2, 2, 751, 752, 3, 2, 2, 2, 
	752, 753, 5, 204, 103, 2, 753, 799, 3, 2, 2, 2, 754, 756, 5, 202, 102, 
	2, 755, 757, 7, 127, 2, 2, 756, 755, 3, 2, 2, 2, 756, 757, 3, 2, 2, 2, 
	757, 758, 3, 2, 2, 2, 758, 760, 5, 206, 104, 2, 759, 761, 7, 127, 2, 2, 
	760, 759, 3, 2, 2, 2, 760, 761, 3, 2, 2, 2, 761, 763, 3, 2, 2, 2, 762, 
	764, 5, 86, 44, 2, 763, 762, 3, 2, 2, 2, 763, 764, 3, 2, 2, 2, 764, 766, 
	3, 2, 2, 2, 765, 767, 7, 127, 2, 2, 766, 765, 3, 2, 2, 2, 766, 767, 3, 
	2, 2, 2, 767, 768, 3, 2, 2, 2, 768, 769, 5, 206, 104, 2, 769, 799, 3, 2, 
	2, 2, 770, 772, 5, 206, 104, 2, 771, 773, 7, 127, 2, 2, 772, 771, 3, 2, 
	2, 2, 772, 773, 3, 2, 2, 2, 773, 775, 3, 2, 2, 2, 774, 776, 5, 86, 44, 
	2, 775, 774, 3, 2, 2, 2, 775, 776, 3, 2, 2, 2, 776, 778, 3, 2, 2, 2, 777, 
	779, 7, 127, 2, 2, 778, 777, 3, 2, 2, 2, 778, 779, 3, 2, 2, 2, 779, 780, 
	3, 2, 2, 2, 780, 782, 5, 206, 104, 2, 781, 783, 7, 127, 2, 2, 782, 781, 
	3, 2, 2, 2, 782, 783, 3, 2, 2, 2, 783, 784, 3, 2, 2, 2, 784, 785, 5, 204, 
	103, 2, 785, 799, 3, 2, 2, 2, 786, 788, 5, 206, 104, 2, 787, 789, 7, 127, 
	2, 2, 788, 787, 3, 2, 2, 2, 788, 789, 3, 2, 2, 2, 789, 791, 3, 2, 2, 2, 
	790, 792, 5, 86, 44, 2, 791, 790, 3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792, 
	794, 3, 2, 2, 2, 793, 795, 7, 127, 2, 2, 794, 793, 3, 2, 2, 2, 794, 795, 
	3, 2, 2, 2, 795, 796, 3, 2, 2, 2, 796, 797, 5, 206, 104, 2, 797, 799, 3, 
	2, 2, 2, 798, 734, 3, 2, 2, 2, 798, 754, 3, 2, 2, 2, 798, 770, 3, 2, 2, 
	2, 798, 786, 3, 2, 2, 2, 799, 85, 3, 2, 2, 2, 800, 802, 7, 10, 2, 2, 801, 
	803, 7, 127, 2, 2, 802, 801, 3, 2, 2, 2, 802, 803, 3, 2, 2, 2, 803, 808, 
	3, 2, 2, 2, 804, 806, 5, 176, 89, 2, 805, 807, 7, 127, 2, 2, 806, 805, 
	3, 2, 2, 2, 806, 807, 3, 2, 2, 2, 807, 809, 3, 2, 2, 2, 808, 804, 3, 2, 
	2, 2, 808, 809, 3, 2, 2, 2, 809, 814, 3, 2, 2, 2, 810, 812, 5, 90, 46, 
	2, 811, 813, 7, 127, 2, 2, 812, 811, 3, 2, 2, 2, 812, 813, 3, 2, 2, 2, 
	813, 815, 3, 2, 2, 2, 814, 810, 3, 2, 2, 2, 814, 815, 3, 2, 2, 2, 815, 
	817, 3, 2, 2, 2, 816, 818, 5, 96, 49, 2, 817, 816, 3, 2, 2, 2, 817, 818, 
	3, 2, 2, 2, 818, 823, 3, 2, 2, 2, 819, 821, 5, 88, 45, 2, 820, 822, 7, 
	127, 2, 2, 821, 820, 3, 2, 2, 2, 821, 822, 3, 2, 2, 2, 822, 824, 3, 2, 
	2, 2, 823, 819, 3, 2, 2, 2, 823, 824, 3, 2, 2, 2, 824, 825, 3, 2, 2, 2, 
	825, 826, 7, 11, 2, 2, 826, 87, 3, 2, 2, 2, 827, 830, 5, 190, 96, 2, 828, 
	830, 5, 194, 98, 2, 829, 827, 3, 2, 2, 2, 829, 828, 3, 2, 2, 2, 830, 89, 
	3, 2, 2, 2, 831, 833, 7, 12, 2, 2, 832, 834, 7, 127, 2, 2, 833, 832, 3, 
	2, 2, 2, 833, 834, 3, 2, 2, 2, 834, 835, 3, 2, 2, 2, 835, 849, 5, 100, 
	51, 2, 836, 838, 7, 127, 2, 2, 837, 836, 3, 2, 2, 2, 837, 838, 3, 2, 2, 
	2, 838, 839, 3, 2, 2, 2, 839, 841, 7, 13, 2, 2, 840, 842, 7, 12, 2, 2, 
	841, 840, 3, 2, 2, 2, 841, 842, 3, 2, 2, 2, 842, 844, 3, 2, 2, 2, 843, 
	845, 7, 127, 2, 2, 844, 843, 3, 2, 2, 2, 844, 845, 3, 2, 2, 2, 845, 846, 
	3, 2, 2, 2, 846, 848, 5, 100, 51, 2, 847, 837, 3, 2, 2, 2, 848, 851, 3, 
	2, 2, 2, 849, 847, 3, 2, 2, 2, 849, 850, 3, 2, 2, 2, 850, 91, 3, 2, 2, 
	2, 851, 849, 3, 2, 2, 2, 852, 859, 5, 94, 48, 2, 853, 855, 7, 127, 2, 2, 
	854, 853, 3, 2, 2, 2, 854, 855, 3, 2, 2, 2, 855, 856, 3, 2, 2, 2, 856, 
	858, 5, 94, 48, 2, 857, 854, 3, 2, 2, 2, 858, 861, 3, 2, 2, 2, 859, 857, 
	3, 2, 2, 2, 859, 860, 3, 2, 2, 2, 860, 93, 3, 2, 2, 2, 861, 859, 3, 2, 
	2, 2, 862, 864, 7, 12, 2, 2, 863, 865, 7, 127, 2, 2, 864, 863, 3, 2, 2, 
	2, 864, 865, 3, 2, 2, 2, 865, 866, 3, 2, 2, 2, 866, 867, 5, 98, 50, 2, 
	867, 95, 3, 2, 2, 2, 868, 870, 7, 7, 2, 2, 869, 871, 7, 127, 2, 2, 870, 
	869, 3, 2, 2, 2, 870, 871, 3, 2, 2, 2, 871, 876, 3, 2, 2, 2, 872, 874, 
	5, 184, 93, 2, 873, 875, 7, 127, 2, 2, 874, 873, 3, 2, 2, 2, 874, 875, 
	3, 2, 2, 2, 875, 877, 3, 2, 2, 2, 876, 872, 3, 2, 2, 2, 876, 877, 3, 2, 
	2, 2, 877, 888, 3, 2, 2, 2, 878, 880, 7, 14, 2, 2, 879, 881, 7, 127, 2, 
	2, 880, 879, 3, 2, 2, 2, 880, 881, 3, 2, 2, 2, 881, 886, 3, 2, 2, 2, 882, 
	884, 5, 184, 93, 2, 883, 885, 7, 127, 2, 2, 884, 883, 3, 2, 2, 2, 884, 
	885, 3, 2, 2, 2, 885, 887, 3, 2, 2, 2, 886, 882, 3, 2, 2, 2, 886, 887, 
	3, 2, 2, 2, 887, 889, 3, 2, 2, 2, 888, 878, 3, 2, 2, 2, 888, 889, 3, 2, 
	2, 2, 889, 97, 3, 2, 2, 2, 890, 891, 5, 196, 99, 2, 891, 99, 3, 2, 2, 2, 
	892, 893, 5, 196, 99, 2, 893, 101, 3, 2, 2, 2, 894, 899, 5, 140, 71, 2, 
	895, 897, 7, 127, 2, 2, 896, 895, 3, 2, 2, 2, 896, 897, 3, 2, 2, 2, 897, 
	898, 3, 2, 2, 2, 898, 900, 5, 138, 70, 2, 899, 896, 3, 2, 2, 2, 900, 901, 
	3, 2, 2, 2, 901, 899, 3, 2, 2, 2, 901, 902, 3, 2, 2, 2, 902, 103, 3, 2, 
	2, 2, 903, 904, 5, 106, 54, 2, 904, 105, 3, 2, 2, 2, 905, 912, 5, 108, 
	55, 2, 906, 907, 7, 127, 2, 2, 907, 908, 7, 75, 2, 2, 908, 909, 7, 127, 
	2, 2, 909, 911, 5, 108, 55, 2, 910, 906, 3, 2, 2, 2, 911, 914, 3, 2, 2, 
	2, 912, 910, 3, 2, 2, 2, 912, 913, 3, 2, 2, 2, 913, 107, 3, 2, 2, 2, 914, 
	912, 3, 2, 2, 2, 915, 922, 5, 110, 56, 2, 916, 917, 7, 127, 2, 2, 917, 
	918, 7, 76, 2, 2, 918, 919, 7, 127, 2, 2, 919, 921, 5, 110, 56, 2, 920, 
	916, 3, 2, 2, 2, 921, 924, 3, 2, 2, 2, 922, 920, 3, 2, 2, 2, 922, 923, 
	3, 2, 2, 2, 923, 109, 3, 2, 2, 2, 924, 922, 3, 2, 2, 2, 925, 932, 5, 112, 
	57, 2, 926, 927, 7, 127, 2, 2, 927, 928, 7, 77, 2, 2, 928, 929, 7, 127, 
	2, 2, 929, 931, 5, 112, 57, 2, 930, 926, 3, 2, 2, 2, 931, 934, 3, 2, 2, 
	2, 932, 930, 3, 2, 2, 2, 932, 933, 3, 2, 2, 2, 933, 111, 3, 2, 2, 2, 934, 
	932, 3, 2, 2, 2, 935, 937, 7, 78, 2, 2, 936, 938, 7, 127, 2, 2, 937, 936, 
	3, 2, 2, 2, 937, 938, 3, 2, 2, 2, 938, 940, 3, 2, 2, 2, 939, 935, 3, 2, 
	2, 2, 940, 943, 3, 2, 2, 2, 941, 939, 3, 2, 2, 2, 941, 942, 3, 2, 2, 2, 
	942, 944, 3, 2, 2, 2, 943, 941, 3, 2, 2, 2, 944, 945, 5, 114, 58, 2, 945, 
	113, 3, 2, 2, 2, 946, 953, 5, 118, 60, 2, 947, 949, 7, 127, 2, 2, 948, 
	947, 3, 2, 2, 2, 948, 949, 3, 2, 2, 2, 949, 950, 3, 2, 2, 2, 950, 952, 
	5, 116, 59, 2, 951, 948, 3, 2, 2, 2, 952, 955, 3, 2, 2, 2, 953, 951, 3, 
	2, 2, 2, 953, 954, 3, 2, 2, 2, 954, 115, 3, 2, 2, 2, 955, 953, 3, 2, 2, 
	2, 956, 958, 7, 5, 2, 2, 957, 959, 7, 127, 2, 2, 958, 957, 3, 2, 2, 2, 
	958, 959, 3, 2, 2, 2, 959, 960, 3, 2, 2, 2, 960, 987, 5, 118, 60, 2, 961, 
	963, 7, 15, 2, 2, 962, 964, 7, 127, 2, 2, 963, 962, 3, 2, 2, 2, 963, 964, 
	3, 2, 2, 2, 964, 965, 3, 2, 2, 2, 965, 987, 5, 118, 60, 2, 966, 968, 7, 
	16, 2, 2, 967, 969, 7, 127, 2, 2, 968, 967, 3, 2, 2, 2, 968, 969, 3, 2, 
	2, 2, 969, 970, 3, 2, 2, 2, 970, 987, 5, 118, 60, 2, 971, 973, 7, 17, 2, 
	2, 972, 974, 7, 127, 2, 2, 973, 972, 3, 2, 2, 2, 973, 974, 3, 2, 2, 2, 
	974, 975, 3, 2, 2, 2, 975, 987, 5, 118, 60, 2, 976, 978, 7, 18, 2, 2, 977, 
	979, 7, 127, 2, 2, 978, 977, 3, 2, 2, 2, 978, 979, 3, 2, 2, 2, 979, 980, 
	3, 2, 2, 2, 980, 987, 5, 118, 60, 2, 981, 983, 7, 19, 2, 2, 982, 984, 7, 
	127, 2, 2, 983, 982, 3, 2, 2, 2, 983, 984, 3, 2, 2, 2, 984, 985, 3, 2, 
	2, 2, 985, 987, 5, 118, 60, 2, 986, 956, 3, 2, 2, 2, 986, 961, 3, 2, 2, 
	2, 986, 966, 3, 2, 2, 2, 986, 971, 3, 2, 2, 2, 986, 976, 3, 2, 2, 2, 986, 
	981, 3, 2, 2, 2, 987, 117, 3, 2, 2, 2, 988, 994, 5, 126, 64, 2, 989, 993, 
	5, 120, 61, 2, 990, 993, 5, 122, 62, 2, 991, 993, 5, 124, 63, 2, 992, 989, 
	3, 2, 2, 2, 992, 990, 3, 2, 2, 2, 992, 991, 3, 2, 2, 2, 993, 996, 3, 2, 
	2, 2, 994, 992, 3, 2, 2, 2, 994, 995, 3, 2, 2, 2, 995, 119, 3, 2, 2, 2, 
	996, 994, 3, 2, 2, 2, 997, 998, 7, 127, 2, 2, 998, 999, 7, 79, 2, 2, 999, 
	1000, 7, 127, 2, 2, 1000, 1008, 7, 63, 2, 2, 1001, 1002, 7, 127, 2, 2, 
	1002, 1003, 7, 80, 2, 2, 1003, 1004, 7, 127, 2, 2, 1004, 1008, 7, 63, 2, 
	2, 1005, 1006, 7, 127, 2, 2, 1006, 1008, 7, 81, 2, 2, 1007, 997, 3, 2, 
	2, 2, 1007, 1001, 3, 2, 2, 2, 1007, 1005, 3, 2, 2, 2, 1008, 1010, 3, 2, 
	2, 2, 1009, 1011, 7, 127, 2, 2, 1010, 1009, 3, 2, 2, 2, 1010, 1011, 3, 
	2, 2, 2, 1011, 1012, 3, 2, 2, 2, 1012, 1013, 5, 126, 64, 2, 1013, 121, 
	3, 2, 2, 2, 1014, 1015, 7, 127, 2, 2, 1015, 1017, 7, 82, 2, 2, 1016, 1018, 
	7, 127, 2, 2, 1017, 1016, 3, 2, 2, 2, 1017, 1018, 3, 2, 2, 2, 1018, 1019, 
	3, 2, 2, 2, 1019, 1020, 5, 126, 64, 2, 1020, 123, 3, 2, 2, 2, 1021, 1022, 
	7, 127, 2, 2, 1022, 1023, 7, 83, 2, 2, 1023, 1024, 7, 127, 2, 2, 1024, 
	1032, 7, 84, 2, 2, 1025, 1026, 7, 127, 2, 2, 1026, 1027, 7, 83, 2, 2, 1027, 
	1028, 7, 127, 2, 2, 1028, 1029, 7, 78, 2, 2, 1029, 1030, 7, 127, 2, 2, 
	1030, 1032, 7, 84, 2, 2, 1031, 1021, 3, 2, 2, 2, 1031, 1025, 3, 2, 2, 2, 
	1032, 125, 3, 2, 2, 2, 1033, 1052, 5, 128, 65, 2, 1034, 1036, 7, 127, 2, 
	2, 1035, 1034, 3, 2, 2, 2, 1035, 1036, 3, 2, 2, 2, 1036, 1037, 3, 2, 2, 
	2, 1037, 1039, 7, 20, 2, 2, 1038, 1040, 7, 127, 2, 2, 1039, 1038, 3, 2, 
	2, 2, 1039, 1040, 3, 2, 2, 2, 1040, 1041, 3, 2, 2, 2, 1041, 1051, 5, 128, 
	65, 2, 1042, 1044, 7, 127, 2, 2, 1043, 1042, 3, 2, 2, 2, 1043, 1044, 3, 
	2, 2, 2, 1044, 1045, 3, 2, 2, 2, 1045, 1047, 7, 21, 2, 2, 1046, 1048, 7, 
	127, 2, 2, 1047, 1046, 3, 2, 2, 2, 1047, 1048, 3, 2, 2, 2, 1048, 1049, 
	3, 2, 2, 2, 1049, 1051, 5, 128, 65, 2, 1050, 1035, 3, 2, 2, 2, 1050, 1043, 
	3, 2, 2, 2, 1051, 1054, 3, 2, 2, 2, 1052, 1050, 3, 2, 2, 2, 1052, 1053, 
	3, 2, 2, 2, 1053, 127, 3, 2, 2, 2, 1054, 1052, 3, 2, 2, 2, 1055, 1082, 
	5, 130, 66, 2, 1056, 1058, 7, 127, 2, 2, 1057, 1056, 3, 2, 2, 2, 1057, 
	1058, 3, 2, 2, 2, 1058, 1059, 3, 2, 2, 2, 1059, 1061, 7, 7, 2, 2, 1060, 
	1062, 7, 127, 2, 2, 1061, 1060, 3, 2, 2, 2, 1061, 1062, 3, 2, 2, 2, 1062, 
	1063, 3, 2, 2, 2, 1063, 1081, 5, 130, 66, 2, 1064, 1066, 7, 127, 2, 2, 
	1065, 1064, 3, 2, 2, 2, 1065, 1066, 3, 2, 2, 2, 1066, 1067, 3, 2, 2, 2, 
	1067, 1069, 7, 22, 2, 2, 1068, 1070, 7, 127, 2, 2, 1069, 1068, 3, 2, 2, 
	2, 1069, 1070, 3, 2, 2, 2, 1070, 1071, 3, 2, 2, 2, 1071, 1081, 5, 130, 
	66, 2, 1072, 1074, 7, 127, 2, 2, 1073, 1072, 3, 2, 2, 2, 1073, 1074, 3, 
	2, 2, 2, 1074, 1075, 3, 2, 2, 2, 1075, 1077, 7, 23, 2, 2, 1076, 1078, 7, 
	127, 2, 2, 1077, 1076, 3, 2, 2, 2, 1077, 1078, 3, 2, 2, 2, 1078, 1079, 
	3, 2, 2, 2, 1079, 1081, 5, 130, 66, 2, 1080, 1057, 3, 2, 2, 2, 1080, 1065, 
	3, 2, 2, 2, 1080, 1073, 3, 2, 2, 2, 1081, 1084, 3, 2, 2, 2, 1082, 1080, 
	3, 2, 2, 2, 1082, 1083, 3, 2, 2, 2, 1083, 129, 3, 2, 2, 2, 1084, 1082, 
	3, 2, 2, 2, 1085, 1096, 5, 132, 67, 2, 1086, 1088, 7, 127, 2, 2, 1087, 
	1086, 3, 2, 2, 2, 1087, 1088, 3, 2, 2, 2, 1088, 1089, 3, 2, 2, 2, 1089, 
	1091, 7, 24, 2, 2, 1090, 1092, 7, 127, 2, 2, 1091, 1090, 3, 2, 2, 2, 1091, 
	1092, 3, 2, 2, 2, 1092, 1093, 3, 2, 2, 2, 1093, 1095, 5, 132, 67, 2, 1094, 
	1087, 3, 2, 2, 2, 1095, 1098, 3, 2, 2, 2, 1096, 1094, 3, 2, 2, 2, 1096, 
	1097, 3, 2, 2, 2, 1097, 131, 3, 2, 2, 2, 1098, 1096, 3, 2, 2, 2, 1099, 
	1106, 5, 134, 68, 2, 1100, 1102, 9, 3, 2, 2, 1101, 1103, 7, 127, 2, 2, 
	1102, 1101, 3, 2, 2, 2, 1102, 1103, 3, 2, 2, 2, 1103, 1104, 3, 2, 2, 2, 
	1104, 1106, 5, 134, 68, 2, 1105, 1099, 3, 2, 2, 2, 1105, 1100, 3, 2, 2, 
	2, 1106, 133, 3, 2, 2, 2, 1107, 1118, 5, 140, 71, 2, 1108, 1110, 7, 127, 
	2, 2, 1109, 1108, 3, 2, 2, 2, 1109, 1110, 3, 2, 2, 2, 1110, 1111, 3, 2, 
	2, 2, 1111, 1117, 5, 136, 69, 2, 1112, 1114, 7, 127, 2, 2, 1113, 1112, 
	3, 2, 2, 2, 1113, 1114, 3, 2, 2, 2, 1114, 1115, 3, 2, 2, 2, 1115, 1117, 
	5, 138, 70, 2, 1116, 1109, 3, 2, 2, 2, 1116, 1113, 3, 2, 2, 2, 1117, 1120, 
	3, 2, 2, 2, 1118, 1116, 3, 2, 2, 2, 1118, 1119, 3, 2, 2, 2, 1119, 1125, 
	3, 2, 2, 2, 1120, 1118, 3, 2, 2, 2, 1121, 1123, 7, 127, 2, 2, 1122, 1121, 
	3, 2, 2, 2, 1122, 1123, 3, 2, 2, 2, 1123, 1124, 3, 2, 2, 2, 1124, 1126, 
	5, 92, 47, 2, 1125, 1122, 3, 2, 2, 2, 1125, 1126, 3, 2, 2, 2, 1126, 135, 
	3, 2, 2, 2, 1127, 1128, 7, 10, 2, 2, 1128, 1129, 5, 104, 53, 2, 1129, 1130, 
	7, 11, 2, 2, 1130, 1141, 3, 2, 2, 2, 1131, 1133, 7, 10, 2, 2, 1132, 1134, 
	5, 104, 53, 2, 1133, 1132, 3, 2, 2, 2, 1133, 1134, 3, 2, 2, 2, 1134, 1135, 
	3, 2, 2, 2, 1135, 1137, 7, 14, 2, 2, 1136, 1138, 5, 104, 53, 2, 1137, 1136, 
	3, 2, 2, 2, 1137, 1138, 3, 2, 2, 2, 1138, 1139, 3, 2, 2, 2, 1139, 1141, 
	7, 11, 2, 2, 1140, 1127, 3, 2, 2, 2, 1140, 1131, 3, 2, 2, 2, 1141, 137, 
	3, 2, 2, 2, 1142, 1144, 7, 25, 2, 2, 1143, 1145, 7, 127, 2, 2, 1144, 1143, 
	3, 2, 2, 2, 1144, 1145, 3, 2, 2, 2, 1145, 1146, 3, 2, 2, 2, 1146, 1147, 
	5, 192, 97, 2, 1147, 139, 3, 2, 2, 2, 1148, 1173, 5, 178, 90, 2, 1149, 
	1173, 5, 194, 98, 2, 1150, 1173, 5, 142, 72, 2, 1151, 1153, 7, 85, 2, 2, 
	1152, 1154, 7, 127, 2, 2, 1153, 1152, 3, 2, 2, 2, 1153, 1154, 3, 2, 2, 
	2, 1154, 1155, 3, 2, 2, 2, 1155, 1157, 7, 8, 2, 2, 1156, 1158, 7, 127, 
	2, 2, 1157, 1156, 3, 2, 2, 2, 1157, 1158, 3, 2, 2, 2, 1158, 1159, 3, 2, 
	2, 2, 1159, 1161, 7, 7, 2, 2, 1160, 1162, 7, 127, 2, 2, 1161, 1160, 3, 
	2, 2, 2, 1161, 1162, 3, 2, 2, 2, 1162, 1163, 3, 2, 2, 2, 1163, 1173, 7, 
	9, 2, 2, 1164, 1173, 5, 146, 74, 2, 1165, 1173, 5, 148, 75, 2, 1166, 1173, 
	5, 150, 76, 2, 1167, 1173, 5, 154, 78, 2, 1168, 1173, 5, 156, 79, 2, 1169, 
	1173, 5, 160, 81, 2, 1170, 1173, 5, 164, 83, 2, 1171, 1173, 5, 176, 89, 
	2, 1172, 1148, 3, 2, 2, 2, 1172, 1149, 3, 2, 2, 2, 1172, 1150, 3, 2, 2, 
	2, 1172, 1151, 3, 2, 2, 2, 1172, 1164, 3, 2, 2, 2, 1172, 1165, 3, 2, 2, 
	2, 1172, 1166, 3, 2, 2, 2, 1172, 1167, 3, 2, 2, 2, 1172, 1168, 3, 2, 2, 
	2, 1172, 1169, 3, 2, 2, 2, 1172, 1170, 3, 2, 2, 2, 1172, 1171, 3, 2, 2, 
	2, 1173, 141, 3, 2, 2, 2, 1174, 1179, 7, 86, 2, 2, 1175, 1177, 7, 127, 
	2, 2, 1176, 1175, 3, 2, 2, 2, 1176, 1177, 3, 2, 2, 2, 1177, 1178, 3, 2, 
	2, 2, 1178, 1180, 5, 144, 73, 2, 1179, 1176, 3, 2, 2, 2, 1180, 1181, 3, 
	2, 2, 2, 1181, 1179, 3, 2, 2, 2, 1181, 1182, 3, 2, 2, 2, 1182, 1197, 3, 
	2, 2, 2, 1183, 1185, 7, 86, 2, 2, 1184, 1186, 7, 127, 2, 2, 1185, 1184, 
	3, 2, 2, 2, 1185, 1186, 3, 2, 2, 2, 1186, 1187, 3, 2, 2, 2, 1187, 1192, 
	5, 104, 53, 2, 1188, 1190, 7, 127, 2, 2, 1189, 1188, 3, 2, 2, 2, 1189, 
	1190, 3, 2, 2, 2, 1190, 1191, 3, 2, 2, 2, 1191, 1193, 5, 144, 73, 2, 1192, 
	1189, 3, 2, 2, 2, 1193, 1194, 3, 2, 2, 2, 1194, 1192, 3, 2, 2, 2, 1194, 
	1195, 3, 2, 2, 2, 1195, 1197, 3, 2, 2, 2, 1196, 1174, 3, 2, 2, 2, 1196, 
	1183, 3, 2, 2, 2, 1197, 1206, 3, 2, 2, 2, 1198, 1200, 7, 127, 2, 2, 1199, 
	1198, 3, 2, 2, 2, 1199, 1200, 3, 2, 2, 2, 1200, 1201, 3, 2, 2, 2, 1201, 
	1203, 7, 87, 2, 2, 1202, 1204, 7, 127, 2, 2, 1203, 1202, 3, 2, 2, 2, 1203, 
	1204, 3, 2, 2, 2, 1204, 1205, 3, 2, 2, 2, 1205, 1207, 5, 104, 53, 2, 1206, 
	1199, 3, 2, 2, 2, 1206, 1207, 3, 2, 2, 2, 1207, 1209, 3, 2, 2, 2, 1208, 
	1210, 7, 127, 2, 2, 1209, 1208, 3, 2, 2, 2, 1209, 1210, 3, 2, 2, 2, 1210, 
	1211, 3, 2, 2, 2, 1211, 1212, 7, 88, 2, 2, 1212, 143, 3, 2, 2, 2, 1213, 
	1215, 7, 89, 2, 2, 1214, 1216, 7, 127, 2, 2, 1215, 1214, 3, 2, 2, 2, 1215, 
	1216, 3, 2, 2, 2, 1216, 1217, 3, 2, 2, 2, 1217, 1219, 5, 104, 53, 2, 1218, 
	1220, 7, 127, 2, 2, 1219, 1218, 3, 2, 2, 2, 1219, 1220, 3, 2, 2, 2, 1220, 
	1221, 3, 2, 2, 2, 1221, 1223, 7, 90, 2, 2, 1222, 1224, 7, 127, 2, 2, 1223, 
	1222, 3, 2, 2, 2, 1223, 1224, 3, 2, 2, 2, 1224, 1225, 3, 2, 2, 2, 1225, 
	1226, 5, 104, 53, 2, 1226, 145, 3, 2, 2, 2, 1227, 1229, 7, 10, 2, 2, 1228, 
	1230, 7, 127, 2, 2, 1229, 1228, 3, 2, 2, 2, 1229, 1230, 3, 2, 2, 2, 1230, 
	1231, 3, 2, 2, 2, 1231, 1240, 5, 152, 77, 2, 1232, 1234, 7, 127, 2, 2, 
	1233, 1232, 3, 2, 2, 2, 1233, 1234, 3, 2, 2, 2, 1234, 1235, 3, 2, 2, 2, 
	1235, 1237, 7, 13, 2, 2, 1236, 1238, 7, 127, 2, 2, 1237, 1236, 3, 2, 2, 
	2, 1237, 1238, 3, 2, 2, 2, 1238, 1239, 3, 2, 2, 2, 1239, 1241, 5, 104, 
	53, 2, 1240, 1233, 3, 2, 2, 2, 1240, 1241, 3, 2, 2, 2, 1241, 1243, 3, 2, 
	2, 2, 1242, 1244, 7, 127, 2, 2, 1243, 1242, 3, 2, 2, 2, 1243, 1244, 3, 
	2, 2, 2, 1244, 1245, 3, 2, 2, 2, 1245, 1246, 7, 11, 2, 2, 1246, 147, 3, 
	2, 2, 2, 1247, 1249, 7, 10, 2, 2, 1248, 1250, 7, 127, 2, 2, 1249, 1248, 
	3, 2, 2, 2, 1249, 1250, 3, 2, 2, 2, 1250, 1259, 3, 2, 2, 2, 1251, 1253, 
	5, 176, 89, 2, 1252, 1254, 7, 127, 2, 2, 1253, 1252, 3, 2, 2, 2, 1253, 
	1254, 3, 2, 2, 2, 1254, 1255, 3, 2, 2, 2, 1255, 1257, 7, 5, 2, 2, 1256, 
	1258, 7, 127, 2, 2, 1257, 1256, 3, 2, 2, 2, 1257, 1258, 3, 2, 2, 2, 1258, 
	1260, 3, 2, 2, 2, 1259, 1251, 3, 2, 2, 2, 1259, 1260, 3, 2, 2, 2, 1260, 
	1261, 3, 2, 2, 2, 1261, 1263, 5, 78, 40, 2, 1262, 1264, 7, 127, 2, 2, 1263, 
	1262, 3, 2, 2, 2, 1263, 1264, 3, 2, 2, 2, 1264, 1269, 3, 2, 2, 2, 1265, 
	1267, 5, 68, 35, 2, 1266, 1268, 7, 127, 2, 2, 1267, 1266, 3, 2, 2, 2, 1267, 
	1268, 3, 2, 2, 2, 1268, 1270, 3, 2, 2, 2, 1269, 1265, 3, 2, 2, 2, 1269, 
	1270, 3, 2, 2, 2, 1270, 1271, 3, 2, 2, 2, 1271, 1273, 7, 13, 2, 2, 1272, 
	1274, 7, 127, 2, 2, 1273, 1272, 3, 2, 2, 2, 1273, 1274, 3, 2, 2, 2, 1274, 
	1275, 3, 2, 2, 2, 1275, 1277, 5, 104, 53, 2, 1276, 1278, 7, 127, 2, 2, 
	1277, 1276, 3, 2, 2, 2, 1277, 1278, 3, 2, 2, 2, 1278, 1279, 3, 2, 2, 2, 
	1279, 1280, 7, 11, 2, 2, 1280, 149, 3, 2, 2, 2, 1281, 1283, 7, 49, 2, 2, 
	1282, 1284, 7, 127, 2, 2, 1283, 1282, 3, 2, 2, 2, 1283, 1284, 3, 2, 2, 
	2, 1284, 1285, 3, 2, 2, 2, 1285, 1287, 7, 8, 2, 2, 1286, 1288, 7, 127, 
	2, 2, 1287, 1286, 3, 2, 2, 2, 1287, 1288, 3, 2, 2, 2, 1288, 1289, 3, 2, 
	2, 2, 1289, 1291, 5, 152, 77, 2, 1290, 1292, 7, 127, 2, 2, 1291, 1290, 
	3, 2, 2, 2, 1291, 1292, 3, 2, 2, 2, 1292, 1293, 3, 2, 2, 2, 1293, 1294, 
	7, 9, 2, 2, 1294, 1338, 3, 2, 2, 2, 1295, 1297, 7, 91, 2, 2, 1296, 1298, 
	7, 127, 2, 2, 1297, 1296, 3, 2, 2, 2, 1297, 1298, 3, 2, 2, 2, 1298, 1299, 
	3, 2, 2, 2, 1299, 1301, 7, 8, 2, 2, 1300, 1302, 7, 127, 2, 2, 1301, 1300, 
	3, 2, 2, 2, 1301, 1302, 3, 2, 2, 2, 1302, 1303, 3, 2, 2, 2, 1303, 1305, 
	5, 152, 77, 2, 1304, 1306, 7, 127, 2, 2, 1305, 1304, 3, 2, 2, 2, 1305, 
	1306, 3, 2, 2, 2, 1306, 1307, 3, 2, 2, 2, 1307, 1308, 7, 9, 2, 2, 1308, 
	1338, 3, 2, 2, 2, 1309, 1311, 7, 92, 2, 2, 1310, 1312, 7, 127, 2, 2, 1311, 
	1310, 3, 2, 2, 2, 1311, 1312, 3, 2, 2, 2, 1312, 1313, 3, 2, 2, 2, 1313, 
	1315, 7, 8, 2, 2, 1314, 1316, 7, 127, 2, 2, 1315, 1314, 3, 2, 2, 2, 1315, 
	1316, 3, 2, 2, 2, 1316, 1317, 3, 2, 2, 2, 1317, 1319, 5, 152, 77, 2, 1318, 
	1320, 7, 127, 2, 2, 1319, 1318, 3, 2, 2, 2, 1319, 1320, 3, 2, 2, 2, 1320, 
	1321, 3, 2, 2, 2, 1321, 1322, 7, 9, 2, 2, 1322, 1338, 3, 2, 2, 2, 1323, 
	1325, 7, 93, 2, 2, 1324, 1326, 7, 127, 2, 2, 1325, 1324, 3, 2, 2, 2, 1325, 
	1326, 3, 2, 2, 2, 1326, 1327, 3, 2, 2, 2, 1327, 1329, 7, 8, 2, 2, 1328, 
	1330, 7, 127, 2, 2, 1329, 1328, 3, 2, 2, 2, 1329, 1330, 3, 2, 2, 2, 1330, 
	1331, 3, 2, 2, 2, 1331, 1333, 5, 152, 77, 2, 1332, 1334, 7, 127, 2, 2, 
	1333, 1332, 3, 2, 2, 2, 1333, 1334, 3, 2, 2, 2, 1334, 1335, 3, 2, 2, 2, 
	1335, 1336, 7, 9, 2, 2, 1336, 1338, 3, 2, 2, 2, 1337, 1281, 3, 2, 2, 2, 
	1337, 1295, 3, 2, 2, 2, 1337, 1309, 3, 2, 2, 2, 1337, 1323, 3, 2, 2, 2, 
	1338, 151, 3, 2, 2, 2, 1339, 1344, 5, 158, 80, 2, 1340, 1342, 7, 127, 2, 
	2, 1341, 1340, 3, 2, 2, 2, 1341, 1342, 3, 2, 2, 2, 1342, 1343, 3, 2, 2, 
	2, 1343, 1345, 5, 68, 35, 2, 1344, 1341, 3, 2, 2, 2, 1344, 1345, 3, 2, 
	2, 2, 1345, 153, 3, 2, 2, 2, 1346, 1347, 5, 78, 40, 2, 1347, 155, 3, 2, 
	2, 2, 1348, 1350, 7, 8, 2, 2, 1349, 1351, 7, 127, 2, 2, 1350, 1349, 3, 
	2, 2, 2, 1350, 1351, 3, 2, 2, 2, 1351, 1352, 3, 2, 2, 2, 1352, 1354, 5, 
	104, 53, 2, 1353, 1355, 7, 127, 2, 2, 1354, 1353, 3, 2, 2, 2, 1354, 1355, 
	3, 2, 2, 2, 1355, 1356, 3, 2, 2, 2, 1356, 1357, 7, 9, 2, 2, 1357, 157, 
	3, 2, 2, 2, 1358, 1359, 5, 176, 89, 2, 1359, 1360, 7, 127, 2, 2, 1360, 
	1361, 7, 82, 2, 2, 1361, 1362, 7, 127, 2, 2, 1362, 1363, 5, 104, 53, 2, 
	1363, 159, 3, 2, 2, 2, 1364, 1366, 5, 162, 82, 2, 1365, 1367, 7, 127, 2, 
	2, 1366, 1365, 3, 2, 2, 2, 1366, 1367, 3, 2, 2, 2, 1367, 1368, 3, 2, 2, 
	2, 1368, 1370, 7, 8, 2, 2, 1369, 1371, 7, 127, 2, 2, 1370, 1369, 3, 2, 
	2, 2, 1370, 1371, 3, 2, 2, 2, 1371, 1376, 3, 2, 2, 2, 1372, 1374, 7, 65, 
	2, 2, 1373, 1375, 7, 127, 2, 2, 1374, 1373, 3, 2, 2, 2, 1374, 1375, 3, 
	2, 2, 2, 1375, 1377, 3, 2, 2, 2, 1376, 1372, 3, 2, 2, 2, 1376, 1377, 3, 
	2, 2, 2, 1377, 1395, 3, 2, 2, 2, 1378, 1380, 5, 104, 53, 2, 1379, 1381, 
	7, 127, 2, 2, 1380, 1379, 3, 2, 2, 2, 1380, 1381, 3, 2, 2, 2, 1381, 1392, 
	3, 2, 2, 2, 1382, 1384, 7, 4, 2, 2, 1383, 1385, 7, 127, 2, 2, 1384, 1383, 
	3, 2, 2, 2, 1384, 1385, 3, 2, 2, 2, 1385, 1386, 3, 2, 2, 2, 1386, 1388, 
	5, 104, 53, 2, 1387, 1389, 7, 127, 2, 2, 1388, 1387, 3, 2, 2, 2, 1388, 
	1389, 3, 2, 2, 2, 1389, 1391, 3, 2, 2, 2, 1390, 1382, 3, 2, 2, 2, 1391, 
	1394, 3, 2, 2, 2, 1392, 1390, 3, 2, 2, 2, 1392, 1393, 3, 2, 2, 2, 1393, 
	1396, 3, 2, 2, 2, 1394, 1392, 3, 2, 2, 2, 1395, 1378, 3, 2, 2, 2, 1395, 
	1396, 3, 2, 2, 2, 1396, 1397, 3, 2, 2, 2, 1397, 1398, 7, 9, 2, 2, 1398, 
	161, 3, 2, 2, 2, 1399, 1400, 5, 174, 88, 2, 1400, 1401, 5, 200, 101, 2, 
	1401, 163, 3, 2, 2, 2, 1402, 1404, 7, 94, 2, 2, 1403, 1405, 7, 127, 2, 
	2, 1404, 1403, 3, 2, 2, 2, 1404, 1405, 3, 2, 2, 2, 1405, 1406, 3, 2, 2, 
	2, 1406, 1408, 7, 26, 2, 2, 1407, 1409, 7, 127, 2, 2, 1408, 1407, 3, 2, 
	2, 2, 1408, 1409, 3, 2, 2, 2, 1409, 1418, 3, 2, 2, 2, 1410, 1419, 5, 8, 
	5, 2, 1411, 1416, 5, 70, 36, 2, 1412, 1414, 7, 127, 2, 2, 1413, 1412, 3, 
	2, 2, 2, 1413, 1414, 3, 2, 2, 2, 1414, 1415, 3, 2, 2, 2, 1415, 1417, 5, 
	68, 35, 2, 1416, 1413, 3, 2, 2, 2, 1416, 1417, 3, 2, 2, 2, 1417, 1419, 
	3, 2, 2, 2, 1418, 1410, 3, 2, 2, 2, 1418, 1411, 3, 2, 2, 2, 1419, 1421, 
	3, 2, 2, 2, 1420, 1422, 7, 127, 2, 2, 1421, 1420, 3, 2, 2, 2, 1421, 1422, 
	3, 2, 2, 2, 1422, 1423, 3, 2, 2, 2, 1423, 1424, 7, 27, 2, 2, 1424, 165, 
	3, 2, 2, 2, 1425, 1427, 5, 172, 87, 2, 1426, 1428, 7, 127, 2, 2, 1427, 
	1426, 3, 2, 2, 2, 1427, 1428, 3, 2, 2, 2, 1428, 1429, 3, 2, 2, 2, 1429, 
	1431, 7, 8, 2, 2, 1430, 1432, 7, 127, 2, 2, 1431, 1430, 3, 2, 2, 2, 1431, 
	1432, 3, 2, 2, 2, 1432, 1450, 3, 2, 2, 2, 1433, 1435, 5, 104, 53, 2, 1434, 
	1436, 7, 127, 2, 2, 1435, 1434, 3, 2, 2, 2, 1435, 1436, 3, 2, 2, 2, 1436, 
	1447, 3, 2, 2, 2, 1437, 1439, 7, 4, 2, 2, 1438, 1440, 7, 127, 2, 2, 1439, 
	1438, 3, 2, 2, 2, 1439, 1440, 3, 2, 2, 2, 1440, 1441, 3, 2, 2, 2, 1441, 
	1443, 5, 104, 53, 2, 1442, 1444, 7, 127, 2, 2, 1443, 1442, 3, 2, 2, 2, 
	1443, 1444, 3, 2, 2, 2, 1444, 1446, 3, 2, 2, 2, 1445, 1437, 3, 2, 2, 2, 
	1446, 1449, 3, 2, 2, 2, 1447, 1445, 3, 2, 2, 2, 1447, 1448, 3, 2, 2, 2, 
	1448, 1451, 3, 2, 2, 2, 1449, 1447, 3, 2, 2, 2, 1450, 1433, 3, 2, 2, 2, 
	1450, 1451, 3, 2, 2, 2, 1451, 1452, 3, 2, 2, 2, 1452, 1453, 7, 9, 2, 2, 
	1453, 167, 3, 2, 2, 2, 1454, 1455, 5, 172, 87, 2, 1455, 169, 3, 2, 2, 2, 
	1456, 1457, 5, 200, 101, 2, 1457, 171, 3, 2, 2, 2, 1458, 1459, 5, 174, 
	88, 2, 1459, 1460, 5, 200, 101, 2, 1460, 173, 3, 2, 2, 2, 1461, 1462, 5, 
	200, 101, 2, 1462, 1463, 7, 25, 2, 2, 1463, 1465, 3, 2, 2, 2, 1464, 1461, 
	3, 2, 2, 2, 1465, 1468, 3, 2, 2, 2, 1466, 1464, 3, 2, 2, 2, 1466, 1467, 
	3, 2, 2, 2, 1467, 175, 3, 2, 2, 2, 1468, 1466, 3, 2, 2, 2, 1469, 1470, 
	5, 200, 101, 2, 1470, 177, 3, 2, 2, 2, 1471, 1478, 5, 180, 91, 2, 1472, 
	1478, 7, 84, 2, 2, 1473, 1478, 5, 182, 92, 2, 1474, 1478, 7, 109, 2, 2, 
	1475, 1478, 5, 188, 95, 2, 1476, 1478, 5, 190, 96, 2, 1477, 1471, 3, 2, 
	2, 2, 1477, 1472, 3, 2, 2, 2, 1477, 1473, 3, 2, 2, 2, 1477, 1474, 3, 2, 
	2, 2, 1477, 1475, 3, 2, 2, 2, 1477, 1476, 3, 2, 2, 2, 1478, 179, 3, 2, 
	2, 2, 1479, 1480, 9, 4, 2, 2, 1480, 181, 3, 2, 2, 2, 1481, 1484, 5, 186, 
	94, 2, 1482, 1484, 5, 184, 93, 2, 1483, 1481, 3, 2, 2, 2, 1483, 1482, 3, 
	2, 2, 2, 1484, 183, 3, 2, 2, 2, 1485, 1486, 9, 5, 2, 2, 1486, 185, 3, 2, 
	2, 2, 1487, 1488, 9, 6, 2, 2, 1488, 187, 3, 2, 2, 2, 1489, 1491, 7, 10, 
	2, 2, 1490, 1492, 7, 127, 2, 2, 1491, 1490, 3, 2, 2, 2, 1491, 1492, 3, 
	2, 2, 2, 1492, 1510, 3, 2, 2, 2, 1493, 1495, 5, 104, 53, 2, 1494, 1496, 
	7, 127, 2, 2, 1495, 1494, 3, 2, 2, 2, 1495, 1496, 3, 2, 2, 2, 1496, 1507, 
	3, 2, 2, 2, 1497, 1499, 7, 4, 2, 2, 1498, 1500, 7, 127, 2, 2, 1499, 1498, 
	3, 2, 2, 2, 1499, 1500, 3, 2, 2, 2, 1500, 1501, 3, 2, 2, 2, 1501, 1503, 
	5, 104, 53, 2, 1502, 1504, 7, 127, 2, 2, 1503, 1502, 3, 2, 2, 2, 1503, 
	1504, 3, 2, 2, 2, 1504, 1506, 3, 2, 2, 2, 1505, 1497, 3, 2, 2, 2, 1506, 
	1509, 3, 2, 2, 2, 1507, 1505, 3, 2, 2, 2, 1507, 1508, 3, 2, 2, 2, 1508, 
	1511, 3, 2, 2, 2, 1509, 1507, 3, 2, 2, 2, 1510, 1493, 3, 2, 2, 2, 1510, 
	1511, 3, 2, 2, 2, 1511, 1512, 3, 2, 2, 2, 1512, 1513, 7, 11, 2, 2, 1513, 
	189, 3, 2, 2, 2, 1514, 1516, 7, 26, 2, 2, 1515, 1517, 7, 127, 2, 2, 1516, 
	1515, 3, 2, 2, 2, 1516, 1517, 3, 2, 2, 2, 1517, 1551, 3, 2, 2, 2, 1518, 
	1520, 5, 192, 97, 2, 1519, 1521, 7, 127, 2, 2, 1520, 1519, 3, 2, 2, 2, 
	1520, 1521, 3, 2, 2, 2, 1521, 1522, 3, 2, 2, 2, 1522, 1524, 7, 12, 2, 2, 
	1523, 1525, 7, 127, 2, 2, 1524, 1523, 3, 2, 2, 2, 1524, 1525, 3, 2, 2, 
	2, 1525, 1526, 3, 2, 2, 2, 1526, 1528, 5, 104, 53, 2, 1527, 1529, 7, 127, 
	2, 2, 1528, 1527, 3, 2, 2, 2, 1528, 1529, 3, 2, 2, 2, 1529, 1548, 3, 2, 
	2, 2, 1530, 1532, 7, 4, 2, 2, 1531, 1533, 7, 127, 2, 2, 1532, 1531, 3, 
	2, 2, 2, 1532, 1533, 3, 2, 2, 2, 1533, 1534, 3, 2, 2, 2, 1534, 1536, 5, 
	192, 97, 2, 1535, 1537, 7, 127, 2, 2, 1536, 1535, 3, 2, 2, 2, 1536, 1537, 
	3, 2, 2, 2, 1537, 1538, 3, 2, 2, 2, 1538, 1540, 7, 12, 2, 2, 1539, 1541, 
	7, 127, 2, 2, 1540, 1539, 3, 2, 2, 2, 1540, 1541, 3, 2, 2, 2, 1541, 1542, 
	3, 2, 2, 2, 1542, 1544, 5, 104, 53, 2, 1543, 1545, 7, 127, 2, 2, 1544, 
	1543, 3, 2, 2, 2, 1544, 1545, 3, 2, 2, 2, 1545, 1547, 3, 2, 2, 2, 1546, 
	1530, 3, 2, 2, 2, 1547, 1550, 3, 2, 2, 2, 1548, 1546, 3, 2, 2, 2, 1548, 
	1549, 3, 2, 2, 2, 1549, 1552, 3, 2, 2, 2, 1550, 1548, 3, 2, 2, 2, 1551, 
	1518, 3, 2, 2, 2, 1551, 1552, 3, 2, 2, 2, 1552, 1553, 3, 2, 2, 2, 1553, 
	1554, 7, 27, 2, 2, 1554, 191, 3, 2, 2, 2, 1555, 1556, 5, 196, 99, 2, 1556, 
	193, 3, 2, 2, 2, 1557, 1560, 7, 28, 2, 2, 1558, 1561, 5, 200, 101, 2, 1559, 
	1561, 7, 98, 2, 2, 1560, 1558, 3, 2, 2, 2, 1560, 1559, 3, 2, 2, 2, 1561, 
	195, 3, 2, 2, 2, 1562, 1565, 5, 200, 101, 2, 1563, 1565, 5, 198, 100, 2, 
	1564, 1562, 3, 2, 2, 2, 1564, 1563, 3, 2, 2, 2, 1565, 197, 3, 2, 2, 2, 
	1566, 1567, 9, 7, 2, 2, 1567, 199, 3, 2, 2, 2, 1568, 1569, 9, 8, 2, 2, 
	1569, 201, 3, 2, 2, 2, 1570, 1571, 9, 9, 2, 2, 1571, 203, 3, 2, 2, 2, 1572, 
	1573, 9, 10, 2, 2, 1573, 205, 3, 2, 2, 2, 1574, 1575, 9, 11, 2, 2, 1575, 
	207, 3, 2, 2, 2, 293, 209, 213, 216, 219, 227, 231, 236, 243, 248, 251, 
	255, 259, 263, 269, 273, 278, 283, 287, 290, 292, 296, 300, 305, 309, 314, 
	318, 327, 332, 336, 340, 344, 347, 351, 361, 368, 381, 385, 391, 395, 399, 
	404, 409, 413, 419, 423, 429, 433, 439, 443, 447, 451, 455, 459, 464, 471, 
	475, 480, 487, 493, 498, 504, 507, 513, 515, 519, 523, 528, 532, 535, 542, 
	549, 552, 558, 561, 567, 571, 575, 579, 583, 588, 593, 597, 602, 605, 614, 
	623, 628, 641, 644, 652, 656, 661, 666, 670, 675, 681, 686, 693, 697, 702, 
	706, 710, 712, 716, 718, 722, 724, 730, 736, 740, 743, 746, 750, 756, 760, 
	763, 766, 772, 775, 778, 782, 788, 791, 794, 798, 802, 806, 808, 812, 814, 
	817, 821, 823, 829, 833, 837, 841, 844, 849, 854, 859, 864, 870, 874, 876, 
	880, 884, 886, 888, 896, 901, 912, 922, 932, 937, 941, 948, 953, 958, 963, 
	968, 973, 978, 983, 986, 992, 994, 1007, 1010, 1017, 1031, 1035, 1039, 
	1043, 1047, 1050, 1052, 1057, 1061, 1065, 1069, 1073, 1077, 1080, 1082, 
	1087, 1091, 1096, 1102, 1105, 1109, 1113, 1116, 1118, 1122, 1125, 1133, 
	1137, 1140, 1144, 1153, 1157, 1161, 1172, 1176, 1181, 1185, 1189, 1194, 
	1196, 1199, 1203, 1206, 1209, 1215, 1219, 1223, 1229, 1233, 1237, 1240, 
	1243, 1249, 1253, 1257, 1259, 1263, 1267, 1269, 1273, 1277, 1283, 1287, 
	1291, 1297, 1301, 1305, 1311, 1315, 1319, 1325, 1329, 1333, 1337, 1341, 
	1344, 1350, 1354, 1366, 1370, 1374, 1376, 1380, 1384, 1388, 1392, 1395, 
	1404, 1408, 1413, 1416, 1418, 1421, 1427, 1431, 1435, 1439, 1443, 1447, 
	1450, 1466, 1477, 1483, 1491, 1495, 1499, 1503, 1507, 1510, 1516, 1520, 
	1524, 1528, 1532, 1536, 1540, 1544, 1548, 1551, 1560, 1564,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "';'", "','", "'='", "'+='", "'*'", "'('", "')'", "'['", "']'", "':'", 
	"'|'", "'..'", "'<>'", "'<'", "'>'", "'<='", "'>='", "'+'", "'-'", "'/'", 
	"'%'", "'^'", "'.'", "'{'", "'}'", "'$'", "'\u27E8'", "'\u3008'", "'\uFE64'", 
	"'\uFF1C'", "'\u27E9'", "'\u3009'", "'\uFE65'", "'\uFF1E'", "'\u00AD'", 
	"'\u2010'", "'\u2011'", "'\u2012'", "'\u2013'", "'\u2014'", "'\u2015'", 
	"'\u2212'", "'\uFE58'", "'\uFE63'", "'\uFF0D'", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'0'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "UNION", "ALL", "OPTIONAL", "MATCH", 
	"UNWIND", "AS", "MERGE", "ON", "CREATE", "SET", "DETACH", "DELETE", "REMOVE", 
	"CALL", "YIELD", "WITH", "RETURN", "DISTINCT", "ORDER", "BY", "L_SKIP", 
	"LIMIT", "ASCENDING", "ASC", "DESCENDING", "DESC", "WHERE", "OR", "XOR", 
	"AND", "NOT", "STARTS", "ENDS", "CONTAINS", "IN", "IS", "NULL", "COUNT", 
	"CASE", "ELSE", "END", "WHEN", "THEN", "ANY", "NONE", "SINGLE", "EXISTS", 
	"TRUE", "FALSE", "HexInteger", "DecimalInteger", "OctalInteger", "HexLetter", 
	"HexDigit", "Digit", "NonZeroDigit", "NonZeroOctDigit", "OctDigit", "ZeroDigit", 
	"ExponentDecimalReal", "RegularDecimalReal", "StringLiteral", "EscapedChar", 
	"CONSTRAINT", "DO", "FOR", "REQUIRE", "UNIQUE", "MANDATORY", "SCALAR", 
	"OF", "ADD", "DROP", "FILTER", "EXTRACT", "UnescapedSymbolicName", "IdentifierStart", 
	"IdentifierPart", "EscapedSymbolicName", "SP", "WHITESPACE", "Comment",
}

var ruleNames = []string{
	"oC_Cypher", "oC_Statement", "oC_Query", "oC_RegularQuery", "oC_Union", 
	"oC_SingleQuery", "oC_SinglePartQuery", "oC_MultiPartQuery", "oC_UpdatingClause", 
	"oC_ReadingClause", "oC_Match", "oC_Unwind", "oC_Merge", "oC_MergeAction", 
	"oC_Create", "oC_Set", "oC_SetItem", "oC_Delete", "oC_Remove", "oC_RemoveItem", 
	"oC_InQueryCall", "oC_StandaloneCall", "oC_YieldItems", "oC_YieldItem", 
	"oC_With", "oC_Return", "oC_ProjectionBody", "oC_ProjectionItems", "oC_ProjectionItem", 
	"oC_Order", "oC_Skip", "oC_Limit", "oC_SortItem", "oC_Where", "oC_Pattern", 
	"oC_PatternPart", "oC_AnonymousPatternPart", "oC_PatternElement", "oC_RelationshipsPattern", 
	"oC_NodePattern", "oC_PatternElementChain", "oC_RelationshipPattern", "oC_RelationshipDetail", 
	"oC_Properties", "oC_RelationshipTypes", "oC_NodeLabels", "oC_NodeLabel", 
	"oC_RangeLiteral", "oC_LabelName", "oC_RelTypeName", "oC_PropertyExpression", 
	"oC_Expression", "oC_OrExpression", "oC_XorExpression", "oC_AndExpression", 
	"oC_NotExpression", "oC_ComparisonExpression", "oC_PartialComparisonExpression", 
	"oC_StringListNullPredicateExpression", "oC_StringPredicateExpression", 
	"oC_ListPredicateExpression", "oC_NullPredicateExpression", "oC_AddOrSubtractExpression", 
	"oC_MultiplyDivideModuloExpression", "oC_PowerOfExpression", "oC_UnaryAddOrSubtractExpression", 
	"oC_NonArithmeticOperatorExpression", "oC_ListOperatorExpression", "oC_PropertyLookup", 
	"oC_Atom", "oC_CaseExpression", "oC_CaseAlternative", "oC_ListComprehension", 
	"oC_PatternComprehension", "oC_Quantifier", "oC_FilterExpression", "oC_PatternPredicate", 
	"oC_ParenthesizedExpression", "oC_IdInColl", "oC_FunctionInvocation", "oC_FunctionName", 
	"oC_ExistentialSubquery", "oC_ExplicitProcedureInvocation", "oC_ImplicitProcedureInvocation", 
	"oC_ProcedureResultField", "oC_ProcedureName", "oC_Namespace", "oC_Variable", 
	"oC_Literal", "oC_BooleanLiteral", "oC_NumberLiteral", "oC_IntegerLiteral", 
	"oC_DoubleLiteral", "oC_ListLiteral", "oC_MapLiteral", "oC_PropertyKeyName", 
	"oC_Parameter", "oC_SchemaName", "oC_ReservedWord", "oC_SymbolicName", 
	"oC_LeftArrowHead", "oC_RightArrowHead", "oC_Dash",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type CypherParser struct {
	*antlr.BaseParser
}

func NewCypherParser(input antlr.TokenStream) *CypherParser {
	this := new(CypherParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Cypher.g4"

	return this
}

// CypherParser tokens.
const (
	CypherParserEOF = antlr.TokenEOF
	CypherParserT__0 = 1
	CypherParserT__1 = 2
	CypherParserT__2 = 3
	CypherParserT__3 = 4
	CypherParserT__4 = 5
	CypherParserT__5 = 6
	CypherParserT__6 = 7
	CypherParserT__7 = 8
	CypherParserT__8 = 9
	CypherParserT__9 = 10
	CypherParserT__10 = 11
	CypherParserT__11 = 12
	CypherParserT__12 = 13
	CypherParserT__13 = 14
	CypherParserT__14 = 15
	CypherParserT__15 = 16
	CypherParserT__16 = 17
	CypherParserT__17 = 18
	CypherParserT__18 = 19
	CypherParserT__19 = 20
	CypherParserT__20 = 21
	CypherParserT__21 = 22
	CypherParserT__22 = 23
	CypherParserT__23 = 24
	CypherParserT__24 = 25
	CypherParserT__25 = 26
	CypherParserT__26 = 27
	CypherParserT__27 = 28
	CypherParserT__28 = 29
	CypherParserT__29 = 30
	CypherParserT__30 = 31
	CypherParserT__31 = 32
	CypherParserT__32 = 33
	CypherParserT__33 = 34
	CypherParserT__34 = 35
	CypherParserT__35 = 36
	CypherParserT__36 = 37
	CypherParserT__37 = 38
	CypherParserT__38 = 39
	CypherParserT__39 = 40
	CypherParserT__40 = 41
	CypherParserT__41 = 42
	CypherParserT__42 = 43
	CypherParserT__43 = 44
	CypherParserT__44 = 45
	CypherParserUNION = 46
	CypherParserALL = 47
	CypherParserOPTIONAL = 48
	CypherParserMATCH = 49
	CypherParserUNWIND = 50
	CypherParserAS = 51
	CypherParserMERGE = 52
	CypherParserON = 53
	CypherParserCREATE = 54
	CypherParserSET = 55
	CypherParserDETACH = 56
	CypherParserDELETE = 57
	CypherParserREMOVE = 58
	CypherParserCALL = 59
	CypherParserYIELD = 60
	CypherParserWITH = 61
	CypherParserRETURN = 62
	CypherParserDISTINCT = 63
	CypherParserORDER = 64
	CypherParserBY = 65
	CypherParserL_SKIP = 66
	CypherParserLIMIT = 67
	CypherParserASCENDING = 68
	CypherParserASC = 69
	CypherParserDESCENDING = 70
	CypherParserDESC = 71
	CypherParserWHERE = 72
	CypherParserOR = 73
	CypherParserXOR = 74
	CypherParserAND = 75
	CypherParserNOT = 76
	CypherParserSTARTS = 77
	CypherParserENDS = 78
	CypherParserCONTAINS = 79
	CypherParserIN = 80
	CypherParserIS = 81
	CypherParserNULL = 82
	CypherParserCOUNT = 83
	CypherParserCASE = 84
	CypherParserELSE = 85
	CypherParserEND = 86
	CypherParserWHEN = 87
	CypherParserTHEN = 88
	CypherParserANY = 89
	CypherParserNONE = 90
	CypherParserSINGLE = 91
	CypherParserEXISTS = 92
	CypherParserTRUE = 93
	CypherParserFALSE = 94
	CypherParserHexInteger = 95
	CypherParserDecimalInteger = 96
	CypherParserOctalInteger = 97
	CypherParserHexLetter = 98
	CypherParserHexDigit = 99
	CypherParserDigit = 100
	CypherParserNonZeroDigit = 101
	CypherParserNonZeroOctDigit = 102
	CypherParserOctDigit = 103
	CypherParserZeroDigit = 104
	CypherParserExponentDecimalReal = 105
	CypherParserRegularDecimalReal = 106
	CypherParserStringLiteral = 107
	CypherParserEscapedChar = 108
	CypherParserCONSTRAINT = 109
	CypherParserDO = 110
	CypherParserFOR = 111
	CypherParserREQUIRE = 112
	CypherParserUNIQUE = 113
	CypherParserMANDATORY = 114
	CypherParserSCALAR = 115
	CypherParserOF = 116
	CypherParserADD = 117
	CypherParserDROP = 118
	CypherParserFILTER = 119
	CypherParserEXTRACT = 120
	CypherParserUnescapedSymbolicName = 121
	CypherParserIdentifierStart = 122
	CypherParserIdentifierPart = 123
	CypherParserEscapedSymbolicName = 124
	CypherParserSP = 125
	CypherParserWHITESPACE = 126
	CypherParserComment = 127
)

// CypherParser rules.
const (
	CypherParserRULE_oC_Cypher = 0
	CypherParserRULE_oC_Statement = 1
	CypherParserRULE_oC_Query = 2
	CypherParserRULE_oC_RegularQuery = 3
	CypherParserRULE_oC_Union = 4
	CypherParserRULE_oC_SingleQuery = 5
	CypherParserRULE_oC_SinglePartQuery = 6
	CypherParserRULE_oC_MultiPartQuery = 7
	CypherParserRULE_oC_UpdatingClause = 8
	CypherParserRULE_oC_ReadingClause = 9
	CypherParserRULE_oC_Match = 10
	CypherParserRULE_oC_Unwind = 11
	CypherParserRULE_oC_Merge = 12
	CypherParserRULE_oC_MergeAction = 13
	CypherParserRULE_oC_Create = 14
	CypherParserRULE_oC_Set = 15
	CypherParserRULE_oC_SetItem = 16
	CypherParserRULE_oC_Delete = 17
	CypherParserRULE_oC_Remove = 18
	CypherParserRULE_oC_RemoveItem = 19
	CypherParserRULE_oC_InQueryCall = 20
	CypherParserRULE_oC_StandaloneCall = 21
	CypherParserRULE_oC_YieldItems = 22
	CypherParserRULE_oC_YieldItem = 23
	CypherParserRULE_oC_With = 24
	CypherParserRULE_oC_Return = 25
	CypherParserRULE_oC_ProjectionBody = 26
	CypherParserRULE_oC_ProjectionItems = 27
	CypherParserRULE_oC_ProjectionItem = 28
	CypherParserRULE_oC_Order = 29
	CypherParserRULE_oC_Skip = 30
	CypherParserRULE_oC_Limit = 31
	CypherParserRULE_oC_SortItem = 32
	CypherParserRULE_oC_Where = 33
	CypherParserRULE_oC_Pattern = 34
	CypherParserRULE_oC_PatternPart = 35
	CypherParserRULE_oC_AnonymousPatternPart = 36
	CypherParserRULE_oC_PatternElement = 37
	CypherParserRULE_oC_RelationshipsPattern = 38
	CypherParserRULE_oC_NodePattern = 39
	CypherParserRULE_oC_PatternElementChain = 40
	CypherParserRULE_oC_RelationshipPattern = 41
	CypherParserRULE_oC_RelationshipDetail = 42
	CypherParserRULE_oC_Properties = 43
	CypherParserRULE_oC_RelationshipTypes = 44
	CypherParserRULE_oC_NodeLabels = 45
	CypherParserRULE_oC_NodeLabel = 46
	CypherParserRULE_oC_RangeLiteral = 47
	CypherParserRULE_oC_LabelName = 48
	CypherParserRULE_oC_RelTypeName = 49
	CypherParserRULE_oC_PropertyExpression = 50
	CypherParserRULE_oC_Expression = 51
	CypherParserRULE_oC_OrExpression = 52
	CypherParserRULE_oC_XorExpression = 53
	CypherParserRULE_oC_AndExpression = 54
	CypherParserRULE_oC_NotExpression = 55
	CypherParserRULE_oC_ComparisonExpression = 56
	CypherParserRULE_oC_PartialComparisonExpression = 57
	CypherParserRULE_oC_StringListNullPredicateExpression = 58
	CypherParserRULE_oC_StringPredicateExpression = 59
	CypherParserRULE_oC_ListPredicateExpression = 60
	CypherParserRULE_oC_NullPredicateExpression = 61
	CypherParserRULE_oC_AddOrSubtractExpression = 62
	CypherParserRULE_oC_MultiplyDivideModuloExpression = 63
	CypherParserRULE_oC_PowerOfExpression = 64
	CypherParserRULE_oC_UnaryAddOrSubtractExpression = 65
	CypherParserRULE_oC_NonArithmeticOperatorExpression = 66
	CypherParserRULE_oC_ListOperatorExpression = 67
	CypherParserRULE_oC_PropertyLookup = 68
	CypherParserRULE_oC_Atom = 69
	CypherParserRULE_oC_CaseExpression = 70
	CypherParserRULE_oC_CaseAlternative = 71
	CypherParserRULE_oC_ListComprehension = 72
	CypherParserRULE_oC_PatternComprehension = 73
	CypherParserRULE_oC_Quantifier = 74
	CypherParserRULE_oC_FilterExpression = 75
	CypherParserRULE_oC_PatternPredicate = 76
	CypherParserRULE_oC_ParenthesizedExpression = 77
	CypherParserRULE_oC_IdInColl = 78
	CypherParserRULE_oC_FunctionInvocation = 79
	CypherParserRULE_oC_FunctionName = 80
	CypherParserRULE_oC_ExistentialSubquery = 81
	CypherParserRULE_oC_ExplicitProcedureInvocation = 82
	CypherParserRULE_oC_ImplicitProcedureInvocation = 83
	CypherParserRULE_oC_ProcedureResultField = 84
	CypherParserRULE_oC_ProcedureName = 85
	CypherParserRULE_oC_Namespace = 86
	CypherParserRULE_oC_Variable = 87
	CypherParserRULE_oC_Literal = 88
	CypherParserRULE_oC_BooleanLiteral = 89
	CypherParserRULE_oC_NumberLiteral = 90
	CypherParserRULE_oC_IntegerLiteral = 91
	CypherParserRULE_oC_DoubleLiteral = 92
	CypherParserRULE_oC_ListLiteral = 93
	CypherParserRULE_oC_MapLiteral = 94
	CypherParserRULE_oC_PropertyKeyName = 95
	CypherParserRULE_oC_Parameter = 96
	CypherParserRULE_oC_SchemaName = 97
	CypherParserRULE_oC_ReservedWord = 98
	CypherParserRULE_oC_SymbolicName = 99
	CypherParserRULE_oC_LeftArrowHead = 100
	CypherParserRULE_oC_RightArrowHead = 101
	CypherParserRULE_oC_Dash = 102
)

// IOC_CypherContext is an interface to support dynamic dispatch.
type IOC_CypherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_CypherContext differentiates from other interfaces.
	IsOC_CypherContext()
}

type OC_CypherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_CypherContext() *OC_CypherContext {
	var p = new(OC_CypherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Cypher
	return p
}

func (*OC_CypherContext) IsOC_CypherContext() {}

func NewOC_CypherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_CypherContext {
	var p = new(OC_CypherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Cypher

	return p
}

func (s *OC_CypherContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_CypherContext) OC_Statement() IOC_StatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_StatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_StatementContext)
}

func (s *OC_CypherContext) EOF() antlr.TerminalNode {
	return s.GetToken(CypherParserEOF, 0)
}

func (s *OC_CypherContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_CypherContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_CypherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_CypherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_CypherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Cypher(s)
	}
}

func (s *OC_CypherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Cypher(s)
	}
}




func (p *CypherParser) OC_Cypher() (localctx IOC_CypherContext) {
	localctx = NewOC_CypherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CypherParserRULE_oC_Cypher)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(207)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(206)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(209)
		p.OC_Statement()
	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		p.SetState(211)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(210)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(213)
			p.Match(CypherParserT__0)
		}


	}
	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(216)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(219)
		p.Match(CypherParserEOF)
	}



	return localctx
}


// IOC_StatementContext is an interface to support dynamic dispatch.
type IOC_StatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_StatementContext differentiates from other interfaces.
	IsOC_StatementContext()
}

type OC_StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_StatementContext() *OC_StatementContext {
	var p = new(OC_StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Statement
	return p
}

func (*OC_StatementContext) IsOC_StatementContext() {}

func NewOC_StatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_StatementContext {
	var p = new(OC_StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Statement

	return p
}

func (s *OC_StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_StatementContext) OC_Query() IOC_QueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_QueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_QueryContext)
}

func (s *OC_StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Statement(s)
	}
}

func (s *OC_StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Statement(s)
	}
}




func (p *CypherParser) OC_Statement() (localctx IOC_StatementContext) {
	localctx = NewOC_StatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CypherParserRULE_oC_Statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(221)
		p.OC_Query()
	}



	return localctx
}


// IOC_QueryContext is an interface to support dynamic dispatch.
type IOC_QueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_QueryContext differentiates from other interfaces.
	IsOC_QueryContext()
}

type OC_QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_QueryContext() *OC_QueryContext {
	var p = new(OC_QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Query
	return p
}

func (*OC_QueryContext) IsOC_QueryContext() {}

func NewOC_QueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_QueryContext {
	var p = new(OC_QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Query

	return p
}

func (s *OC_QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_QueryContext) OC_RegularQuery() IOC_RegularQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RegularQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_RegularQueryContext)
}

func (s *OC_QueryContext) OC_StandaloneCall() IOC_StandaloneCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_StandaloneCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_StandaloneCallContext)
}

func (s *OC_QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Query(s)
	}
}

func (s *OC_QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Query(s)
	}
}




func (p *CypherParser) OC_Query() (localctx IOC_QueryContext) {
	localctx = NewOC_QueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CypherParserRULE_oC_Query)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(223)
			p.OC_RegularQuery()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(224)
			p.OC_StandaloneCall()
		}

	}


	return localctx
}


// IOC_RegularQueryContext is an interface to support dynamic dispatch.
type IOC_RegularQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RegularQueryContext differentiates from other interfaces.
	IsOC_RegularQueryContext()
}

type OC_RegularQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RegularQueryContext() *OC_RegularQueryContext {
	var p = new(OC_RegularQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_RegularQuery
	return p
}

func (*OC_RegularQueryContext) IsOC_RegularQueryContext() {}

func NewOC_RegularQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RegularQueryContext {
	var p = new(OC_RegularQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_RegularQuery

	return p
}

func (s *OC_RegularQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RegularQueryContext) OC_SingleQuery() IOC_SingleQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SingleQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SingleQueryContext)
}

func (s *OC_RegularQueryContext) AllOC_Union() []IOC_UnionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_UnionContext)(nil)).Elem())
	var tst = make([]IOC_UnionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_UnionContext)
		}
	}

	return tst
}

func (s *OC_RegularQueryContext) OC_Union(i int) IOC_UnionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_UnionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_UnionContext)
}

func (s *OC_RegularQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_RegularQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_RegularQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RegularQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_RegularQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_RegularQuery(s)
	}
}

func (s *OC_RegularQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_RegularQuery(s)
	}
}




func (p *CypherParser) OC_RegularQuery() (localctx IOC_RegularQueryContext) {
	localctx = NewOC_RegularQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CypherParserRULE_oC_RegularQuery)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(227)
		p.OC_SingleQuery()
	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(229)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(228)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(231)
				p.OC_Union()
			}


		}
		p.SetState(236)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_UnionContext is an interface to support dynamic dispatch.
type IOC_UnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_UnionContext differentiates from other interfaces.
	IsOC_UnionContext()
}

type OC_UnionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_UnionContext() *OC_UnionContext {
	var p = new(OC_UnionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Union
	return p
}

func (*OC_UnionContext) IsOC_UnionContext() {}

func NewOC_UnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_UnionContext {
	var p = new(OC_UnionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Union

	return p
}

func (s *OC_UnionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_UnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(CypherParserUNION, 0)
}

func (s *OC_UnionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_UnionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_UnionContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *OC_UnionContext) OC_SingleQuery() IOC_SingleQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SingleQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SingleQueryContext)
}

func (s *OC_UnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_UnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_UnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Union(s)
	}
}

func (s *OC_UnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Union(s)
	}
}




func (p *CypherParser) OC_Union() (localctx IOC_UnionContext) {
	localctx = NewOC_UnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CypherParserRULE_oC_Union)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(237)
			p.Match(CypherParserUNION)
		}
		{
			p.SetState(238)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(239)
			p.Match(CypherParserALL)
		}
		p.SetState(241)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(240)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(243)
			p.OC_SingleQuery()
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(244)
			p.Match(CypherParserUNION)
		}
		p.SetState(246)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(245)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(248)
			p.OC_SingleQuery()
		}


	}


	return localctx
}


// IOC_SingleQueryContext is an interface to support dynamic dispatch.
type IOC_SingleQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SingleQueryContext differentiates from other interfaces.
	IsOC_SingleQueryContext()
}

type OC_SingleQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SingleQueryContext() *OC_SingleQueryContext {
	var p = new(OC_SingleQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_SingleQuery
	return p
}

func (*OC_SingleQueryContext) IsOC_SingleQueryContext() {}

func NewOC_SingleQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SingleQueryContext {
	var p = new(OC_SingleQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_SingleQuery

	return p
}

func (s *OC_SingleQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SingleQueryContext) OC_SinglePartQuery() IOC_SinglePartQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SinglePartQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SinglePartQueryContext)
}

func (s *OC_SingleQueryContext) OC_MultiPartQuery() IOC_MultiPartQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_MultiPartQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_MultiPartQueryContext)
}

func (s *OC_SingleQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SingleQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_SingleQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_SingleQuery(s)
	}
}

func (s *OC_SingleQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_SingleQuery(s)
	}
}




func (p *CypherParser) OC_SingleQuery() (localctx IOC_SingleQueryContext) {
	localctx = NewOC_SingleQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CypherParserRULE_oC_SingleQuery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(253)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(251)
			p.OC_SinglePartQuery()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(252)
			p.OC_MultiPartQuery()
		}

	}


	return localctx
}


// IOC_SinglePartQueryContext is an interface to support dynamic dispatch.
type IOC_SinglePartQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SinglePartQueryContext differentiates from other interfaces.
	IsOC_SinglePartQueryContext()
}

type OC_SinglePartQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SinglePartQueryContext() *OC_SinglePartQueryContext {
	var p = new(OC_SinglePartQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_SinglePartQuery
	return p
}

func (*OC_SinglePartQueryContext) IsOC_SinglePartQueryContext() {}

func NewOC_SinglePartQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SinglePartQueryContext {
	var p = new(OC_SinglePartQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_SinglePartQuery

	return p
}

func (s *OC_SinglePartQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SinglePartQueryContext) OC_Return() IOC_ReturnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ReturnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ReturnContext)
}

func (s *OC_SinglePartQueryContext) AllOC_ReadingClause() []IOC_ReadingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ReadingClauseContext)(nil)).Elem())
	var tst = make([]IOC_ReadingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ReadingClauseContext)
		}
	}

	return tst
}

func (s *OC_SinglePartQueryContext) OC_ReadingClause(i int) IOC_ReadingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ReadingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ReadingClauseContext)
}

func (s *OC_SinglePartQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_SinglePartQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_SinglePartQueryContext) AllOC_UpdatingClause() []IOC_UpdatingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_UpdatingClauseContext)(nil)).Elem())
	var tst = make([]IOC_UpdatingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_UpdatingClauseContext)
		}
	}

	return tst
}

func (s *OC_SinglePartQueryContext) OC_UpdatingClause(i int) IOC_UpdatingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_UpdatingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_UpdatingClauseContext)
}

func (s *OC_SinglePartQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SinglePartQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_SinglePartQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_SinglePartQuery(s)
	}
}

func (s *OC_SinglePartQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_SinglePartQuery(s)
	}
}




func (p *CypherParser) OC_SinglePartQuery() (localctx IOC_SinglePartQueryContext) {
	localctx = NewOC_SinglePartQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CypherParserRULE_oC_SinglePartQuery)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(290)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(261)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ((((_la - 48)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 48))) & ((1 << (CypherParserOPTIONAL - 48)) | (1 << (CypherParserMATCH - 48)) | (1 << (CypherParserUNWIND - 48)) | (1 << (CypherParserCALL - 48)))) != 0) {
			{
				p.SetState(255)
				p.OC_ReadingClause()
			}
			p.SetState(257)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(256)
					p.Match(CypherParserSP)
				}

			}


			p.SetState(263)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(264)
			p.OC_Return()
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(271)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ((((_la - 48)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 48))) & ((1 << (CypherParserOPTIONAL - 48)) | (1 << (CypherParserMATCH - 48)) | (1 << (CypherParserUNWIND - 48)) | (1 << (CypherParserCALL - 48)))) != 0) {
			{
				p.SetState(265)
				p.OC_ReadingClause()
			}
			p.SetState(267)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(266)
					p.Match(CypherParserSP)
				}

			}


			p.SetState(273)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(274)
			p.OC_UpdatingClause()
		}
		p.SetState(281)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(276)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(275)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(278)
					p.OC_UpdatingClause()
				}


			}
			p.SetState(283)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
		}
		p.SetState(288)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			p.SetState(285)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(284)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(287)
				p.OC_Return()
			}


		}


	}


	return localctx
}


// IOC_MultiPartQueryContext is an interface to support dynamic dispatch.
type IOC_MultiPartQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MultiPartQueryContext differentiates from other interfaces.
	IsOC_MultiPartQueryContext()
}

type OC_MultiPartQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MultiPartQueryContext() *OC_MultiPartQueryContext {
	var p = new(OC_MultiPartQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_MultiPartQuery
	return p
}

func (*OC_MultiPartQueryContext) IsOC_MultiPartQueryContext() {}

func NewOC_MultiPartQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MultiPartQueryContext {
	var p = new(OC_MultiPartQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_MultiPartQuery

	return p
}

func (s *OC_MultiPartQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MultiPartQueryContext) OC_SinglePartQuery() IOC_SinglePartQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SinglePartQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SinglePartQueryContext)
}

func (s *OC_MultiPartQueryContext) AllOC_With() []IOC_WithContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_WithContext)(nil)).Elem())
	var tst = make([]IOC_WithContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_WithContext)
		}
	}

	return tst
}

func (s *OC_MultiPartQueryContext) OC_With(i int) IOC_WithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_WithContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_WithContext)
}

func (s *OC_MultiPartQueryContext) AllOC_ReadingClause() []IOC_ReadingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ReadingClauseContext)(nil)).Elem())
	var tst = make([]IOC_ReadingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ReadingClauseContext)
		}
	}

	return tst
}

func (s *OC_MultiPartQueryContext) OC_ReadingClause(i int) IOC_ReadingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ReadingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ReadingClauseContext)
}

func (s *OC_MultiPartQueryContext) AllOC_UpdatingClause() []IOC_UpdatingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_UpdatingClauseContext)(nil)).Elem())
	var tst = make([]IOC_UpdatingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_UpdatingClauseContext)
		}
	}

	return tst
}

func (s *OC_MultiPartQueryContext) OC_UpdatingClause(i int) IOC_UpdatingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_UpdatingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_UpdatingClauseContext)
}

func (s *OC_MultiPartQueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_MultiPartQueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_MultiPartQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MultiPartQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_MultiPartQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_MultiPartQuery(s)
	}
}

func (s *OC_MultiPartQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_MultiPartQuery(s)
	}
}




func (p *CypherParser) OC_MultiPartQuery() (localctx IOC_MultiPartQueryContext) {
	localctx = NewOC_MultiPartQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CypherParserRULE_oC_MultiPartQuery)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(298)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				for ((((_la - 48)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 48))) & ((1 << (CypherParserOPTIONAL - 48)) | (1 << (CypherParserMATCH - 48)) | (1 << (CypherParserUNWIND - 48)) | (1 << (CypherParserCALL - 48)))) != 0) {
					{
						p.SetState(292)
						p.OC_ReadingClause()
					}
					p.SetState(294)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)


					if _la == CypherParserSP {
						{
							p.SetState(293)
							p.Match(CypherParserSP)
						}

					}


					p.SetState(300)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				p.SetState(307)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				for ((((_la - 52)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 52))) & ((1 << (CypherParserMERGE - 52)) | (1 << (CypherParserCREATE - 52)) | (1 << (CypherParserSET - 52)) | (1 << (CypherParserDETACH - 52)) | (1 << (CypherParserDELETE - 52)) | (1 << (CypherParserREMOVE - 52)))) != 0) {
					{
						p.SetState(301)
						p.OC_UpdatingClause()
					}
					p.SetState(303)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)


					if _la == CypherParserSP {
						{
							p.SetState(302)
							p.Match(CypherParserSP)
						}

					}


					p.SetState(309)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(310)
					p.OC_With()
				}
				p.SetState(312)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(311)
						p.Match(CypherParserSP)
					}

				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(316)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
	}
	{
		p.SetState(318)
		p.OC_SinglePartQuery()
	}



	return localctx
}


// IOC_UpdatingClauseContext is an interface to support dynamic dispatch.
type IOC_UpdatingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_UpdatingClauseContext differentiates from other interfaces.
	IsOC_UpdatingClauseContext()
}

type OC_UpdatingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_UpdatingClauseContext() *OC_UpdatingClauseContext {
	var p = new(OC_UpdatingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_UpdatingClause
	return p
}

func (*OC_UpdatingClauseContext) IsOC_UpdatingClauseContext() {}

func NewOC_UpdatingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_UpdatingClauseContext {
	var p = new(OC_UpdatingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_UpdatingClause

	return p
}

func (s *OC_UpdatingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_UpdatingClauseContext) OC_Create() IOC_CreateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_CreateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_CreateContext)
}

func (s *OC_UpdatingClauseContext) OC_Merge() IOC_MergeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_MergeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_MergeContext)
}

func (s *OC_UpdatingClauseContext) OC_Delete() IOC_DeleteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_DeleteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_DeleteContext)
}

func (s *OC_UpdatingClauseContext) OC_Set() IOC_SetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SetContext)
}

func (s *OC_UpdatingClauseContext) OC_Remove() IOC_RemoveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RemoveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_RemoveContext)
}

func (s *OC_UpdatingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_UpdatingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_UpdatingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_UpdatingClause(s)
	}
}

func (s *OC_UpdatingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_UpdatingClause(s)
	}
}




func (p *CypherParser) OC_UpdatingClause() (localctx IOC_UpdatingClauseContext) {
	localctx = NewOC_UpdatingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CypherParserRULE_oC_UpdatingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(325)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCREATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(320)
			p.OC_Create()
		}


	case CypherParserMERGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(321)
			p.OC_Merge()
		}


	case CypherParserDETACH, CypherParserDELETE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(322)
			p.OC_Delete()
		}


	case CypherParserSET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(323)
			p.OC_Set()
		}


	case CypherParserREMOVE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(324)
			p.OC_Remove()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_ReadingClauseContext is an interface to support dynamic dispatch.
type IOC_ReadingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ReadingClauseContext differentiates from other interfaces.
	IsOC_ReadingClauseContext()
}

type OC_ReadingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ReadingClauseContext() *OC_ReadingClauseContext {
	var p = new(OC_ReadingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ReadingClause
	return p
}

func (*OC_ReadingClauseContext) IsOC_ReadingClauseContext() {}

func NewOC_ReadingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ReadingClauseContext {
	var p = new(OC_ReadingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ReadingClause

	return p
}

func (s *OC_ReadingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ReadingClauseContext) OC_Match() IOC_MatchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_MatchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_MatchContext)
}

func (s *OC_ReadingClauseContext) OC_Unwind() IOC_UnwindContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_UnwindContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_UnwindContext)
}

func (s *OC_ReadingClauseContext) OC_InQueryCall() IOC_InQueryCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_InQueryCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_InQueryCallContext)
}

func (s *OC_ReadingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ReadingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ReadingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ReadingClause(s)
	}
}

func (s *OC_ReadingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ReadingClause(s)
	}
}




func (p *CypherParser) OC_ReadingClause() (localctx IOC_ReadingClauseContext) {
	localctx = NewOC_ReadingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CypherParserRULE_oC_ReadingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(330)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserOPTIONAL, CypherParserMATCH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(327)
			p.OC_Match()
		}


	case CypherParserUNWIND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(328)
			p.OC_Unwind()
		}


	case CypherParserCALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(329)
			p.OC_InQueryCall()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_MatchContext is an interface to support dynamic dispatch.
type IOC_MatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MatchContext differentiates from other interfaces.
	IsOC_MatchContext()
}

type OC_MatchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MatchContext() *OC_MatchContext {
	var p = new(OC_MatchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Match
	return p
}

func (*OC_MatchContext) IsOC_MatchContext() {}

func NewOC_MatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MatchContext {
	var p = new(OC_MatchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Match

	return p
}

func (s *OC_MatchContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MatchContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *OC_MatchContext) OC_Pattern() IOC_PatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternContext)
}

func (s *OC_MatchContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONAL, 0)
}

func (s *OC_MatchContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_MatchContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_MatchContext) OC_Where() IOC_WhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_WhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_MatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_MatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Match(s)
	}
}

func (s *OC_MatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Match(s)
	}
}




func (p *CypherParser) OC_Match() (localctx IOC_MatchContext) {
	localctx = NewOC_MatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CypherParserRULE_oC_Match)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(334)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserOPTIONAL {
		{
			p.SetState(332)
			p.Match(CypherParserOPTIONAL)
		}
		{
			p.SetState(333)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(336)
		p.Match(CypherParserMATCH)
	}
	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(337)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(340)
		p.OC_Pattern()
	}
	p.SetState(345)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
		p.SetState(342)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(341)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(344)
			p.OC_Where()
		}


	}



	return localctx
}


// IOC_UnwindContext is an interface to support dynamic dispatch.
type IOC_UnwindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_UnwindContext differentiates from other interfaces.
	IsOC_UnwindContext()
}

type OC_UnwindContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_UnwindContext() *OC_UnwindContext {
	var p = new(OC_UnwindContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Unwind
	return p
}

func (*OC_UnwindContext) IsOC_UnwindContext() {}

func NewOC_UnwindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_UnwindContext {
	var p = new(OC_UnwindContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Unwind

	return p
}

func (s *OC_UnwindContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_UnwindContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(CypherParserUNWIND, 0)
}

func (s *OC_UnwindContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_UnwindContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_UnwindContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_UnwindContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *OC_UnwindContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_UnwindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_UnwindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_UnwindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Unwind(s)
	}
}

func (s *OC_UnwindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Unwind(s)
	}
}




func (p *CypherParser) OC_Unwind() (localctx IOC_UnwindContext) {
	localctx = NewOC_UnwindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CypherParserRULE_oC_Unwind)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(347)
		p.Match(CypherParserUNWIND)
	}
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(348)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(351)
		p.OC_Expression()
	}
	{
		p.SetState(352)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(353)
		p.Match(CypherParserAS)
	}
	{
		p.SetState(354)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(355)
		p.OC_Variable()
	}



	return localctx
}


// IOC_MergeContext is an interface to support dynamic dispatch.
type IOC_MergeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MergeContext differentiates from other interfaces.
	IsOC_MergeContext()
}

type OC_MergeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MergeContext() *OC_MergeContext {
	var p = new(OC_MergeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Merge
	return p
}

func (*OC_MergeContext) IsOC_MergeContext() {}

func NewOC_MergeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MergeContext {
	var p = new(OC_MergeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Merge

	return p
}

func (s *OC_MergeContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MergeContext) MERGE() antlr.TerminalNode {
	return s.GetToken(CypherParserMERGE, 0)
}

func (s *OC_MergeContext) OC_PatternPart() IOC_PatternPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternPartContext)
}

func (s *OC_MergeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_MergeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_MergeContext) AllOC_MergeAction() []IOC_MergeActionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_MergeActionContext)(nil)).Elem())
	var tst = make([]IOC_MergeActionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_MergeActionContext)
		}
	}

	return tst
}

func (s *OC_MergeContext) OC_MergeAction(i int) IOC_MergeActionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_MergeActionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_MergeActionContext)
}

func (s *OC_MergeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MergeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_MergeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Merge(s)
	}
}

func (s *OC_MergeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Merge(s)
	}
}




func (p *CypherParser) OC_Merge() (localctx IOC_MergeContext) {
	localctx = NewOC_MergeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CypherParserRULE_oC_Merge)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(357)
		p.Match(CypherParserMERGE)
	}
	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(358)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(361)
		p.OC_PatternPart()
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(362)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(363)
				p.OC_MergeAction()
			}


		}
		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_MergeActionContext is an interface to support dynamic dispatch.
type IOC_MergeActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MergeActionContext differentiates from other interfaces.
	IsOC_MergeActionContext()
}

type OC_MergeActionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MergeActionContext() *OC_MergeActionContext {
	var p = new(OC_MergeActionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_MergeAction
	return p
}

func (*OC_MergeActionContext) IsOC_MergeActionContext() {}

func NewOC_MergeActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MergeActionContext {
	var p = new(OC_MergeActionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_MergeAction

	return p
}

func (s *OC_MergeActionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MergeActionContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *OC_MergeActionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_MergeActionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_MergeActionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *OC_MergeActionContext) OC_Set() IOC_SetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SetContext)
}

func (s *OC_MergeActionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *OC_MergeActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MergeActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_MergeActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_MergeAction(s)
	}
}

func (s *OC_MergeActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_MergeAction(s)
	}
}




func (p *CypherParser) OC_MergeAction() (localctx IOC_MergeActionContext) {
	localctx = NewOC_MergeActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CypherParserRULE_oC_MergeAction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(369)
			p.Match(CypherParserON)
		}
		{
			p.SetState(370)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(371)
			p.Match(CypherParserMATCH)
		}
		{
			p.SetState(372)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(373)
			p.OC_Set()
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.Match(CypherParserON)
		}
		{
			p.SetState(375)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(376)
			p.Match(CypherParserCREATE)
		}
		{
			p.SetState(377)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(378)
			p.OC_Set()
		}


	}


	return localctx
}


// IOC_CreateContext is an interface to support dynamic dispatch.
type IOC_CreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_CreateContext differentiates from other interfaces.
	IsOC_CreateContext()
}

type OC_CreateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_CreateContext() *OC_CreateContext {
	var p = new(OC_CreateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Create
	return p
}

func (*OC_CreateContext) IsOC_CreateContext() {}

func NewOC_CreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_CreateContext {
	var p = new(OC_CreateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Create

	return p
}

func (s *OC_CreateContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_CreateContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *OC_CreateContext) OC_Pattern() IOC_PatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternContext)
}

func (s *OC_CreateContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_CreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_CreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_CreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Create(s)
	}
}

func (s *OC_CreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Create(s)
	}
}




func (p *CypherParser) OC_Create() (localctx IOC_CreateContext) {
	localctx = NewOC_CreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CypherParserRULE_oC_Create)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.Match(CypherParserCREATE)
	}
	p.SetState(383)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(382)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(385)
		p.OC_Pattern()
	}



	return localctx
}


// IOC_SetContext is an interface to support dynamic dispatch.
type IOC_SetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SetContext differentiates from other interfaces.
	IsOC_SetContext()
}

type OC_SetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SetContext() *OC_SetContext {
	var p = new(OC_SetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Set
	return p
}

func (*OC_SetContext) IsOC_SetContext() {}

func NewOC_SetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SetContext {
	var p = new(OC_SetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Set

	return p
}

func (s *OC_SetContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SetContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *OC_SetContext) AllOC_SetItem() []IOC_SetItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_SetItemContext)(nil)).Elem())
	var tst = make([]IOC_SetItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_SetItemContext)
		}
	}

	return tst
}

func (s *OC_SetContext) OC_SetItem(i int) IOC_SetItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SetItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_SetItemContext)
}

func (s *OC_SetContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_SetContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_SetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_SetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Set(s)
	}
}

func (s *OC_SetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Set(s)
	}
}




func (p *CypherParser) OC_Set() (localctx IOC_SetContext) {
	localctx = NewOC_SetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CypherParserRULE_oC_Set)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.Match(CypherParserSET)
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(388)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(391)
		p.OC_SetItem()
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(393)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(392)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(395)
				p.Match(CypherParserT__1)
			}
			p.SetState(397)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(396)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(399)
				p.OC_SetItem()
			}


		}
		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_SetItemContext is an interface to support dynamic dispatch.
type IOC_SetItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SetItemContext differentiates from other interfaces.
	IsOC_SetItemContext()
}

type OC_SetItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SetItemContext() *OC_SetItemContext {
	var p = new(OC_SetItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_SetItem
	return p
}

func (*OC_SetItemContext) IsOC_SetItemContext() {}

func NewOC_SetItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SetItemContext {
	var p = new(OC_SetItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_SetItem

	return p
}

func (s *OC_SetItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SetItemContext) OC_PropertyExpression() IOC_PropertyExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PropertyExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyExpressionContext)
}

func (s *OC_SetItemContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_SetItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_SetItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_SetItemContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_SetItemContext) OC_NodeLabels() IOC_NodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NodeLabelsContext)
}

func (s *OC_SetItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SetItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_SetItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_SetItem(s)
	}
}

func (s *OC_SetItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_SetItem(s)
	}
}




func (p *CypherParser) OC_SetItem() (localctx IOC_SetItemContext) {
	localctx = NewOC_SetItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CypherParserRULE_oC_SetItem)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(405)
			p.OC_PropertyExpression()
		}
		p.SetState(407)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(406)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(409)
			p.Match(CypherParserT__2)
		}
		p.SetState(411)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(410)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(413)
			p.OC_Expression()
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(415)
			p.OC_Variable()
		}
		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(416)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(419)
			p.Match(CypherParserT__2)
		}
		p.SetState(421)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(420)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(423)
			p.OC_Expression()
		}



	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(425)
			p.OC_Variable()
		}
		p.SetState(427)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(426)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(429)
			p.Match(CypherParserT__3)
		}
		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(430)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(433)
			p.OC_Expression()
		}



	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(435)
			p.OC_Variable()
		}
		p.SetState(437)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(436)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(439)
			p.OC_NodeLabels()
		}


	}


	return localctx
}


// IOC_DeleteContext is an interface to support dynamic dispatch.
type IOC_DeleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_DeleteContext differentiates from other interfaces.
	IsOC_DeleteContext()
}

type OC_DeleteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_DeleteContext() *OC_DeleteContext {
	var p = new(OC_DeleteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Delete
	return p
}

func (*OC_DeleteContext) IsOC_DeleteContext() {}

func NewOC_DeleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_DeleteContext {
	var p = new(OC_DeleteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Delete

	return p
}

func (s *OC_DeleteContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CypherParserDELETE, 0)
}

func (s *OC_DeleteContext) AllOC_Expression() []IOC_ExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem())
	var tst = make([]IOC_ExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ExpressionContext)
		}
	}

	return tst
}

func (s *OC_DeleteContext) OC_Expression(i int) IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_DeleteContext) DETACH() antlr.TerminalNode {
	return s.GetToken(CypherParserDETACH, 0)
}

func (s *OC_DeleteContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_DeleteContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_DeleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Delete(s)
	}
}

func (s *OC_DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Delete(s)
	}
}




func (p *CypherParser) OC_Delete() (localctx IOC_DeleteContext) {
	localctx = NewOC_DeleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CypherParserRULE_oC_Delete)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(445)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserDETACH {
		{
			p.SetState(443)
			p.Match(CypherParserDETACH)
		}
		{
			p.SetState(444)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(447)
		p.Match(CypherParserDELETE)
	}
	p.SetState(449)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(448)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(451)
		p.OC_Expression()
	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(453)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(452)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(455)
				p.Match(CypherParserT__1)
			}
			p.SetState(457)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(456)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(459)
				p.OC_Expression()
			}


		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_RemoveContext is an interface to support dynamic dispatch.
type IOC_RemoveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RemoveContext differentiates from other interfaces.
	IsOC_RemoveContext()
}

type OC_RemoveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RemoveContext() *OC_RemoveContext {
	var p = new(OC_RemoveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Remove
	return p
}

func (*OC_RemoveContext) IsOC_RemoveContext() {}

func NewOC_RemoveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RemoveContext {
	var p = new(OC_RemoveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Remove

	return p
}

func (s *OC_RemoveContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RemoveContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *OC_RemoveContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_RemoveContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_RemoveContext) AllOC_RemoveItem() []IOC_RemoveItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_RemoveItemContext)(nil)).Elem())
	var tst = make([]IOC_RemoveItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_RemoveItemContext)
		}
	}

	return tst
}

func (s *OC_RemoveContext) OC_RemoveItem(i int) IOC_RemoveItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RemoveItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_RemoveItemContext)
}

func (s *OC_RemoveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RemoveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_RemoveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Remove(s)
	}
}

func (s *OC_RemoveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Remove(s)
	}
}




func (p *CypherParser) OC_Remove() (localctx IOC_RemoveContext) {
	localctx = NewOC_RemoveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CypherParserRULE_oC_Remove)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(465)
		p.Match(CypherParserREMOVE)
	}
	{
		p.SetState(466)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(467)
		p.OC_RemoveItem()
	}
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(469)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(468)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(471)
				p.Match(CypherParserT__1)
			}
			p.SetState(473)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(472)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(475)
				p.OC_RemoveItem()
			}


		}
		p.SetState(480)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_RemoveItemContext is an interface to support dynamic dispatch.
type IOC_RemoveItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RemoveItemContext differentiates from other interfaces.
	IsOC_RemoveItemContext()
}

type OC_RemoveItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RemoveItemContext() *OC_RemoveItemContext {
	var p = new(OC_RemoveItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_RemoveItem
	return p
}

func (*OC_RemoveItemContext) IsOC_RemoveItemContext() {}

func NewOC_RemoveItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RemoveItemContext {
	var p = new(OC_RemoveItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_RemoveItem

	return p
}

func (s *OC_RemoveItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RemoveItemContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_RemoveItemContext) OC_NodeLabels() IOC_NodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NodeLabelsContext)
}

func (s *OC_RemoveItemContext) OC_PropertyExpression() IOC_PropertyExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PropertyExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyExpressionContext)
}

func (s *OC_RemoveItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RemoveItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_RemoveItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_RemoveItem(s)
	}
}

func (s *OC_RemoveItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_RemoveItem(s)
	}
}




func (p *CypherParser) OC_RemoveItem() (localctx IOC_RemoveItemContext) {
	localctx = NewOC_RemoveItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CypherParserRULE_oC_RemoveItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(481)
			p.OC_Variable()
		}
		{
			p.SetState(482)
			p.OC_NodeLabels()
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(484)
			p.OC_PropertyExpression()
		}

	}


	return localctx
}


// IOC_InQueryCallContext is an interface to support dynamic dispatch.
type IOC_InQueryCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_InQueryCallContext differentiates from other interfaces.
	IsOC_InQueryCallContext()
}

type OC_InQueryCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_InQueryCallContext() *OC_InQueryCallContext {
	var p = new(OC_InQueryCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_InQueryCall
	return p
}

func (*OC_InQueryCallContext) IsOC_InQueryCallContext() {}

func NewOC_InQueryCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_InQueryCallContext {
	var p = new(OC_InQueryCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_InQueryCall

	return p
}

func (s *OC_InQueryCallContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_InQueryCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(CypherParserCALL, 0)
}

func (s *OC_InQueryCallContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_InQueryCallContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_InQueryCallContext) OC_ExplicitProcedureInvocation() IOC_ExplicitProcedureInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExplicitProcedureInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExplicitProcedureInvocationContext)
}

func (s *OC_InQueryCallContext) YIELD() antlr.TerminalNode {
	return s.GetToken(CypherParserYIELD, 0)
}

func (s *OC_InQueryCallContext) OC_YieldItems() IOC_YieldItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_YieldItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_YieldItemsContext)
}

func (s *OC_InQueryCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_InQueryCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_InQueryCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_InQueryCall(s)
	}
}

func (s *OC_InQueryCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_InQueryCall(s)
	}
}




func (p *CypherParser) OC_InQueryCall() (localctx IOC_InQueryCallContext) {
	localctx = NewOC_InQueryCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CypherParserRULE_oC_InQueryCall)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(CypherParserCALL)
	}
	{
		p.SetState(488)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(489)
		p.OC_ExplicitProcedureInvocation()
	}
	p.SetState(496)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(490)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(493)
			p.Match(CypherParserYIELD)
		}
		{
			p.SetState(494)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(495)
			p.OC_YieldItems()
		}


	}



	return localctx
}


// IOC_StandaloneCallContext is an interface to support dynamic dispatch.
type IOC_StandaloneCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_StandaloneCallContext differentiates from other interfaces.
	IsOC_StandaloneCallContext()
}

type OC_StandaloneCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_StandaloneCallContext() *OC_StandaloneCallContext {
	var p = new(OC_StandaloneCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_StandaloneCall
	return p
}

func (*OC_StandaloneCallContext) IsOC_StandaloneCallContext() {}

func NewOC_StandaloneCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_StandaloneCallContext {
	var p = new(OC_StandaloneCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_StandaloneCall

	return p
}

func (s *OC_StandaloneCallContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_StandaloneCallContext) CALL() antlr.TerminalNode {
	return s.GetToken(CypherParserCALL, 0)
}

func (s *OC_StandaloneCallContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_StandaloneCallContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_StandaloneCallContext) OC_ExplicitProcedureInvocation() IOC_ExplicitProcedureInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExplicitProcedureInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExplicitProcedureInvocationContext)
}

func (s *OC_StandaloneCallContext) OC_ImplicitProcedureInvocation() IOC_ImplicitProcedureInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ImplicitProcedureInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ImplicitProcedureInvocationContext)
}

func (s *OC_StandaloneCallContext) YIELD() antlr.TerminalNode {
	return s.GetToken(CypherParserYIELD, 0)
}

func (s *OC_StandaloneCallContext) OC_YieldItems() IOC_YieldItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_YieldItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_YieldItemsContext)
}

func (s *OC_StandaloneCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_StandaloneCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_StandaloneCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_StandaloneCall(s)
	}
}

func (s *OC_StandaloneCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_StandaloneCall(s)
	}
}




func (p *CypherParser) OC_StandaloneCall() (localctx IOC_StandaloneCallContext) {
	localctx = NewOC_StandaloneCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CypherParserRULE_oC_StandaloneCall)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Match(CypherParserCALL)
	}
	{
		p.SetState(499)
		p.Match(CypherParserSP)
	}
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(500)
			p.OC_ExplicitProcedureInvocation()
		}


	case 2:
		{
			p.SetState(501)
			p.OC_ImplicitProcedureInvocation()
		}

	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(504)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(507)
			p.Match(CypherParserYIELD)
		}
		{
			p.SetState(508)
			p.Match(CypherParserSP)
		}
		p.SetState(511)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case CypherParserT__4:
			{
				p.SetState(509)
				p.Match(CypherParserT__4)
			}


		case CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
			{
				p.SetState(510)
				p.OC_YieldItems()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}


	}



	return localctx
}


// IOC_YieldItemsContext is an interface to support dynamic dispatch.
type IOC_YieldItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_YieldItemsContext differentiates from other interfaces.
	IsOC_YieldItemsContext()
}

type OC_YieldItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_YieldItemsContext() *OC_YieldItemsContext {
	var p = new(OC_YieldItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_YieldItems
	return p
}

func (*OC_YieldItemsContext) IsOC_YieldItemsContext() {}

func NewOC_YieldItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_YieldItemsContext {
	var p = new(OC_YieldItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_YieldItems

	return p
}

func (s *OC_YieldItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_YieldItemsContext) AllOC_YieldItem() []IOC_YieldItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_YieldItemContext)(nil)).Elem())
	var tst = make([]IOC_YieldItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_YieldItemContext)
		}
	}

	return tst
}

func (s *OC_YieldItemsContext) OC_YieldItem(i int) IOC_YieldItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_YieldItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_YieldItemContext)
}

func (s *OC_YieldItemsContext) OC_Where() IOC_WhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_WhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_YieldItemsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_YieldItemsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_YieldItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_YieldItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_YieldItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_YieldItems(s)
	}
}

func (s *OC_YieldItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_YieldItems(s)
	}
}




func (p *CypherParser) OC_YieldItems() (localctx IOC_YieldItemsContext) {
	localctx = NewOC_YieldItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CypherParserRULE_oC_YieldItems)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		p.OC_YieldItem()
	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(517)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(516)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(519)
				p.Match(CypherParserT__1)
			}
			p.SetState(521)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(520)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(523)
				p.OC_YieldItem()
			}


		}
		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}
	p.SetState(533)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(529)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(532)
			p.OC_Where()
		}


	}



	return localctx
}


// IOC_YieldItemContext is an interface to support dynamic dispatch.
type IOC_YieldItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_YieldItemContext differentiates from other interfaces.
	IsOC_YieldItemContext()
}

type OC_YieldItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_YieldItemContext() *OC_YieldItemContext {
	var p = new(OC_YieldItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_YieldItem
	return p
}

func (*OC_YieldItemContext) IsOC_YieldItemContext() {}

func NewOC_YieldItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_YieldItemContext {
	var p = new(OC_YieldItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_YieldItem

	return p
}

func (s *OC_YieldItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_YieldItemContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_YieldItemContext) OC_ProcedureResultField() IOC_ProcedureResultFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ProcedureResultFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ProcedureResultFieldContext)
}

func (s *OC_YieldItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_YieldItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_YieldItemContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *OC_YieldItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_YieldItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_YieldItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_YieldItem(s)
	}
}

func (s *OC_YieldItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_YieldItem(s)
	}
}




func (p *CypherParser) OC_YieldItem() (localctx IOC_YieldItemContext) {
	localctx = NewOC_YieldItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CypherParserRULE_oC_YieldItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(540)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(535)
			p.OC_ProcedureResultField()
		}
		{
			p.SetState(536)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(537)
			p.Match(CypherParserAS)
		}
		{
			p.SetState(538)
			p.Match(CypherParserSP)
		}


	}
	{
		p.SetState(542)
		p.OC_Variable()
	}



	return localctx
}


// IOC_WithContext is an interface to support dynamic dispatch.
type IOC_WithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_WithContext differentiates from other interfaces.
	IsOC_WithContext()
}

type OC_WithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_WithContext() *OC_WithContext {
	var p = new(OC_WithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_With
	return p
}

func (*OC_WithContext) IsOC_WithContext() {}

func NewOC_WithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_WithContext {
	var p = new(OC_WithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_With

	return p
}

func (s *OC_WithContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_WithContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *OC_WithContext) OC_ProjectionBody() IOC_ProjectionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ProjectionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ProjectionBodyContext)
}

func (s *OC_WithContext) OC_Where() IOC_WhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_WhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_WithContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_WithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_WithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_WithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_With(s)
	}
}

func (s *OC_WithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_With(s)
	}
}




func (p *CypherParser) OC_With() (localctx IOC_WithContext) {
	localctx = NewOC_WithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CypherParserRULE_oC_With)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Match(CypherParserWITH)
	}
	{
		p.SetState(545)
		p.OC_ProjectionBody()
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(546)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(549)
			p.OC_Where()
		}


	}



	return localctx
}


// IOC_ReturnContext is an interface to support dynamic dispatch.
type IOC_ReturnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ReturnContext differentiates from other interfaces.
	IsOC_ReturnContext()
}

type OC_ReturnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ReturnContext() *OC_ReturnContext {
	var p = new(OC_ReturnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Return
	return p
}

func (*OC_ReturnContext) IsOC_ReturnContext() {}

func NewOC_ReturnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ReturnContext {
	var p = new(OC_ReturnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Return

	return p
}

func (s *OC_ReturnContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ReturnContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CypherParserRETURN, 0)
}

func (s *OC_ReturnContext) OC_ProjectionBody() IOC_ProjectionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ProjectionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ProjectionBodyContext)
}

func (s *OC_ReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ReturnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ReturnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Return(s)
	}
}

func (s *OC_ReturnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Return(s)
	}
}




func (p *CypherParser) OC_Return() (localctx IOC_ReturnContext) {
	localctx = NewOC_ReturnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CypherParserRULE_oC_Return)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.Match(CypherParserRETURN)
	}
	{
		p.SetState(553)
		p.OC_ProjectionBody()
	}



	return localctx
}


// IOC_ProjectionBodyContext is an interface to support dynamic dispatch.
type IOC_ProjectionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ProjectionBodyContext differentiates from other interfaces.
	IsOC_ProjectionBodyContext()
}

type OC_ProjectionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ProjectionBodyContext() *OC_ProjectionBodyContext {
	var p = new(OC_ProjectionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ProjectionBody
	return p
}

func (*OC_ProjectionBodyContext) IsOC_ProjectionBodyContext() {}

func NewOC_ProjectionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ProjectionBodyContext {
	var p = new(OC_ProjectionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ProjectionBody

	return p
}

func (s *OC_ProjectionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ProjectionBodyContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_ProjectionBodyContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_ProjectionBodyContext) OC_ProjectionItems() IOC_ProjectionItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ProjectionItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ProjectionItemsContext)
}

func (s *OC_ProjectionBodyContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *OC_ProjectionBodyContext) OC_Order() IOC_OrderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_OrderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_OrderContext)
}

func (s *OC_ProjectionBodyContext) OC_Skip() IOC_SkipContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SkipContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SkipContext)
}

func (s *OC_ProjectionBodyContext) OC_Limit() IOC_LimitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_LimitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_LimitContext)
}

func (s *OC_ProjectionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ProjectionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ProjectionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ProjectionBody(s)
	}
}

func (s *OC_ProjectionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ProjectionBody(s)
	}
}




func (p *CypherParser) OC_ProjectionBody() (localctx IOC_ProjectionBodyContext) {
	localctx = NewOC_ProjectionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CypherParserRULE_oC_ProjectionBody)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(559)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(555)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(558)
			p.Match(CypherParserDISTINCT)
		}


	}
	{
		p.SetState(561)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(562)
		p.OC_ProjectionItems()
	}
	p.SetState(565)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(563)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(564)
			p.OC_Order()
		}


	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(567)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(568)
			p.OC_Skip()
		}


	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(571)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(572)
			p.OC_Limit()
		}


	}



	return localctx
}


// IOC_ProjectionItemsContext is an interface to support dynamic dispatch.
type IOC_ProjectionItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ProjectionItemsContext differentiates from other interfaces.
	IsOC_ProjectionItemsContext()
}

type OC_ProjectionItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ProjectionItemsContext() *OC_ProjectionItemsContext {
	var p = new(OC_ProjectionItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ProjectionItems
	return p
}

func (*OC_ProjectionItemsContext) IsOC_ProjectionItemsContext() {}

func NewOC_ProjectionItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ProjectionItemsContext {
	var p = new(OC_ProjectionItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ProjectionItems

	return p
}

func (s *OC_ProjectionItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ProjectionItemsContext) AllOC_ProjectionItem() []IOC_ProjectionItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ProjectionItemContext)(nil)).Elem())
	var tst = make([]IOC_ProjectionItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ProjectionItemContext)
		}
	}

	return tst
}

func (s *OC_ProjectionItemsContext) OC_ProjectionItem(i int) IOC_ProjectionItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ProjectionItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ProjectionItemContext)
}

func (s *OC_ProjectionItemsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_ProjectionItemsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_ProjectionItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ProjectionItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ProjectionItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ProjectionItems(s)
	}
}

func (s *OC_ProjectionItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ProjectionItems(s)
	}
}




func (p *CypherParser) OC_ProjectionItems() (localctx IOC_ProjectionItemsContext) {
	localctx = NewOC_ProjectionItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CypherParserRULE_oC_ProjectionItems)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(603)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__4:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(575)
			p.Match(CypherParserT__4)
		}
		p.SetState(586)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(577)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(576)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(579)
					p.Match(CypherParserT__1)
				}
				p.SetState(581)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(580)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(583)
					p.OC_ProjectionItem()
				}


			}
			p.SetState(588)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())
		}



	case CypherParserT__5, CypherParserT__7, CypherParserT__17, CypherParserT__18, CypherParserT__23, CypherParserT__25, CypherParserALL, CypherParserNOT, CypherParserNULL, CypherParserCOUNT, CypherParserCASE, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserEXISTS, CypherParserTRUE, CypherParserFALSE, CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger, CypherParserHexLetter, CypherParserExponentDecimalReal, CypherParserRegularDecimalReal, CypherParserStringLiteral, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(589)
			p.OC_ProjectionItem()
		}
		p.SetState(600)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(591)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(590)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(593)
					p.Match(CypherParserT__1)
				}
				p.SetState(595)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(594)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(597)
					p.OC_ProjectionItem()
				}


			}
			p.SetState(602)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
		}




	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_ProjectionItemContext is an interface to support dynamic dispatch.
type IOC_ProjectionItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ProjectionItemContext differentiates from other interfaces.
	IsOC_ProjectionItemContext()
}

type OC_ProjectionItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ProjectionItemContext() *OC_ProjectionItemContext {
	var p = new(OC_ProjectionItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ProjectionItem
	return p
}

func (*OC_ProjectionItemContext) IsOC_ProjectionItemContext() {}

func NewOC_ProjectionItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ProjectionItemContext {
	var p = new(OC_ProjectionItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ProjectionItem

	return p
}

func (s *OC_ProjectionItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ProjectionItemContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ProjectionItemContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_ProjectionItemContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_ProjectionItemContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *OC_ProjectionItemContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_ProjectionItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ProjectionItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ProjectionItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ProjectionItem(s)
	}
}

func (s *OC_ProjectionItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ProjectionItem(s)
	}
}




func (p *CypherParser) OC_ProjectionItem() (localctx IOC_ProjectionItemContext) {
	localctx = NewOC_ProjectionItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CypherParserRULE_oC_ProjectionItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(605)
			p.OC_Expression()
		}
		{
			p.SetState(606)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(607)
			p.Match(CypherParserAS)
		}
		{
			p.SetState(608)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(609)
			p.OC_Variable()
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.OC_Expression()
		}

	}


	return localctx
}


// IOC_OrderContext is an interface to support dynamic dispatch.
type IOC_OrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_OrderContext differentiates from other interfaces.
	IsOC_OrderContext()
}

type OC_OrderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_OrderContext() *OC_OrderContext {
	var p = new(OC_OrderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Order
	return p
}

func (*OC_OrderContext) IsOC_OrderContext() {}

func NewOC_OrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_OrderContext {
	var p = new(OC_OrderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Order

	return p
}

func (s *OC_OrderContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_OrderContext) ORDER() antlr.TerminalNode {
	return s.GetToken(CypherParserORDER, 0)
}

func (s *OC_OrderContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_OrderContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_OrderContext) BY() antlr.TerminalNode {
	return s.GetToken(CypherParserBY, 0)
}

func (s *OC_OrderContext) AllOC_SortItem() []IOC_SortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_SortItemContext)(nil)).Elem())
	var tst = make([]IOC_SortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_SortItemContext)
		}
	}

	return tst
}

func (s *OC_OrderContext) OC_SortItem(i int) IOC_SortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_SortItemContext)
}

func (s *OC_OrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_OrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_OrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Order(s)
	}
}

func (s *OC_OrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Order(s)
	}
}




func (p *CypherParser) OC_Order() (localctx IOC_OrderContext) {
	localctx = NewOC_OrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CypherParserRULE_oC_Order)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.Match(CypherParserORDER)
	}
	{
		p.SetState(615)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(616)
		p.Match(CypherParserBY)
	}
	{
		p.SetState(617)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(618)
		p.OC_SortItem()
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == CypherParserT__1 {
		{
			p.SetState(619)
			p.Match(CypherParserT__1)
		}
		p.SetState(621)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(620)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(623)
			p.OC_SortItem()
		}


		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IOC_SkipContext is an interface to support dynamic dispatch.
type IOC_SkipContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SkipContext differentiates from other interfaces.
	IsOC_SkipContext()
}

type OC_SkipContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SkipContext() *OC_SkipContext {
	var p = new(OC_SkipContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Skip
	return p
}

func (*OC_SkipContext) IsOC_SkipContext() {}

func NewOC_SkipContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SkipContext {
	var p = new(OC_SkipContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Skip

	return p
}

func (s *OC_SkipContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SkipContext) L_SKIP() antlr.TerminalNode {
	return s.GetToken(CypherParserL_SKIP, 0)
}

func (s *OC_SkipContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_SkipContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_SkipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SkipContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_SkipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Skip(s)
	}
}

func (s *OC_SkipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Skip(s)
	}
}




func (p *CypherParser) OC_Skip() (localctx IOC_SkipContext) {
	localctx = NewOC_SkipContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CypherParserRULE_oC_Skip)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)
		p.Match(CypherParserL_SKIP)
	}
	{
		p.SetState(630)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(631)
		p.OC_Expression()
	}



	return localctx
}


// IOC_LimitContext is an interface to support dynamic dispatch.
type IOC_LimitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_LimitContext differentiates from other interfaces.
	IsOC_LimitContext()
}

type OC_LimitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_LimitContext() *OC_LimitContext {
	var p = new(OC_LimitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Limit
	return p
}

func (*OC_LimitContext) IsOC_LimitContext() {}

func NewOC_LimitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_LimitContext {
	var p = new(OC_LimitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Limit

	return p
}

func (s *OC_LimitContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_LimitContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserLIMIT, 0)
}

func (s *OC_LimitContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_LimitContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_LimitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_LimitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_LimitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Limit(s)
	}
}

func (s *OC_LimitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Limit(s)
	}
}




func (p *CypherParser) OC_Limit() (localctx IOC_LimitContext) {
	localctx = NewOC_LimitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CypherParserRULE_oC_Limit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Match(CypherParserLIMIT)
	}
	{
		p.SetState(634)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(635)
		p.OC_Expression()
	}



	return localctx
}


// IOC_SortItemContext is an interface to support dynamic dispatch.
type IOC_SortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SortItemContext differentiates from other interfaces.
	IsOC_SortItemContext()
}

type OC_SortItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SortItemContext() *OC_SortItemContext {
	var p = new(OC_SortItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_SortItem
	return p
}

func (*OC_SortItemContext) IsOC_SortItemContext() {}

func NewOC_SortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SortItemContext {
	var p = new(OC_SortItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_SortItem

	return p
}

func (s *OC_SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SortItemContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_SortItemContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserASCENDING, 0)
}

func (s *OC_SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(CypherParserASC, 0)
}

func (s *OC_SortItemContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserDESCENDING, 0)
}

func (s *OC_SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(CypherParserDESC, 0)
}

func (s *OC_SortItemContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_SortItem(s)
	}
}

func (s *OC_SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_SortItem(s)
	}
}




func (p *CypherParser) OC_SortItem() (localctx IOC_SortItemContext) {
	localctx = NewOC_SortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CypherParserRULE_oC_SortItem)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.OC_Expression()
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(638)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(641)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (CypherParserASCENDING - 68)) | (1 << (CypherParserASC - 68)) | (1 << (CypherParserDESCENDING - 68)) | (1 << (CypherParserDESC - 68)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}


	}



	return localctx
}


// IOC_WhereContext is an interface to support dynamic dispatch.
type IOC_WhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_WhereContext differentiates from other interfaces.
	IsOC_WhereContext()
}

type OC_WhereContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_WhereContext() *OC_WhereContext {
	var p = new(OC_WhereContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Where
	return p
}

func (*OC_WhereContext) IsOC_WhereContext() {}

func NewOC_WhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_WhereContext {
	var p = new(OC_WhereContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Where

	return p
}

func (s *OC_WhereContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_WhereContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *OC_WhereContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_WhereContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_WhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_WhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_WhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Where(s)
	}
}

func (s *OC_WhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Where(s)
	}
}




func (p *CypherParser) OC_Where() (localctx IOC_WhereContext) {
	localctx = NewOC_WhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CypherParserRULE_oC_Where)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Match(CypherParserWHERE)
	}
	{
		p.SetState(645)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(646)
		p.OC_Expression()
	}



	return localctx
}


// IOC_PatternContext is an interface to support dynamic dispatch.
type IOC_PatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternContext differentiates from other interfaces.
	IsOC_PatternContext()
}

type OC_PatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternContext() *OC_PatternContext {
	var p = new(OC_PatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Pattern
	return p
}

func (*OC_PatternContext) IsOC_PatternContext() {}

func NewOC_PatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternContext {
	var p = new(OC_PatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Pattern

	return p
}

func (s *OC_PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternContext) AllOC_PatternPart() []IOC_PatternPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_PatternPartContext)(nil)).Elem())
	var tst = make([]IOC_PatternPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_PatternPartContext)
		}
	}

	return tst
}

func (s *OC_PatternContext) OC_PatternPart(i int) IOC_PatternPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternPartContext)
}

func (s *OC_PatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_PatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Pattern(s)
	}
}

func (s *OC_PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Pattern(s)
	}
}




func (p *CypherParser) OC_Pattern() (localctx IOC_PatternContext) {
	localctx = NewOC_PatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CypherParserRULE_oC_Pattern)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.OC_PatternPart()
	}
	p.SetState(659)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(650)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(649)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(652)
				p.Match(CypherParserT__1)
			}
			p.SetState(654)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(653)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(656)
				p.OC_PatternPart()
			}


		}
		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_PatternPartContext is an interface to support dynamic dispatch.
type IOC_PatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternPartContext differentiates from other interfaces.
	IsOC_PatternPartContext()
}

type OC_PatternPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternPartContext() *OC_PatternPartContext {
	var p = new(OC_PatternPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_PatternPart
	return p
}

func (*OC_PatternPartContext) IsOC_PatternPartContext() {}

func NewOC_PatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternPartContext {
	var p = new(OC_PatternPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_PatternPart

	return p
}

func (s *OC_PatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternPartContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_PatternPartContext) OC_AnonymousPatternPart() IOC_AnonymousPatternPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_AnonymousPatternPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_AnonymousPatternPartContext)
}

func (s *OC_PatternPartContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_PatternPartContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_PatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PatternPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_PatternPart(s)
	}
}

func (s *OC_PatternPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_PatternPart(s)
	}
}




func (p *CypherParser) OC_PatternPart() (localctx IOC_PatternPartContext) {
	localctx = NewOC_PatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CypherParserRULE_oC_PatternPart)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(673)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(662)
			p.OC_Variable()
		}
		p.SetState(664)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(663)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(666)
			p.Match(CypherParserT__2)
		}
		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(667)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(670)
			p.OC_AnonymousPatternPart()
		}



	case CypherParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(672)
			p.OC_AnonymousPatternPart()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_AnonymousPatternPartContext is an interface to support dynamic dispatch.
type IOC_AnonymousPatternPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_AnonymousPatternPartContext differentiates from other interfaces.
	IsOC_AnonymousPatternPartContext()
}

type OC_AnonymousPatternPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_AnonymousPatternPartContext() *OC_AnonymousPatternPartContext {
	var p = new(OC_AnonymousPatternPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_AnonymousPatternPart
	return p
}

func (*OC_AnonymousPatternPartContext) IsOC_AnonymousPatternPartContext() {}

func NewOC_AnonymousPatternPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_AnonymousPatternPartContext {
	var p = new(OC_AnonymousPatternPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_AnonymousPatternPart

	return p
}

func (s *OC_AnonymousPatternPartContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_AnonymousPatternPartContext) OC_PatternElement() IOC_PatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternElementContext)
}

func (s *OC_AnonymousPatternPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_AnonymousPatternPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_AnonymousPatternPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_AnonymousPatternPart(s)
	}
}

func (s *OC_AnonymousPatternPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_AnonymousPatternPart(s)
	}
}




func (p *CypherParser) OC_AnonymousPatternPart() (localctx IOC_AnonymousPatternPartContext) {
	localctx = NewOC_AnonymousPatternPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CypherParserRULE_oC_AnonymousPatternPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(675)
		p.OC_PatternElement()
	}



	return localctx
}


// IOC_PatternElementContext is an interface to support dynamic dispatch.
type IOC_PatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternElementContext differentiates from other interfaces.
	IsOC_PatternElementContext()
}

type OC_PatternElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternElementContext() *OC_PatternElementContext {
	var p = new(OC_PatternElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_PatternElement
	return p
}

func (*OC_PatternElementContext) IsOC_PatternElementContext() {}

func NewOC_PatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternElementContext {
	var p = new(OC_PatternElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_PatternElement

	return p
}

func (s *OC_PatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternElementContext) OC_NodePattern() IOC_NodePatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NodePatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NodePatternContext)
}

func (s *OC_PatternElementContext) AllOC_PatternElementChain() []IOC_PatternElementChainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_PatternElementChainContext)(nil)).Elem())
	var tst = make([]IOC_PatternElementChainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_PatternElementChainContext)
		}
	}

	return tst
}

func (s *OC_PatternElementContext) OC_PatternElementChain(i int) IOC_PatternElementChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternElementChainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternElementChainContext)
}

func (s *OC_PatternElementContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_PatternElementContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_PatternElementContext) OC_PatternElement() IOC_PatternElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternElementContext)
}

func (s *OC_PatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PatternElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_PatternElement(s)
	}
}

func (s *OC_PatternElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_PatternElement(s)
	}
}




func (p *CypherParser) OC_PatternElement() (localctx IOC_PatternElementContext) {
	localctx = NewOC_PatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CypherParserRULE_oC_PatternElement)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(677)
			p.OC_NodePattern()
		}
		p.SetState(684)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(679)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(678)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(681)
					p.OC_PatternElementChain()
				}


			}
			p.SetState(686)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(687)
			p.Match(CypherParserT__5)
		}
		{
			p.SetState(688)
			p.OC_PatternElement()
		}
		{
			p.SetState(689)
			p.Match(CypherParserT__6)
		}


	}


	return localctx
}


// IOC_RelationshipsPatternContext is an interface to support dynamic dispatch.
type IOC_RelationshipsPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RelationshipsPatternContext differentiates from other interfaces.
	IsOC_RelationshipsPatternContext()
}

type OC_RelationshipsPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RelationshipsPatternContext() *OC_RelationshipsPatternContext {
	var p = new(OC_RelationshipsPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_RelationshipsPattern
	return p
}

func (*OC_RelationshipsPatternContext) IsOC_RelationshipsPatternContext() {}

func NewOC_RelationshipsPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RelationshipsPatternContext {
	var p = new(OC_RelationshipsPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_RelationshipsPattern

	return p
}

func (s *OC_RelationshipsPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RelationshipsPatternContext) OC_NodePattern() IOC_NodePatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NodePatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NodePatternContext)
}

func (s *OC_RelationshipsPatternContext) AllOC_PatternElementChain() []IOC_PatternElementChainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_PatternElementChainContext)(nil)).Elem())
	var tst = make([]IOC_PatternElementChainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_PatternElementChainContext)
		}
	}

	return tst
}

func (s *OC_RelationshipsPatternContext) OC_PatternElementChain(i int) IOC_PatternElementChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternElementChainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternElementChainContext)
}

func (s *OC_RelationshipsPatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_RelationshipsPatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_RelationshipsPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RelationshipsPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_RelationshipsPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_RelationshipsPattern(s)
	}
}

func (s *OC_RelationshipsPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_RelationshipsPattern(s)
	}
}




func (p *CypherParser) OC_RelationshipsPattern() (localctx IOC_RelationshipsPatternContext) {
	localctx = NewOC_RelationshipsPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CypherParserRULE_oC_RelationshipsPattern)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.OC_NodePattern()
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(695)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(694)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(697)
					p.OC_PatternElementChain()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_NodePatternContext is an interface to support dynamic dispatch.
type IOC_NodePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NodePatternContext differentiates from other interfaces.
	IsOC_NodePatternContext()
}

type OC_NodePatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NodePatternContext() *OC_NodePatternContext {
	var p = new(OC_NodePatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_NodePattern
	return p
}

func (*OC_NodePatternContext) IsOC_NodePatternContext() {}

func NewOC_NodePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NodePatternContext {
	var p = new(OC_NodePatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_NodePattern

	return p
}

func (s *OC_NodePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NodePatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_NodePatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_NodePatternContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_NodePatternContext) OC_NodeLabels() IOC_NodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NodeLabelsContext)
}

func (s *OC_NodePatternContext) OC_Properties() IOC_PropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PropertiesContext)
}

func (s *OC_NodePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NodePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_NodePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_NodePattern(s)
	}
}

func (s *OC_NodePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_NodePattern(s)
	}
}




func (p *CypherParser) OC_NodePattern() (localctx IOC_NodePatternContext) {
	localctx = NewOC_NodePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CypherParserRULE_oC_NodePattern)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(CypherParserT__5)
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(703)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 83)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 83))) & ((1 << (CypherParserCOUNT - 83)) | (1 << (CypherParserANY - 83)) | (1 << (CypherParserNONE - 83)) | (1 << (CypherParserSINGLE - 83)) | (1 << (CypherParserHexLetter - 83)))) != 0) || ((((_la - 119)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 119))) & ((1 << (CypherParserFILTER - 119)) | (1 << (CypherParserEXTRACT - 119)) | (1 << (CypherParserUnescapedSymbolicName - 119)) | (1 << (CypherParserEscapedSymbolicName - 119)))) != 0) {
		{
			p.SetState(706)
			p.OC_Variable()
		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(707)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserT__9 {
		{
			p.SetState(712)
			p.OC_NodeLabels()
		}
		p.SetState(714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(713)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserT__23 || _la == CypherParserT__25 {
		{
			p.SetState(718)
			p.OC_Properties()
		}
		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(719)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(724)
		p.Match(CypherParserT__6)
	}



	return localctx
}


// IOC_PatternElementChainContext is an interface to support dynamic dispatch.
type IOC_PatternElementChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternElementChainContext differentiates from other interfaces.
	IsOC_PatternElementChainContext()
}

type OC_PatternElementChainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternElementChainContext() *OC_PatternElementChainContext {
	var p = new(OC_PatternElementChainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_PatternElementChain
	return p
}

func (*OC_PatternElementChainContext) IsOC_PatternElementChainContext() {}

func NewOC_PatternElementChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternElementChainContext {
	var p = new(OC_PatternElementChainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_PatternElementChain

	return p
}

func (s *OC_PatternElementChainContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternElementChainContext) OC_RelationshipPattern() IOC_RelationshipPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RelationshipPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_RelationshipPatternContext)
}

func (s *OC_PatternElementChainContext) OC_NodePattern() IOC_NodePatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NodePatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NodePatternContext)
}

func (s *OC_PatternElementChainContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_PatternElementChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternElementChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PatternElementChainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_PatternElementChain(s)
	}
}

func (s *OC_PatternElementChainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_PatternElementChain(s)
	}
}




func (p *CypherParser) OC_PatternElementChain() (localctx IOC_PatternElementChainContext) {
	localctx = NewOC_PatternElementChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CypherParserRULE_oC_PatternElementChain)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.OC_RelationshipPattern()
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(727)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(730)
		p.OC_NodePattern()
	}



	return localctx
}


// IOC_RelationshipPatternContext is an interface to support dynamic dispatch.
type IOC_RelationshipPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RelationshipPatternContext differentiates from other interfaces.
	IsOC_RelationshipPatternContext()
}

type OC_RelationshipPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RelationshipPatternContext() *OC_RelationshipPatternContext {
	var p = new(OC_RelationshipPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_RelationshipPattern
	return p
}

func (*OC_RelationshipPatternContext) IsOC_RelationshipPatternContext() {}

func NewOC_RelationshipPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RelationshipPatternContext {
	var p = new(OC_RelationshipPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_RelationshipPattern

	return p
}

func (s *OC_RelationshipPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RelationshipPatternContext) OC_LeftArrowHead() IOC_LeftArrowHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_LeftArrowHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_LeftArrowHeadContext)
}

func (s *OC_RelationshipPatternContext) AllOC_Dash() []IOC_DashContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_DashContext)(nil)).Elem())
	var tst = make([]IOC_DashContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_DashContext)
		}
	}

	return tst
}

func (s *OC_RelationshipPatternContext) OC_Dash(i int) IOC_DashContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_DashContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_DashContext)
}

func (s *OC_RelationshipPatternContext) OC_RightArrowHead() IOC_RightArrowHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RightArrowHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_RightArrowHeadContext)
}

func (s *OC_RelationshipPatternContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_RelationshipPatternContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_RelationshipPatternContext) OC_RelationshipDetail() IOC_RelationshipDetailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RelationshipDetailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_RelationshipDetailContext)
}

func (s *OC_RelationshipPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RelationshipPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_RelationshipPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_RelationshipPattern(s)
	}
}

func (s *OC_RelationshipPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_RelationshipPattern(s)
	}
}




func (p *CypherParser) OC_RelationshipPattern() (localctx IOC_RelationshipPatternContext) {
	localctx = NewOC_RelationshipPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CypherParserRULE_oC_RelationshipPattern)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(796)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(732)
			p.OC_LeftArrowHead()
		}
		p.SetState(734)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(733)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(736)
			p.OC_Dash()
		}
		p.SetState(738)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(737)
				p.Match(CypherParserSP)
			}


		}
		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserT__7 {
			{
				p.SetState(740)
				p.OC_RelationshipDetail()
			}

		}
		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(743)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(746)
			p.OC_Dash()
		}
		p.SetState(748)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(747)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(750)
			p.OC_RightArrowHead()
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.OC_LeftArrowHead()
		}
		p.SetState(754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(753)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(756)
			p.OC_Dash()
		}
		p.SetState(758)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(757)
				p.Match(CypherParserSP)
			}


		}
		p.SetState(761)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserT__7 {
			{
				p.SetState(760)
				p.OC_RelationshipDetail()
			}

		}
		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(763)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(766)
			p.OC_Dash()
		}



	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(768)
			p.OC_Dash()
		}
		p.SetState(770)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(769)
				p.Match(CypherParserSP)
			}


		}
		p.SetState(773)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserT__7 {
			{
				p.SetState(772)
				p.OC_RelationshipDetail()
			}

		}
		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(775)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(778)
			p.OC_Dash()
		}
		p.SetState(780)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(779)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(782)
			p.OC_RightArrowHead()
		}



	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(784)
			p.OC_Dash()
		}
		p.SetState(786)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(785)
				p.Match(CypherParserSP)
			}


		}
		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserT__7 {
			{
				p.SetState(788)
				p.OC_RelationshipDetail()
			}

		}
		p.SetState(792)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(791)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(794)
			p.OC_Dash()
		}


	}


	return localctx
}


// IOC_RelationshipDetailContext is an interface to support dynamic dispatch.
type IOC_RelationshipDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RelationshipDetailContext differentiates from other interfaces.
	IsOC_RelationshipDetailContext()
}

type OC_RelationshipDetailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RelationshipDetailContext() *OC_RelationshipDetailContext {
	var p = new(OC_RelationshipDetailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_RelationshipDetail
	return p
}

func (*OC_RelationshipDetailContext) IsOC_RelationshipDetailContext() {}

func NewOC_RelationshipDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RelationshipDetailContext {
	var p = new(OC_RelationshipDetailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_RelationshipDetail

	return p
}

func (s *OC_RelationshipDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RelationshipDetailContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_RelationshipDetailContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_RelationshipDetailContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_RelationshipDetailContext) OC_RelationshipTypes() IOC_RelationshipTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RelationshipTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_RelationshipTypesContext)
}

func (s *OC_RelationshipDetailContext) OC_RangeLiteral() IOC_RangeLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RangeLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_RangeLiteralContext)
}

func (s *OC_RelationshipDetailContext) OC_Properties() IOC_PropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PropertiesContext)
}

func (s *OC_RelationshipDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RelationshipDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_RelationshipDetailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_RelationshipDetail(s)
	}
}

func (s *OC_RelationshipDetailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_RelationshipDetail(s)
	}
}




func (p *CypherParser) OC_RelationshipDetail() (localctx IOC_RelationshipDetailContext) {
	localctx = NewOC_RelationshipDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CypherParserRULE_oC_RelationshipDetail)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		p.Match(CypherParserT__7)
	}
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(799)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 83)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 83))) & ((1 << (CypherParserCOUNT - 83)) | (1 << (CypherParserANY - 83)) | (1 << (CypherParserNONE - 83)) | (1 << (CypherParserSINGLE - 83)) | (1 << (CypherParserHexLetter - 83)))) != 0) || ((((_la - 119)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 119))) & ((1 << (CypherParserFILTER - 119)) | (1 << (CypherParserEXTRACT - 119)) | (1 << (CypherParserUnescapedSymbolicName - 119)) | (1 << (CypherParserEscapedSymbolicName - 119)))) != 0) {
		{
			p.SetState(802)
			p.OC_Variable()
		}
		p.SetState(804)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(803)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(812)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserT__9 {
		{
			p.SetState(808)
			p.OC_RelationshipTypes()
		}
		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(809)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(815)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserT__4 {
		{
			p.SetState(814)
			p.OC_RangeLiteral()
		}

	}
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserT__23 || _la == CypherParserT__25 {
		{
			p.SetState(817)
			p.OC_Properties()
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(818)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(823)
		p.Match(CypherParserT__8)
	}



	return localctx
}


// IOC_PropertiesContext is an interface to support dynamic dispatch.
type IOC_PropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PropertiesContext differentiates from other interfaces.
	IsOC_PropertiesContext()
}

type OC_PropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PropertiesContext() *OC_PropertiesContext {
	var p = new(OC_PropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Properties
	return p
}

func (*OC_PropertiesContext) IsOC_PropertiesContext() {}

func NewOC_PropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PropertiesContext {
	var p = new(OC_PropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Properties

	return p
}

func (s *OC_PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PropertiesContext) OC_MapLiteral() IOC_MapLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_MapLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_MapLiteralContext)
}

func (s *OC_PropertiesContext) OC_Parameter() IOC_ParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ParameterContext)
}

func (s *OC_PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Properties(s)
	}
}

func (s *OC_PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Properties(s)
	}
}




func (p *CypherParser) OC_Properties() (localctx IOC_PropertiesContext) {
	localctx = NewOC_PropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CypherParserRULE_oC_Properties)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(827)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__23:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(825)
			p.OC_MapLiteral()
		}


	case CypherParserT__25:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(826)
			p.OC_Parameter()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_RelationshipTypesContext is an interface to support dynamic dispatch.
type IOC_RelationshipTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RelationshipTypesContext differentiates from other interfaces.
	IsOC_RelationshipTypesContext()
}

type OC_RelationshipTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RelationshipTypesContext() *OC_RelationshipTypesContext {
	var p = new(OC_RelationshipTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_RelationshipTypes
	return p
}

func (*OC_RelationshipTypesContext) IsOC_RelationshipTypesContext() {}

func NewOC_RelationshipTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RelationshipTypesContext {
	var p = new(OC_RelationshipTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_RelationshipTypes

	return p
}

func (s *OC_RelationshipTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RelationshipTypesContext) AllOC_RelTypeName() []IOC_RelTypeNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_RelTypeNameContext)(nil)).Elem())
	var tst = make([]IOC_RelTypeNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_RelTypeNameContext)
		}
	}

	return tst
}

func (s *OC_RelationshipTypesContext) OC_RelTypeName(i int) IOC_RelTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RelTypeNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_RelTypeNameContext)
}

func (s *OC_RelationshipTypesContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_RelationshipTypesContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_RelationshipTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RelationshipTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_RelationshipTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_RelationshipTypes(s)
	}
}

func (s *OC_RelationshipTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_RelationshipTypes(s)
	}
}




func (p *CypherParser) OC_RelationshipTypes() (localctx IOC_RelationshipTypesContext) {
	localctx = NewOC_RelationshipTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CypherParserRULE_oC_RelationshipTypes)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.Match(CypherParserT__9)
	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(830)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(833)
		p.OC_RelTypeName()
	}
	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(835)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(834)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(837)
				p.Match(CypherParserT__10)
			}
			p.SetState(839)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserT__9 {
				{
					p.SetState(838)
					p.Match(CypherParserT__9)
				}

			}
			p.SetState(842)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(841)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(844)
				p.OC_RelTypeName()
			}


		}
		p.SetState(849)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_NodeLabelsContext is an interface to support dynamic dispatch.
type IOC_NodeLabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NodeLabelsContext differentiates from other interfaces.
	IsOC_NodeLabelsContext()
}

type OC_NodeLabelsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NodeLabelsContext() *OC_NodeLabelsContext {
	var p = new(OC_NodeLabelsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_NodeLabels
	return p
}

func (*OC_NodeLabelsContext) IsOC_NodeLabelsContext() {}

func NewOC_NodeLabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NodeLabelsContext {
	var p = new(OC_NodeLabelsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_NodeLabels

	return p
}

func (s *OC_NodeLabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NodeLabelsContext) AllOC_NodeLabel() []IOC_NodeLabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_NodeLabelContext)(nil)).Elem())
	var tst = make([]IOC_NodeLabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_NodeLabelContext)
		}
	}

	return tst
}

func (s *OC_NodeLabelsContext) OC_NodeLabel(i int) IOC_NodeLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NodeLabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_NodeLabelContext)
}

func (s *OC_NodeLabelsContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_NodeLabelsContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_NodeLabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NodeLabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_NodeLabelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_NodeLabels(s)
	}
}

func (s *OC_NodeLabelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_NodeLabels(s)
	}
}




func (p *CypherParser) OC_NodeLabels() (localctx IOC_NodeLabelsContext) {
	localctx = NewOC_NodeLabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CypherParserRULE_oC_NodeLabels)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.OC_NodeLabel()
	}
	p.SetState(857)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(852)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(851)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(854)
				p.OC_NodeLabel()
			}


		}
		p.SetState(859)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_NodeLabelContext is an interface to support dynamic dispatch.
type IOC_NodeLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NodeLabelContext differentiates from other interfaces.
	IsOC_NodeLabelContext()
}

type OC_NodeLabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NodeLabelContext() *OC_NodeLabelContext {
	var p = new(OC_NodeLabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_NodeLabel
	return p
}

func (*OC_NodeLabelContext) IsOC_NodeLabelContext() {}

func NewOC_NodeLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NodeLabelContext {
	var p = new(OC_NodeLabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_NodeLabel

	return p
}

func (s *OC_NodeLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NodeLabelContext) OC_LabelName() IOC_LabelNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_LabelNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_LabelNameContext)
}

func (s *OC_NodeLabelContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_NodeLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NodeLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_NodeLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_NodeLabel(s)
	}
}

func (s *OC_NodeLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_NodeLabel(s)
	}
}




func (p *CypherParser) OC_NodeLabel() (localctx IOC_NodeLabelContext) {
	localctx = NewOC_NodeLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CypherParserRULE_oC_NodeLabel)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.Match(CypherParserT__9)
	}
	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(861)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(864)
		p.OC_LabelName()
	}



	return localctx
}


// IOC_RangeLiteralContext is an interface to support dynamic dispatch.
type IOC_RangeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RangeLiteralContext differentiates from other interfaces.
	IsOC_RangeLiteralContext()
}

type OC_RangeLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RangeLiteralContext() *OC_RangeLiteralContext {
	var p = new(OC_RangeLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_RangeLiteral
	return p
}

func (*OC_RangeLiteralContext) IsOC_RangeLiteralContext() {}

func NewOC_RangeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RangeLiteralContext {
	var p = new(OC_RangeLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_RangeLiteral

	return p
}

func (s *OC_RangeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RangeLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_RangeLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_RangeLiteralContext) AllOC_IntegerLiteral() []IOC_IntegerLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_IntegerLiteralContext)(nil)).Elem())
	var tst = make([]IOC_IntegerLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_IntegerLiteralContext)
		}
	}

	return tst
}

func (s *OC_RangeLiteralContext) OC_IntegerLiteral(i int) IOC_IntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_IntegerLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_IntegerLiteralContext)
}

func (s *OC_RangeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RangeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_RangeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_RangeLiteral(s)
	}
}

func (s *OC_RangeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_RangeLiteral(s)
	}
}




func (p *CypherParser) OC_RangeLiteral() (localctx IOC_RangeLiteralContext) {
	localctx = NewOC_RangeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CypherParserRULE_oC_RangeLiteral)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.Match(CypherParserT__4)
	}
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(867)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 95)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 95))) & ((1 << (CypherParserHexInteger - 95)) | (1 << (CypherParserDecimalInteger - 95)) | (1 << (CypherParserOctalInteger - 95)))) != 0) {
		{
			p.SetState(870)
			p.OC_IntegerLiteral()
		}
		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(871)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserT__11 {
		{
			p.SetState(876)
			p.Match(CypherParserT__11)
		}
		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(877)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 95)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 95))) & ((1 << (CypherParserHexInteger - 95)) | (1 << (CypherParserDecimalInteger - 95)) | (1 << (CypherParserOctalInteger - 95)))) != 0) {
			{
				p.SetState(880)
				p.OC_IntegerLiteral()
			}
			p.SetState(882)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(881)
					p.Match(CypherParserSP)
				}

			}

		}

	}



	return localctx
}


// IOC_LabelNameContext is an interface to support dynamic dispatch.
type IOC_LabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_LabelNameContext differentiates from other interfaces.
	IsOC_LabelNameContext()
}

type OC_LabelNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_LabelNameContext() *OC_LabelNameContext {
	var p = new(OC_LabelNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_LabelName
	return p
}

func (*OC_LabelNameContext) IsOC_LabelNameContext() {}

func NewOC_LabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_LabelNameContext {
	var p = new(OC_LabelNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_LabelName

	return p
}

func (s *OC_LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_LabelNameContext) OC_SchemaName() IOC_SchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SchemaNameContext)
}

func (s *OC_LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_LabelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_LabelName(s)
	}
}

func (s *OC_LabelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_LabelName(s)
	}
}




func (p *CypherParser) OC_LabelName() (localctx IOC_LabelNameContext) {
	localctx = NewOC_LabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CypherParserRULE_oC_LabelName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		p.OC_SchemaName()
	}



	return localctx
}


// IOC_RelTypeNameContext is an interface to support dynamic dispatch.
type IOC_RelTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RelTypeNameContext differentiates from other interfaces.
	IsOC_RelTypeNameContext()
}

type OC_RelTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RelTypeNameContext() *OC_RelTypeNameContext {
	var p = new(OC_RelTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_RelTypeName
	return p
}

func (*OC_RelTypeNameContext) IsOC_RelTypeNameContext() {}

func NewOC_RelTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RelTypeNameContext {
	var p = new(OC_RelTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_RelTypeName

	return p
}

func (s *OC_RelTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_RelTypeNameContext) OC_SchemaName() IOC_SchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SchemaNameContext)
}

func (s *OC_RelTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RelTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_RelTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_RelTypeName(s)
	}
}

func (s *OC_RelTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_RelTypeName(s)
	}
}




func (p *CypherParser) OC_RelTypeName() (localctx IOC_RelTypeNameContext) {
	localctx = NewOC_RelTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CypherParserRULE_oC_RelTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.OC_SchemaName()
	}



	return localctx
}


// IOC_PropertyExpressionContext is an interface to support dynamic dispatch.
type IOC_PropertyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PropertyExpressionContext differentiates from other interfaces.
	IsOC_PropertyExpressionContext()
}

type OC_PropertyExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PropertyExpressionContext() *OC_PropertyExpressionContext {
	var p = new(OC_PropertyExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_PropertyExpression
	return p
}

func (*OC_PropertyExpressionContext) IsOC_PropertyExpressionContext() {}

func NewOC_PropertyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PropertyExpressionContext {
	var p = new(OC_PropertyExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_PropertyExpression

	return p
}

func (s *OC_PropertyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PropertyExpressionContext) OC_Atom() IOC_AtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_AtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_AtomContext)
}

func (s *OC_PropertyExpressionContext) AllOC_PropertyLookup() []IOC_PropertyLookupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_PropertyLookupContext)(nil)).Elem())
	var tst = make([]IOC_PropertyLookupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_PropertyLookupContext)
		}
	}

	return tst
}

func (s *OC_PropertyExpressionContext) OC_PropertyLookup(i int) IOC_PropertyLookupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PropertyLookupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyLookupContext)
}

func (s *OC_PropertyExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_PropertyExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_PropertyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PropertyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PropertyExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_PropertyExpression(s)
	}
}

func (s *OC_PropertyExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_PropertyExpression(s)
	}
}




func (p *CypherParser) OC_PropertyExpression() (localctx IOC_PropertyExpressionContext) {
	localctx = NewOC_PropertyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CypherParserRULE_oC_PropertyExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(892)
		p.OC_Atom()
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(894)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(893)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(896)
					p.OC_PropertyLookup()
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(899)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_ExpressionContext is an interface to support dynamic dispatch.
type IOC_ExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ExpressionContext differentiates from other interfaces.
	IsOC_ExpressionContext()
}

type OC_ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ExpressionContext() *OC_ExpressionContext {
	var p = new(OC_ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Expression
	return p
}

func (*OC_ExpressionContext) IsOC_ExpressionContext() {}

func NewOC_ExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ExpressionContext {
	var p = new(OC_ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Expression

	return p
}

func (s *OC_ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ExpressionContext) OC_OrExpression() IOC_OrExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_OrExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_OrExpressionContext)
}

func (s *OC_ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Expression(s)
	}
}

func (s *OC_ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Expression(s)
	}
}




func (p *CypherParser) OC_Expression() (localctx IOC_ExpressionContext) {
	localctx = NewOC_ExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CypherParserRULE_oC_Expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(901)
		p.OC_OrExpression()
	}



	return localctx
}


// IOC_OrExpressionContext is an interface to support dynamic dispatch.
type IOC_OrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_OrExpressionContext differentiates from other interfaces.
	IsOC_OrExpressionContext()
}

type OC_OrExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_OrExpressionContext() *OC_OrExpressionContext {
	var p = new(OC_OrExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_OrExpression
	return p
}

func (*OC_OrExpressionContext) IsOC_OrExpressionContext() {}

func NewOC_OrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_OrExpressionContext {
	var p = new(OC_OrExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_OrExpression

	return p
}

func (s *OC_OrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_OrExpressionContext) AllOC_XorExpression() []IOC_XorExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_XorExpressionContext)(nil)).Elem())
	var tst = make([]IOC_XorExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_XorExpressionContext)
		}
	}

	return tst
}

func (s *OC_OrExpressionContext) OC_XorExpression(i int) IOC_XorExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_XorExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_XorExpressionContext)
}

func (s *OC_OrExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_OrExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_OrExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(CypherParserOR)
}

func (s *OC_OrExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserOR, i)
}

func (s *OC_OrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_OrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_OrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_OrExpression(s)
	}
}

func (s *OC_OrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_OrExpression(s)
	}
}




func (p *CypherParser) OC_OrExpression() (localctx IOC_OrExpressionContext) {
	localctx = NewOC_OrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CypherParserRULE_oC_OrExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(903)
		p.OC_XorExpression()
	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(904)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(905)
				p.Match(CypherParserOR)
			}
			{
				p.SetState(906)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(907)
				p.OC_XorExpression()
			}


		}
		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_XorExpressionContext is an interface to support dynamic dispatch.
type IOC_XorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_XorExpressionContext differentiates from other interfaces.
	IsOC_XorExpressionContext()
}

type OC_XorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_XorExpressionContext() *OC_XorExpressionContext {
	var p = new(OC_XorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_XorExpression
	return p
}

func (*OC_XorExpressionContext) IsOC_XorExpressionContext() {}

func NewOC_XorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_XorExpressionContext {
	var p = new(OC_XorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_XorExpression

	return p
}

func (s *OC_XorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_XorExpressionContext) AllOC_AndExpression() []IOC_AndExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_AndExpressionContext)(nil)).Elem())
	var tst = make([]IOC_AndExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_AndExpressionContext)
		}
	}

	return tst
}

func (s *OC_XorExpressionContext) OC_AndExpression(i int) IOC_AndExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_AndExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_AndExpressionContext)
}

func (s *OC_XorExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_XorExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_XorExpressionContext) AllXOR() []antlr.TerminalNode {
	return s.GetTokens(CypherParserXOR)
}

func (s *OC_XorExpressionContext) XOR(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserXOR, i)
}

func (s *OC_XorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_XorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_XorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_XorExpression(s)
	}
}

func (s *OC_XorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_XorExpression(s)
	}
}




func (p *CypherParser) OC_XorExpression() (localctx IOC_XorExpressionContext) {
	localctx = NewOC_XorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CypherParserRULE_oC_XorExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(913)
		p.OC_AndExpression()
	}
	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(914)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(915)
				p.Match(CypherParserXOR)
			}
			{
				p.SetState(916)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(917)
				p.OC_AndExpression()
			}


		}
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_AndExpressionContext is an interface to support dynamic dispatch.
type IOC_AndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_AndExpressionContext differentiates from other interfaces.
	IsOC_AndExpressionContext()
}

type OC_AndExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_AndExpressionContext() *OC_AndExpressionContext {
	var p = new(OC_AndExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_AndExpression
	return p
}

func (*OC_AndExpressionContext) IsOC_AndExpressionContext() {}

func NewOC_AndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_AndExpressionContext {
	var p = new(OC_AndExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_AndExpression

	return p
}

func (s *OC_AndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_AndExpressionContext) AllOC_NotExpression() []IOC_NotExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_NotExpressionContext)(nil)).Elem())
	var tst = make([]IOC_NotExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_NotExpressionContext)
		}
	}

	return tst
}

func (s *OC_AndExpressionContext) OC_NotExpression(i int) IOC_NotExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NotExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_NotExpressionContext)
}

func (s *OC_AndExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_AndExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_AndExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(CypherParserAND)
}

func (s *OC_AndExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserAND, i)
}

func (s *OC_AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_AndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_AndExpression(s)
	}
}

func (s *OC_AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_AndExpression(s)
	}
}




func (p *CypherParser) OC_AndExpression() (localctx IOC_AndExpressionContext) {
	localctx = NewOC_AndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CypherParserRULE_oC_AndExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(923)
		p.OC_NotExpression()
	}
	p.SetState(930)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(924)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(925)
				p.Match(CypherParserAND)
			}
			{
				p.SetState(926)
				p.Match(CypherParserSP)
			}
			{
				p.SetState(927)
				p.OC_NotExpression()
			}


		}
		p.SetState(932)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_NotExpressionContext is an interface to support dynamic dispatch.
type IOC_NotExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NotExpressionContext differentiates from other interfaces.
	IsOC_NotExpressionContext()
}

type OC_NotExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NotExpressionContext() *OC_NotExpressionContext {
	var p = new(OC_NotExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_NotExpression
	return p
}

func (*OC_NotExpressionContext) IsOC_NotExpressionContext() {}

func NewOC_NotExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NotExpressionContext {
	var p = new(OC_NotExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_NotExpression

	return p
}

func (s *OC_NotExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NotExpressionContext) OC_ComparisonExpression() IOC_ComparisonExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ComparisonExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ComparisonExpressionContext)
}

func (s *OC_NotExpressionContext) AllNOT() []antlr.TerminalNode {
	return s.GetTokens(CypherParserNOT)
}

func (s *OC_NotExpressionContext) NOT(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, i)
}

func (s *OC_NotExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_NotExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NotExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_NotExpression(s)
	}
}

func (s *OC_NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_NotExpression(s)
	}
}




func (p *CypherParser) OC_NotExpression() (localctx IOC_NotExpressionContext) {
	localctx = NewOC_NotExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CypherParserRULE_oC_NotExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == CypherParserNOT {
		{
			p.SetState(933)
			p.Match(CypherParserNOT)
		}
		p.SetState(935)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(934)
				p.Match(CypherParserSP)
			}

		}


		p.SetState(941)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(942)
		p.OC_ComparisonExpression()
	}



	return localctx
}


// IOC_ComparisonExpressionContext is an interface to support dynamic dispatch.
type IOC_ComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ComparisonExpressionContext differentiates from other interfaces.
	IsOC_ComparisonExpressionContext()
}

type OC_ComparisonExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ComparisonExpressionContext() *OC_ComparisonExpressionContext {
	var p = new(OC_ComparisonExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ComparisonExpression
	return p
}

func (*OC_ComparisonExpressionContext) IsOC_ComparisonExpressionContext() {}

func NewOC_ComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ComparisonExpressionContext {
	var p = new(OC_ComparisonExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ComparisonExpression

	return p
}

func (s *OC_ComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ComparisonExpressionContext) OC_StringListNullPredicateExpression() IOC_StringListNullPredicateExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_StringListNullPredicateExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_StringListNullPredicateExpressionContext)
}

func (s *OC_ComparisonExpressionContext) AllOC_PartialComparisonExpression() []IOC_PartialComparisonExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_PartialComparisonExpressionContext)(nil)).Elem())
	var tst = make([]IOC_PartialComparisonExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_PartialComparisonExpressionContext)
		}
	}

	return tst
}

func (s *OC_ComparisonExpressionContext) OC_PartialComparisonExpression(i int) IOC_PartialComparisonExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PartialComparisonExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_PartialComparisonExpressionContext)
}

func (s *OC_ComparisonExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_ComparisonExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ComparisonExpression(s)
	}
}

func (s *OC_ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ComparisonExpression(s)
	}
}




func (p *CypherParser) OC_ComparisonExpression() (localctx IOC_ComparisonExpressionContext) {
	localctx = NewOC_ComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CypherParserRULE_oC_ComparisonExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.OC_StringListNullPredicateExpression()
	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(946)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(945)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(948)
				p.OC_PartialComparisonExpression()
			}


		}
		p.SetState(953)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_PartialComparisonExpressionContext is an interface to support dynamic dispatch.
type IOC_PartialComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PartialComparisonExpressionContext differentiates from other interfaces.
	IsOC_PartialComparisonExpressionContext()
}

type OC_PartialComparisonExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PartialComparisonExpressionContext() *OC_PartialComparisonExpressionContext {
	var p = new(OC_PartialComparisonExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_PartialComparisonExpression
	return p
}

func (*OC_PartialComparisonExpressionContext) IsOC_PartialComparisonExpressionContext() {}

func NewOC_PartialComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PartialComparisonExpressionContext {
	var p = new(OC_PartialComparisonExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_PartialComparisonExpression

	return p
}

func (s *OC_PartialComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PartialComparisonExpressionContext) OC_StringListNullPredicateExpression() IOC_StringListNullPredicateExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_StringListNullPredicateExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_StringListNullPredicateExpressionContext)
}

func (s *OC_PartialComparisonExpressionContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_PartialComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PartialComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PartialComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_PartialComparisonExpression(s)
	}
}

func (s *OC_PartialComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_PartialComparisonExpression(s)
	}
}




func (p *CypherParser) OC_PartialComparisonExpression() (localctx IOC_PartialComparisonExpressionContext) {
	localctx = NewOC_PartialComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CypherParserRULE_oC_PartialComparisonExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(984)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(954)
			p.Match(CypherParserT__2)
		}
		p.SetState(956)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(955)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(958)
			p.OC_StringListNullPredicateExpression()
		}



	case CypherParserT__12:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(959)
			p.Match(CypherParserT__12)
		}
		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(960)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(963)
			p.OC_StringListNullPredicateExpression()
		}



	case CypherParserT__13:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(964)
			p.Match(CypherParserT__13)
		}
		p.SetState(966)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(965)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(968)
			p.OC_StringListNullPredicateExpression()
		}



	case CypherParserT__14:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(969)
			p.Match(CypherParserT__14)
		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(970)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(973)
			p.OC_StringListNullPredicateExpression()
		}



	case CypherParserT__15:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(974)
			p.Match(CypherParserT__15)
		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(975)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(978)
			p.OC_StringListNullPredicateExpression()
		}



	case CypherParserT__16:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(979)
			p.Match(CypherParserT__16)
		}
		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(980)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(983)
			p.OC_StringListNullPredicateExpression()
		}




	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_StringListNullPredicateExpressionContext is an interface to support dynamic dispatch.
type IOC_StringListNullPredicateExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_StringListNullPredicateExpressionContext differentiates from other interfaces.
	IsOC_StringListNullPredicateExpressionContext()
}

type OC_StringListNullPredicateExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_StringListNullPredicateExpressionContext() *OC_StringListNullPredicateExpressionContext {
	var p = new(OC_StringListNullPredicateExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_StringListNullPredicateExpression
	return p
}

func (*OC_StringListNullPredicateExpressionContext) IsOC_StringListNullPredicateExpressionContext() {}

func NewOC_StringListNullPredicateExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_StringListNullPredicateExpressionContext {
	var p = new(OC_StringListNullPredicateExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_StringListNullPredicateExpression

	return p
}

func (s *OC_StringListNullPredicateExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_StringListNullPredicateExpressionContext) OC_AddOrSubtractExpression() IOC_AddOrSubtractExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_AddOrSubtractExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_AddOrSubtractExpressionContext)
}

func (s *OC_StringListNullPredicateExpressionContext) AllOC_StringPredicateExpression() []IOC_StringPredicateExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_StringPredicateExpressionContext)(nil)).Elem())
	var tst = make([]IOC_StringPredicateExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_StringPredicateExpressionContext)
		}
	}

	return tst
}

func (s *OC_StringListNullPredicateExpressionContext) OC_StringPredicateExpression(i int) IOC_StringPredicateExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_StringPredicateExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_StringPredicateExpressionContext)
}

func (s *OC_StringListNullPredicateExpressionContext) AllOC_ListPredicateExpression() []IOC_ListPredicateExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ListPredicateExpressionContext)(nil)).Elem())
	var tst = make([]IOC_ListPredicateExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ListPredicateExpressionContext)
		}
	}

	return tst
}

func (s *OC_StringListNullPredicateExpressionContext) OC_ListPredicateExpression(i int) IOC_ListPredicateExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ListPredicateExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ListPredicateExpressionContext)
}

func (s *OC_StringListNullPredicateExpressionContext) AllOC_NullPredicateExpression() []IOC_NullPredicateExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_NullPredicateExpressionContext)(nil)).Elem())
	var tst = make([]IOC_NullPredicateExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_NullPredicateExpressionContext)
		}
	}

	return tst
}

func (s *OC_StringListNullPredicateExpressionContext) OC_NullPredicateExpression(i int) IOC_NullPredicateExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NullPredicateExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_NullPredicateExpressionContext)
}

func (s *OC_StringListNullPredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_StringListNullPredicateExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_StringListNullPredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_StringListNullPredicateExpression(s)
	}
}

func (s *OC_StringListNullPredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_StringListNullPredicateExpression(s)
	}
}




func (p *CypherParser) OC_StringListNullPredicateExpression() (localctx IOC_StringListNullPredicateExpressionContext) {
	localctx = NewOC_StringListNullPredicateExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CypherParserRULE_oC_StringListNullPredicateExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(986)
		p.OC_AddOrSubtractExpression()
	}
	p.SetState(992)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(990)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(987)
					p.OC_StringPredicateExpression()
				}


			case 2:
				{
					p.SetState(988)
					p.OC_ListPredicateExpression()
				}


			case 3:
				{
					p.SetState(989)
					p.OC_NullPredicateExpression()
				}

			}

		}
		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_StringPredicateExpressionContext is an interface to support dynamic dispatch.
type IOC_StringPredicateExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_StringPredicateExpressionContext differentiates from other interfaces.
	IsOC_StringPredicateExpressionContext()
}

type OC_StringPredicateExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_StringPredicateExpressionContext() *OC_StringPredicateExpressionContext {
	var p = new(OC_StringPredicateExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_StringPredicateExpression
	return p
}

func (*OC_StringPredicateExpressionContext) IsOC_StringPredicateExpressionContext() {}

func NewOC_StringPredicateExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_StringPredicateExpressionContext {
	var p = new(OC_StringPredicateExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_StringPredicateExpression

	return p
}

func (s *OC_StringPredicateExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_StringPredicateExpressionContext) OC_AddOrSubtractExpression() IOC_AddOrSubtractExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_AddOrSubtractExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_AddOrSubtractExpressionContext)
}

func (s *OC_StringPredicateExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_StringPredicateExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_StringPredicateExpressionContext) STARTS() antlr.TerminalNode {
	return s.GetToken(CypherParserSTARTS, 0)
}

func (s *OC_StringPredicateExpressionContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *OC_StringPredicateExpressionContext) ENDS() antlr.TerminalNode {
	return s.GetToken(CypherParserENDS, 0)
}

func (s *OC_StringPredicateExpressionContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(CypherParserCONTAINS, 0)
}

func (s *OC_StringPredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_StringPredicateExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_StringPredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_StringPredicateExpression(s)
	}
}

func (s *OC_StringPredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_StringPredicateExpression(s)
	}
}




func (p *CypherParser) OC_StringPredicateExpression() (localctx IOC_StringPredicateExpressionContext) {
	localctx = NewOC_StringPredicateExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CypherParserRULE_oC_StringPredicateExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(995)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(996)
			p.Match(CypherParserSTARTS)
		}
		{
			p.SetState(997)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(998)
			p.Match(CypherParserWITH)
		}



	case 2:
		{
			p.SetState(999)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1000)
			p.Match(CypherParserENDS)
		}
		{
			p.SetState(1001)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1002)
			p.Match(CypherParserWITH)
		}



	case 3:
		{
			p.SetState(1003)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1004)
			p.Match(CypherParserCONTAINS)
		}


	}
	p.SetState(1008)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1007)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1010)
		p.OC_AddOrSubtractExpression()
	}



	return localctx
}


// IOC_ListPredicateExpressionContext is an interface to support dynamic dispatch.
type IOC_ListPredicateExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ListPredicateExpressionContext differentiates from other interfaces.
	IsOC_ListPredicateExpressionContext()
}

type OC_ListPredicateExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ListPredicateExpressionContext() *OC_ListPredicateExpressionContext {
	var p = new(OC_ListPredicateExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ListPredicateExpression
	return p
}

func (*OC_ListPredicateExpressionContext) IsOC_ListPredicateExpressionContext() {}

func NewOC_ListPredicateExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ListPredicateExpressionContext {
	var p = new(OC_ListPredicateExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ListPredicateExpression

	return p
}

func (s *OC_ListPredicateExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ListPredicateExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_ListPredicateExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_ListPredicateExpressionContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *OC_ListPredicateExpressionContext) OC_AddOrSubtractExpression() IOC_AddOrSubtractExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_AddOrSubtractExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_AddOrSubtractExpressionContext)
}

func (s *OC_ListPredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ListPredicateExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ListPredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ListPredicateExpression(s)
	}
}

func (s *OC_ListPredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ListPredicateExpression(s)
	}
}




func (p *CypherParser) OC_ListPredicateExpression() (localctx IOC_ListPredicateExpressionContext) {
	localctx = NewOC_ListPredicateExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CypherParserRULE_oC_ListPredicateExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1013)
		p.Match(CypherParserIN)
	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1014)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1017)
		p.OC_AddOrSubtractExpression()
	}



	return localctx
}


// IOC_NullPredicateExpressionContext is an interface to support dynamic dispatch.
type IOC_NullPredicateExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NullPredicateExpressionContext differentiates from other interfaces.
	IsOC_NullPredicateExpressionContext()
}

type OC_NullPredicateExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NullPredicateExpressionContext() *OC_NullPredicateExpressionContext {
	var p = new(OC_NullPredicateExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_NullPredicateExpression
	return p
}

func (*OC_NullPredicateExpressionContext) IsOC_NullPredicateExpressionContext() {}

func NewOC_NullPredicateExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NullPredicateExpressionContext {
	var p = new(OC_NullPredicateExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_NullPredicateExpression

	return p
}

func (s *OC_NullPredicateExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NullPredicateExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_NullPredicateExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_NullPredicateExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(CypherParserIS, 0)
}

func (s *OC_NullPredicateExpressionContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *OC_NullPredicateExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *OC_NullPredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NullPredicateExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_NullPredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_NullPredicateExpression(s)
	}
}

func (s *OC_NullPredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_NullPredicateExpression(s)
	}
}




func (p *CypherParser) OC_NullPredicateExpression() (localctx IOC_NullPredicateExpressionContext) {
	localctx = NewOC_NullPredicateExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CypherParserRULE_oC_NullPredicateExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1029)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1019)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1020)
			p.Match(CypherParserIS)
		}
		{
			p.SetState(1021)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1022)
			p.Match(CypherParserNULL)
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1023)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1024)
			p.Match(CypherParserIS)
		}
		{
			p.SetState(1025)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1026)
			p.Match(CypherParserNOT)
		}
		{
			p.SetState(1027)
			p.Match(CypherParserSP)
		}
		{
			p.SetState(1028)
			p.Match(CypherParserNULL)
		}


	}


	return localctx
}


// IOC_AddOrSubtractExpressionContext is an interface to support dynamic dispatch.
type IOC_AddOrSubtractExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_AddOrSubtractExpressionContext differentiates from other interfaces.
	IsOC_AddOrSubtractExpressionContext()
}

type OC_AddOrSubtractExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_AddOrSubtractExpressionContext() *OC_AddOrSubtractExpressionContext {
	var p = new(OC_AddOrSubtractExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_AddOrSubtractExpression
	return p
}

func (*OC_AddOrSubtractExpressionContext) IsOC_AddOrSubtractExpressionContext() {}

func NewOC_AddOrSubtractExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_AddOrSubtractExpressionContext {
	var p = new(OC_AddOrSubtractExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_AddOrSubtractExpression

	return p
}

func (s *OC_AddOrSubtractExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_AddOrSubtractExpressionContext) AllOC_MultiplyDivideModuloExpression() []IOC_MultiplyDivideModuloExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_MultiplyDivideModuloExpressionContext)(nil)).Elem())
	var tst = make([]IOC_MultiplyDivideModuloExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_MultiplyDivideModuloExpressionContext)
		}
	}

	return tst
}

func (s *OC_AddOrSubtractExpressionContext) OC_MultiplyDivideModuloExpression(i int) IOC_MultiplyDivideModuloExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_MultiplyDivideModuloExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_MultiplyDivideModuloExpressionContext)
}

func (s *OC_AddOrSubtractExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_AddOrSubtractExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_AddOrSubtractExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_AddOrSubtractExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_AddOrSubtractExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_AddOrSubtractExpression(s)
	}
}

func (s *OC_AddOrSubtractExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_AddOrSubtractExpression(s)
	}
}




func (p *CypherParser) OC_AddOrSubtractExpression() (localctx IOC_AddOrSubtractExpressionContext) {
	localctx = NewOC_AddOrSubtractExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CypherParserRULE_oC_AddOrSubtractExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1031)
		p.OC_MultiplyDivideModuloExpression()
	}
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1048)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) {
			case 1:
				p.SetState(1033)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1032)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1035)
					p.Match(CypherParserT__17)
				}
				p.SetState(1037)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1036)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1039)
					p.OC_MultiplyDivideModuloExpression()
				}



			case 2:
				p.SetState(1041)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1040)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1043)
					p.Match(CypherParserT__18)
				}
				p.SetState(1045)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1044)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1047)
					p.OC_MultiplyDivideModuloExpression()
				}


			}

		}
		p.SetState(1052)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_MultiplyDivideModuloExpressionContext is an interface to support dynamic dispatch.
type IOC_MultiplyDivideModuloExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MultiplyDivideModuloExpressionContext differentiates from other interfaces.
	IsOC_MultiplyDivideModuloExpressionContext()
}

type OC_MultiplyDivideModuloExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MultiplyDivideModuloExpressionContext() *OC_MultiplyDivideModuloExpressionContext {
	var p = new(OC_MultiplyDivideModuloExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_MultiplyDivideModuloExpression
	return p
}

func (*OC_MultiplyDivideModuloExpressionContext) IsOC_MultiplyDivideModuloExpressionContext() {}

func NewOC_MultiplyDivideModuloExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MultiplyDivideModuloExpressionContext {
	var p = new(OC_MultiplyDivideModuloExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_MultiplyDivideModuloExpression

	return p
}

func (s *OC_MultiplyDivideModuloExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MultiplyDivideModuloExpressionContext) AllOC_PowerOfExpression() []IOC_PowerOfExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_PowerOfExpressionContext)(nil)).Elem())
	var tst = make([]IOC_PowerOfExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_PowerOfExpressionContext)
		}
	}

	return tst
}

func (s *OC_MultiplyDivideModuloExpressionContext) OC_PowerOfExpression(i int) IOC_PowerOfExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PowerOfExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_PowerOfExpressionContext)
}

func (s *OC_MultiplyDivideModuloExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_MultiplyDivideModuloExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_MultiplyDivideModuloExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MultiplyDivideModuloExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_MultiplyDivideModuloExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_MultiplyDivideModuloExpression(s)
	}
}

func (s *OC_MultiplyDivideModuloExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_MultiplyDivideModuloExpression(s)
	}
}




func (p *CypherParser) OC_MultiplyDivideModuloExpression() (localctx IOC_MultiplyDivideModuloExpressionContext) {
	localctx = NewOC_MultiplyDivideModuloExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CypherParserRULE_oC_MultiplyDivideModuloExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1053)
		p.OC_PowerOfExpression()
	}
	p.SetState(1080)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1078)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext()) {
			case 1:
				p.SetState(1055)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1054)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1057)
					p.Match(CypherParserT__4)
				}
				p.SetState(1059)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1058)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1061)
					p.OC_PowerOfExpression()
				}



			case 2:
				p.SetState(1063)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1062)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1065)
					p.Match(CypherParserT__19)
				}
				p.SetState(1067)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1066)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1069)
					p.OC_PowerOfExpression()
				}



			case 3:
				p.SetState(1071)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1070)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1073)
					p.Match(CypherParserT__20)
				}
				p.SetState(1075)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1074)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1077)
					p.OC_PowerOfExpression()
				}


			}

		}
		p.SetState(1082)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_PowerOfExpressionContext is an interface to support dynamic dispatch.
type IOC_PowerOfExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PowerOfExpressionContext differentiates from other interfaces.
	IsOC_PowerOfExpressionContext()
}

type OC_PowerOfExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PowerOfExpressionContext() *OC_PowerOfExpressionContext {
	var p = new(OC_PowerOfExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_PowerOfExpression
	return p
}

func (*OC_PowerOfExpressionContext) IsOC_PowerOfExpressionContext() {}

func NewOC_PowerOfExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PowerOfExpressionContext {
	var p = new(OC_PowerOfExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_PowerOfExpression

	return p
}

func (s *OC_PowerOfExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PowerOfExpressionContext) AllOC_UnaryAddOrSubtractExpression() []IOC_UnaryAddOrSubtractExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_UnaryAddOrSubtractExpressionContext)(nil)).Elem())
	var tst = make([]IOC_UnaryAddOrSubtractExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_UnaryAddOrSubtractExpressionContext)
		}
	}

	return tst
}

func (s *OC_PowerOfExpressionContext) OC_UnaryAddOrSubtractExpression(i int) IOC_UnaryAddOrSubtractExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_UnaryAddOrSubtractExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_UnaryAddOrSubtractExpressionContext)
}

func (s *OC_PowerOfExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_PowerOfExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_PowerOfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PowerOfExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PowerOfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_PowerOfExpression(s)
	}
}

func (s *OC_PowerOfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_PowerOfExpression(s)
	}
}




func (p *CypherParser) OC_PowerOfExpression() (localctx IOC_PowerOfExpressionContext) {
	localctx = NewOC_PowerOfExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CypherParserRULE_oC_PowerOfExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1083)
		p.OC_UnaryAddOrSubtractExpression()
	}
	p.SetState(1094)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1085)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1084)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1087)
				p.Match(CypherParserT__21)
			}
			p.SetState(1089)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1088)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1091)
				p.OC_UnaryAddOrSubtractExpression()
			}


		}
		p.SetState(1096)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_UnaryAddOrSubtractExpressionContext is an interface to support dynamic dispatch.
type IOC_UnaryAddOrSubtractExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_UnaryAddOrSubtractExpressionContext differentiates from other interfaces.
	IsOC_UnaryAddOrSubtractExpressionContext()
}

type OC_UnaryAddOrSubtractExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_UnaryAddOrSubtractExpressionContext() *OC_UnaryAddOrSubtractExpressionContext {
	var p = new(OC_UnaryAddOrSubtractExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_UnaryAddOrSubtractExpression
	return p
}

func (*OC_UnaryAddOrSubtractExpressionContext) IsOC_UnaryAddOrSubtractExpressionContext() {}

func NewOC_UnaryAddOrSubtractExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_UnaryAddOrSubtractExpressionContext {
	var p = new(OC_UnaryAddOrSubtractExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_UnaryAddOrSubtractExpression

	return p
}

func (s *OC_UnaryAddOrSubtractExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_UnaryAddOrSubtractExpressionContext) OC_NonArithmeticOperatorExpression() IOC_NonArithmeticOperatorExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NonArithmeticOperatorExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NonArithmeticOperatorExpressionContext)
}

func (s *OC_UnaryAddOrSubtractExpressionContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_UnaryAddOrSubtractExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_UnaryAddOrSubtractExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_UnaryAddOrSubtractExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_UnaryAddOrSubtractExpression(s)
	}
}

func (s *OC_UnaryAddOrSubtractExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_UnaryAddOrSubtractExpression(s)
	}
}




func (p *CypherParser) OC_UnaryAddOrSubtractExpression() (localctx IOC_UnaryAddOrSubtractExpressionContext) {
	localctx = NewOC_UnaryAddOrSubtractExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CypherParserRULE_oC_UnaryAddOrSubtractExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1103)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserT__5, CypherParserT__7, CypherParserT__23, CypherParserT__25, CypherParserALL, CypherParserNULL, CypherParserCOUNT, CypherParserCASE, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserEXISTS, CypherParserTRUE, CypherParserFALSE, CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger, CypherParserHexLetter, CypherParserExponentDecimalReal, CypherParserRegularDecimalReal, CypherParserStringLiteral, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1097)
			p.OC_NonArithmeticOperatorExpression()
		}


	case CypherParserT__17, CypherParserT__18:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1098)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CypherParserT__17 || _la == CypherParserT__18) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		p.SetState(1100)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1099)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1102)
			p.OC_NonArithmeticOperatorExpression()
		}




	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_NonArithmeticOperatorExpressionContext is an interface to support dynamic dispatch.
type IOC_NonArithmeticOperatorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NonArithmeticOperatorExpressionContext differentiates from other interfaces.
	IsOC_NonArithmeticOperatorExpressionContext()
}

type OC_NonArithmeticOperatorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NonArithmeticOperatorExpressionContext() *OC_NonArithmeticOperatorExpressionContext {
	var p = new(OC_NonArithmeticOperatorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_NonArithmeticOperatorExpression
	return p
}

func (*OC_NonArithmeticOperatorExpressionContext) IsOC_NonArithmeticOperatorExpressionContext() {}

func NewOC_NonArithmeticOperatorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NonArithmeticOperatorExpressionContext {
	var p = new(OC_NonArithmeticOperatorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_NonArithmeticOperatorExpression

	return p
}

func (s *OC_NonArithmeticOperatorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NonArithmeticOperatorExpressionContext) OC_Atom() IOC_AtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_AtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_AtomContext)
}

func (s *OC_NonArithmeticOperatorExpressionContext) OC_NodeLabels() IOC_NodeLabelsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NodeLabelsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NodeLabelsContext)
}

func (s *OC_NonArithmeticOperatorExpressionContext) AllOC_ListOperatorExpression() []IOC_ListOperatorExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ListOperatorExpressionContext)(nil)).Elem())
	var tst = make([]IOC_ListOperatorExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ListOperatorExpressionContext)
		}
	}

	return tst
}

func (s *OC_NonArithmeticOperatorExpressionContext) OC_ListOperatorExpression(i int) IOC_ListOperatorExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ListOperatorExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ListOperatorExpressionContext)
}

func (s *OC_NonArithmeticOperatorExpressionContext) AllOC_PropertyLookup() []IOC_PropertyLookupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_PropertyLookupContext)(nil)).Elem())
	var tst = make([]IOC_PropertyLookupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_PropertyLookupContext)
		}
	}

	return tst
}

func (s *OC_NonArithmeticOperatorExpressionContext) OC_PropertyLookup(i int) IOC_PropertyLookupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PropertyLookupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyLookupContext)
}

func (s *OC_NonArithmeticOperatorExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_NonArithmeticOperatorExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_NonArithmeticOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NonArithmeticOperatorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_NonArithmeticOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_NonArithmeticOperatorExpression(s)
	}
}

func (s *OC_NonArithmeticOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_NonArithmeticOperatorExpression(s)
	}
}




func (p *CypherParser) OC_NonArithmeticOperatorExpression() (localctx IOC_NonArithmeticOperatorExpressionContext) {
	localctx = NewOC_NonArithmeticOperatorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CypherParserRULE_oC_NonArithmeticOperatorExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1105)
		p.OC_Atom()
	}
	p.SetState(1116)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1114)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext()) {
			case 1:
				p.SetState(1107)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1106)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1109)
					p.OC_ListOperatorExpression()
				}



			case 2:
				p.SetState(1111)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == CypherParserSP {
					{
						p.SetState(1110)
						p.Match(CypherParserSP)
					}

				}
				{
					p.SetState(1113)
					p.OC_PropertyLookup()
				}


			}

		}
		p.SetState(1118)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())
	}
	p.SetState(1123)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext()) == 1 {
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1119)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1122)
			p.OC_NodeLabels()
		}


	}



	return localctx
}


// IOC_ListOperatorExpressionContext is an interface to support dynamic dispatch.
type IOC_ListOperatorExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ListOperatorExpressionContext differentiates from other interfaces.
	IsOC_ListOperatorExpressionContext()
}

type OC_ListOperatorExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ListOperatorExpressionContext() *OC_ListOperatorExpressionContext {
	var p = new(OC_ListOperatorExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ListOperatorExpression
	return p
}

func (*OC_ListOperatorExpressionContext) IsOC_ListOperatorExpressionContext() {}

func NewOC_ListOperatorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ListOperatorExpressionContext {
	var p = new(OC_ListOperatorExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ListOperatorExpression

	return p
}

func (s *OC_ListOperatorExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ListOperatorExpressionContext) AllOC_Expression() []IOC_ExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem())
	var tst = make([]IOC_ExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ExpressionContext)
		}
	}

	return tst
}

func (s *OC_ListOperatorExpressionContext) OC_Expression(i int) IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ListOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ListOperatorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ListOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ListOperatorExpression(s)
	}
}

func (s *OC_ListOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ListOperatorExpression(s)
	}
}




func (p *CypherParser) OC_ListOperatorExpression() (localctx IOC_ListOperatorExpressionContext) {
	localctx = NewOC_ListOperatorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CypherParserRULE_oC_ListOperatorExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1138)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1125)
			p.Match(CypherParserT__7)
		}
		{
			p.SetState(1126)
			p.OC_Expression()
		}
		{
			p.SetState(1127)
			p.Match(CypherParserT__8)
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1129)
			p.Match(CypherParserT__7)
		}
		p.SetState(1131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << CypherParserT__5) | (1 << CypherParserT__7) | (1 << CypherParserT__17) | (1 << CypherParserT__18) | (1 << CypherParserT__23) | (1 << CypherParserT__25))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || ((((_la - 82)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 82))) & ((1 << (CypherParserNULL - 82)) | (1 << (CypherParserCOUNT - 82)) | (1 << (CypherParserCASE - 82)) | (1 << (CypherParserANY - 82)) | (1 << (CypherParserNONE - 82)) | (1 << (CypherParserSINGLE - 82)) | (1 << (CypherParserEXISTS - 82)) | (1 << (CypherParserTRUE - 82)) | (1 << (CypherParserFALSE - 82)) | (1 << (CypherParserHexInteger - 82)) | (1 << (CypherParserDecimalInteger - 82)) | (1 << (CypherParserOctalInteger - 82)) | (1 << (CypherParserHexLetter - 82)) | (1 << (CypherParserExponentDecimalReal - 82)) | (1 << (CypherParserRegularDecimalReal - 82)) | (1 << (CypherParserStringLiteral - 82)))) != 0) || ((((_la - 119)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 119))) & ((1 << (CypherParserFILTER - 119)) | (1 << (CypherParserEXTRACT - 119)) | (1 << (CypherParserUnescapedSymbolicName - 119)) | (1 << (CypherParserEscapedSymbolicName - 119)))) != 0) {
			{
				p.SetState(1130)
				p.OC_Expression()
			}

		}
		{
			p.SetState(1133)
			p.Match(CypherParserT__11)
		}
		p.SetState(1135)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << CypherParserT__5) | (1 << CypherParserT__7) | (1 << CypherParserT__17) | (1 << CypherParserT__18) | (1 << CypherParserT__23) | (1 << CypherParserT__25))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || ((((_la - 82)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 82))) & ((1 << (CypherParserNULL - 82)) | (1 << (CypherParserCOUNT - 82)) | (1 << (CypherParserCASE - 82)) | (1 << (CypherParserANY - 82)) | (1 << (CypherParserNONE - 82)) | (1 << (CypherParserSINGLE - 82)) | (1 << (CypherParserEXISTS - 82)) | (1 << (CypherParserTRUE - 82)) | (1 << (CypherParserFALSE - 82)) | (1 << (CypherParserHexInteger - 82)) | (1 << (CypherParserDecimalInteger - 82)) | (1 << (CypherParserOctalInteger - 82)) | (1 << (CypherParserHexLetter - 82)) | (1 << (CypherParserExponentDecimalReal - 82)) | (1 << (CypherParserRegularDecimalReal - 82)) | (1 << (CypherParserStringLiteral - 82)))) != 0) || ((((_la - 119)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 119))) & ((1 << (CypherParserFILTER - 119)) | (1 << (CypherParserEXTRACT - 119)) | (1 << (CypherParserUnescapedSymbolicName - 119)) | (1 << (CypherParserEscapedSymbolicName - 119)))) != 0) {
			{
				p.SetState(1134)
				p.OC_Expression()
			}

		}
		{
			p.SetState(1137)
			p.Match(CypherParserT__8)
		}


	}


	return localctx
}


// IOC_PropertyLookupContext is an interface to support dynamic dispatch.
type IOC_PropertyLookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PropertyLookupContext differentiates from other interfaces.
	IsOC_PropertyLookupContext()
}

type OC_PropertyLookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PropertyLookupContext() *OC_PropertyLookupContext {
	var p = new(OC_PropertyLookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_PropertyLookup
	return p
}

func (*OC_PropertyLookupContext) IsOC_PropertyLookupContext() {}

func NewOC_PropertyLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PropertyLookupContext {
	var p = new(OC_PropertyLookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_PropertyLookup

	return p
}

func (s *OC_PropertyLookupContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PropertyLookupContext) OC_PropertyKeyName() IOC_PropertyKeyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PropertyKeyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyKeyNameContext)
}

func (s *OC_PropertyLookupContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_PropertyLookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PropertyLookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PropertyLookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_PropertyLookup(s)
	}
}

func (s *OC_PropertyLookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_PropertyLookup(s)
	}
}




func (p *CypherParser) OC_PropertyLookup() (localctx IOC_PropertyLookupContext) {
	localctx = NewOC_PropertyLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CypherParserRULE_oC_PropertyLookup)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1140)
		p.Match(CypherParserT__22)
	}
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1141)
			p.Match(CypherParserSP)
		}

	}

	{
		p.SetState(1144)
		p.OC_PropertyKeyName()
	}




	return localctx
}


// IOC_AtomContext is an interface to support dynamic dispatch.
type IOC_AtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_AtomContext differentiates from other interfaces.
	IsOC_AtomContext()
}

type OC_AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_AtomContext() *OC_AtomContext {
	var p = new(OC_AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Atom
	return p
}

func (*OC_AtomContext) IsOC_AtomContext() {}

func NewOC_AtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_AtomContext {
	var p = new(OC_AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Atom

	return p
}

func (s *OC_AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_AtomContext) OC_Literal() IOC_LiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_LiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_LiteralContext)
}

func (s *OC_AtomContext) OC_Parameter() IOC_ParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ParameterContext)
}

func (s *OC_AtomContext) OC_CaseExpression() IOC_CaseExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_CaseExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_CaseExpressionContext)
}

func (s *OC_AtomContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *OC_AtomContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_AtomContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_AtomContext) OC_ListComprehension() IOC_ListComprehensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ListComprehensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ListComprehensionContext)
}

func (s *OC_AtomContext) OC_PatternComprehension() IOC_PatternComprehensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternComprehensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternComprehensionContext)
}

func (s *OC_AtomContext) OC_Quantifier() IOC_QuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_QuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_QuantifierContext)
}

func (s *OC_AtomContext) OC_PatternPredicate() IOC_PatternPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternPredicateContext)
}

func (s *OC_AtomContext) OC_ParenthesizedExpression() IOC_ParenthesizedExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ParenthesizedExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ParenthesizedExpressionContext)
}

func (s *OC_AtomContext) OC_FunctionInvocation() IOC_FunctionInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_FunctionInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_FunctionInvocationContext)
}

func (s *OC_AtomContext) OC_ExistentialSubquery() IOC_ExistentialSubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExistentialSubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExistentialSubqueryContext)
}

func (s *OC_AtomContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Atom(s)
	}
}

func (s *OC_AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Atom(s)
	}
}




func (p *CypherParser) OC_Atom() (localctx IOC_AtomContext) {
	localctx = NewOC_AtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CypherParserRULE_oC_Atom)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1170)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1146)
			p.OC_Literal()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1147)
			p.OC_Parameter()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1148)
			p.OC_CaseExpression()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1149)
			p.Match(CypherParserCOUNT)
		}
		p.SetState(1151)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1150)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1153)
			p.Match(CypherParserT__5)
		}
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1154)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1157)
			p.Match(CypherParserT__4)
		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1158)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1161)
			p.Match(CypherParserT__6)
		}



	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1162)
			p.OC_ListComprehension()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1163)
			p.OC_PatternComprehension()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1164)
			p.OC_Quantifier()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1165)
			p.OC_PatternPredicate()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1166)
			p.OC_ParenthesizedExpression()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1167)
			p.OC_FunctionInvocation()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1168)
			p.OC_ExistentialSubquery()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1169)
			p.OC_Variable()
		}

	}


	return localctx
}


// IOC_CaseExpressionContext is an interface to support dynamic dispatch.
type IOC_CaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_CaseExpressionContext differentiates from other interfaces.
	IsOC_CaseExpressionContext()
}

type OC_CaseExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_CaseExpressionContext() *OC_CaseExpressionContext {
	var p = new(OC_CaseExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_CaseExpression
	return p
}

func (*OC_CaseExpressionContext) IsOC_CaseExpressionContext() {}

func NewOC_CaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_CaseExpressionContext {
	var p = new(OC_CaseExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_CaseExpression

	return p
}

func (s *OC_CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_CaseExpressionContext) END() antlr.TerminalNode {
	return s.GetToken(CypherParserEND, 0)
}

func (s *OC_CaseExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CypherParserELSE, 0)
}

func (s *OC_CaseExpressionContext) AllOC_Expression() []IOC_ExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem())
	var tst = make([]IOC_ExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ExpressionContext)
		}
	}

	return tst
}

func (s *OC_CaseExpressionContext) OC_Expression(i int) IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_CaseExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_CaseExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_CaseExpressionContext) CASE() antlr.TerminalNode {
	return s.GetToken(CypherParserCASE, 0)
}

func (s *OC_CaseExpressionContext) AllOC_CaseAlternative() []IOC_CaseAlternativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_CaseAlternativeContext)(nil)).Elem())
	var tst = make([]IOC_CaseAlternativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_CaseAlternativeContext)
		}
	}

	return tst
}

func (s *OC_CaseExpressionContext) OC_CaseAlternative(i int) IOC_CaseAlternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_CaseAlternativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_CaseAlternativeContext)
}

func (s *OC_CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_CaseExpression(s)
	}
}

func (s *OC_CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_CaseExpression(s)
	}
}




func (p *CypherParser) OC_CaseExpression() (localctx IOC_CaseExpressionContext) {
	localctx = NewOC_CaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CypherParserRULE_oC_CaseExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1194)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1172)
			p.Match(CypherParserCASE)
		}
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					p.SetState(1174)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)


					if _la == CypherParserSP {
						{
							p.SetState(1173)
							p.Match(CypherParserSP)
						}

					}
					{
						p.SetState(1176)
						p.OC_CaseAlternative()
					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1179)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())
		}



	case 2:
		{
			p.SetState(1181)
			p.Match(CypherParserCASE)
		}
		p.SetState(1183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1182)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1185)
			p.OC_Expression()
		}
		p.SetState(1190)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					p.SetState(1187)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)


					if _la == CypherParserSP {
						{
							p.SetState(1186)
							p.Match(CypherParserSP)
						}

					}
					{
						p.SetState(1189)
						p.OC_CaseAlternative()
					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1192)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())
		}


	}
	p.SetState(1204)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
		p.SetState(1197)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1196)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1199)
			p.Match(CypherParserELSE)
		}
		p.SetState(1201)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1200)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1203)
			p.OC_Expression()
		}


	}
	p.SetState(1207)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1206)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1209)
		p.Match(CypherParserEND)
	}



	return localctx
}


// IOC_CaseAlternativeContext is an interface to support dynamic dispatch.
type IOC_CaseAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_CaseAlternativeContext differentiates from other interfaces.
	IsOC_CaseAlternativeContext()
}

type OC_CaseAlternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_CaseAlternativeContext() *OC_CaseAlternativeContext {
	var p = new(OC_CaseAlternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_CaseAlternative
	return p
}

func (*OC_CaseAlternativeContext) IsOC_CaseAlternativeContext() {}

func NewOC_CaseAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_CaseAlternativeContext {
	var p = new(OC_CaseAlternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_CaseAlternative

	return p
}

func (s *OC_CaseAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_CaseAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(CypherParserWHEN, 0)
}

func (s *OC_CaseAlternativeContext) AllOC_Expression() []IOC_ExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem())
	var tst = make([]IOC_ExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ExpressionContext)
		}
	}

	return tst
}

func (s *OC_CaseAlternativeContext) OC_Expression(i int) IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_CaseAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(CypherParserTHEN, 0)
}

func (s *OC_CaseAlternativeContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_CaseAlternativeContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_CaseAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_CaseAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_CaseAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_CaseAlternative(s)
	}
}

func (s *OC_CaseAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_CaseAlternative(s)
	}
}




func (p *CypherParser) OC_CaseAlternative() (localctx IOC_CaseAlternativeContext) {
	localctx = NewOC_CaseAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CypherParserRULE_oC_CaseAlternative)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1211)
		p.Match(CypherParserWHEN)
	}
	p.SetState(1213)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1212)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1215)
		p.OC_Expression()
	}
	p.SetState(1217)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1216)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1219)
		p.Match(CypherParserTHEN)
	}
	p.SetState(1221)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1220)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1223)
		p.OC_Expression()
	}



	return localctx
}


// IOC_ListComprehensionContext is an interface to support dynamic dispatch.
type IOC_ListComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ListComprehensionContext differentiates from other interfaces.
	IsOC_ListComprehensionContext()
}

type OC_ListComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ListComprehensionContext() *OC_ListComprehensionContext {
	var p = new(OC_ListComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ListComprehension
	return p
}

func (*OC_ListComprehensionContext) IsOC_ListComprehensionContext() {}

func NewOC_ListComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ListComprehensionContext {
	var p = new(OC_ListComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ListComprehension

	return p
}

func (s *OC_ListComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ListComprehensionContext) OC_FilterExpression() IOC_FilterExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_FilterExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_FilterExpressionContext)
}

func (s *OC_ListComprehensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_ListComprehensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_ListComprehensionContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ListComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ListComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ListComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ListComprehension(s)
	}
}

func (s *OC_ListComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ListComprehension(s)
	}
}




func (p *CypherParser) OC_ListComprehension() (localctx IOC_ListComprehensionContext) {
	localctx = NewOC_ListComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CypherParserRULE_oC_ListComprehension)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1225)
		p.Match(CypherParserT__7)
	}
	p.SetState(1227)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1226)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1229)
		p.OC_FilterExpression()
	}
	p.SetState(1238)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 220, p.GetParserRuleContext()) == 1 {
		p.SetState(1231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1230)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1233)
			p.Match(CypherParserT__10)
		}
		p.SetState(1235)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1234)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1237)
			p.OC_Expression()
		}


	}
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1240)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1243)
		p.Match(CypherParserT__8)
	}



	return localctx
}


// IOC_PatternComprehensionContext is an interface to support dynamic dispatch.
type IOC_PatternComprehensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternComprehensionContext differentiates from other interfaces.
	IsOC_PatternComprehensionContext()
}

type OC_PatternComprehensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternComprehensionContext() *OC_PatternComprehensionContext {
	var p = new(OC_PatternComprehensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_PatternComprehension
	return p
}

func (*OC_PatternComprehensionContext) IsOC_PatternComprehensionContext() {}

func NewOC_PatternComprehensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternComprehensionContext {
	var p = new(OC_PatternComprehensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_PatternComprehension

	return p
}

func (s *OC_PatternComprehensionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternComprehensionContext) OC_RelationshipsPattern() IOC_RelationshipsPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RelationshipsPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_RelationshipsPatternContext)
}

func (s *OC_PatternComprehensionContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_PatternComprehensionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_PatternComprehensionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_PatternComprehensionContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_PatternComprehensionContext) OC_Where() IOC_WhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_WhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_PatternComprehensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternComprehensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PatternComprehensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_PatternComprehension(s)
	}
}

func (s *OC_PatternComprehensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_PatternComprehension(s)
	}
}




func (p *CypherParser) OC_PatternComprehension() (localctx IOC_PatternComprehensionContext) {
	localctx = NewOC_PatternComprehensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CypherParserRULE_oC_PatternComprehension)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1245)
		p.Match(CypherParserT__7)
	}
	p.SetState(1247)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1246)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1257)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 83)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 83))) & ((1 << (CypherParserCOUNT - 83)) | (1 << (CypherParserANY - 83)) | (1 << (CypherParserNONE - 83)) | (1 << (CypherParserSINGLE - 83)) | (1 << (CypherParserHexLetter - 83)))) != 0) || ((((_la - 119)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 119))) & ((1 << (CypherParserFILTER - 119)) | (1 << (CypherParserEXTRACT - 119)) | (1 << (CypherParserUnescapedSymbolicName - 119)) | (1 << (CypherParserEscapedSymbolicName - 119)))) != 0) {
		{
			p.SetState(1249)
			p.OC_Variable()
		}
		p.SetState(1251)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1250)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1253)
			p.Match(CypherParserT__2)
		}
		p.SetState(1255)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1254)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(1259)
		p.OC_RelationshipsPattern()
	}
	p.SetState(1261)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1260)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1267)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserWHERE {
		{
			p.SetState(1263)
			p.OC_Where()
		}
		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1264)
				p.Match(CypherParserSP)
			}

		}

	}
	{
		p.SetState(1269)
		p.Match(CypherParserT__10)
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1270)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1273)
		p.OC_Expression()
	}
	p.SetState(1275)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1274)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1277)
		p.Match(CypherParserT__8)
	}



	return localctx
}


// IOC_QuantifierContext is an interface to support dynamic dispatch.
type IOC_QuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_QuantifierContext differentiates from other interfaces.
	IsOC_QuantifierContext()
}

type OC_QuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_QuantifierContext() *OC_QuantifierContext {
	var p = new(OC_QuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Quantifier
	return p
}

func (*OC_QuantifierContext) IsOC_QuantifierContext() {}

func NewOC_QuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_QuantifierContext {
	var p = new(OC_QuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Quantifier

	return p
}

func (s *OC_QuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_QuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *OC_QuantifierContext) OC_FilterExpression() IOC_FilterExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_FilterExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_FilterExpressionContext)
}

func (s *OC_QuantifierContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_QuantifierContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_QuantifierContext) ANY() antlr.TerminalNode {
	return s.GetToken(CypherParserANY, 0)
}

func (s *OC_QuantifierContext) NONE() antlr.TerminalNode {
	return s.GetToken(CypherParserNONE, 0)
}

func (s *OC_QuantifierContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(CypherParserSINGLE, 0)
}

func (s *OC_QuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_QuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_QuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Quantifier(s)
	}
}

func (s *OC_QuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Quantifier(s)
	}
}




func (p *CypherParser) OC_Quantifier() (localctx IOC_QuantifierContext) {
	localctx = NewOC_QuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CypherParserRULE_oC_Quantifier)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1335)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1279)
			p.Match(CypherParserALL)
		}
		p.SetState(1281)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1280)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1283)
			p.Match(CypherParserT__5)
		}
		p.SetState(1285)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1284)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1287)
			p.OC_FilterExpression()
		}
		p.SetState(1289)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1288)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1291)
			p.Match(CypherParserT__6)
		}



	case CypherParserANY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1293)
			p.Match(CypherParserANY)
		}
		p.SetState(1295)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1294)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1297)
			p.Match(CypherParserT__5)
		}
		p.SetState(1299)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1298)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1301)
			p.OC_FilterExpression()
		}
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1302)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1305)
			p.Match(CypherParserT__6)
		}



	case CypherParserNONE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1307)
			p.Match(CypherParserNONE)
		}
		p.SetState(1309)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1308)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1311)
			p.Match(CypherParserT__5)
		}
		p.SetState(1313)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1312)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1315)
			p.OC_FilterExpression()
		}
		p.SetState(1317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1316)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1319)
			p.Match(CypherParserT__6)
		}



	case CypherParserSINGLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1321)
			p.Match(CypherParserSINGLE)
		}
		p.SetState(1323)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1322)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1325)
			p.Match(CypherParserT__5)
		}
		p.SetState(1327)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1326)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1329)
			p.OC_FilterExpression()
		}
		p.SetState(1331)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1330)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1333)
			p.Match(CypherParserT__6)
		}




	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_FilterExpressionContext is an interface to support dynamic dispatch.
type IOC_FilterExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_FilterExpressionContext differentiates from other interfaces.
	IsOC_FilterExpressionContext()
}

type OC_FilterExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_FilterExpressionContext() *OC_FilterExpressionContext {
	var p = new(OC_FilterExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_FilterExpression
	return p
}

func (*OC_FilterExpressionContext) IsOC_FilterExpressionContext() {}

func NewOC_FilterExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_FilterExpressionContext {
	var p = new(OC_FilterExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_FilterExpression

	return p
}

func (s *OC_FilterExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_FilterExpressionContext) OC_IdInColl() IOC_IdInCollContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_IdInCollContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_IdInCollContext)
}

func (s *OC_FilterExpressionContext) OC_Where() IOC_WhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_WhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_FilterExpressionContext) SP() antlr.TerminalNode {
	return s.GetToken(CypherParserSP, 0)
}

func (s *OC_FilterExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_FilterExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_FilterExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_FilterExpression(s)
	}
}

func (s *OC_FilterExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_FilterExpression(s)
	}
}




func (p *CypherParser) OC_FilterExpression() (localctx IOC_FilterExpressionContext) {
	localctx = NewOC_FilterExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CypherParserRULE_oC_FilterExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1337)
		p.OC_IdInColl()
	}
	p.SetState(1342)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 245, p.GetParserRuleContext()) == 1 {
		p.SetState(1339)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1338)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1341)
			p.OC_Where()
		}


	}



	return localctx
}


// IOC_PatternPredicateContext is an interface to support dynamic dispatch.
type IOC_PatternPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PatternPredicateContext differentiates from other interfaces.
	IsOC_PatternPredicateContext()
}

type OC_PatternPredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PatternPredicateContext() *OC_PatternPredicateContext {
	var p = new(OC_PatternPredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_PatternPredicate
	return p
}

func (*OC_PatternPredicateContext) IsOC_PatternPredicateContext() {}

func NewOC_PatternPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PatternPredicateContext {
	var p = new(OC_PatternPredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_PatternPredicate

	return p
}

func (s *OC_PatternPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PatternPredicateContext) OC_RelationshipsPattern() IOC_RelationshipsPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RelationshipsPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_RelationshipsPatternContext)
}

func (s *OC_PatternPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PatternPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PatternPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_PatternPredicate(s)
	}
}

func (s *OC_PatternPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_PatternPredicate(s)
	}
}




func (p *CypherParser) OC_PatternPredicate() (localctx IOC_PatternPredicateContext) {
	localctx = NewOC_PatternPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CypherParserRULE_oC_PatternPredicate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1344)
		p.OC_RelationshipsPattern()
	}



	return localctx
}


// IOC_ParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IOC_ParenthesizedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ParenthesizedExpressionContext differentiates from other interfaces.
	IsOC_ParenthesizedExpressionContext()
}

type OC_ParenthesizedExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ParenthesizedExpressionContext() *OC_ParenthesizedExpressionContext {
	var p = new(OC_ParenthesizedExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ParenthesizedExpression
	return p
}

func (*OC_ParenthesizedExpressionContext) IsOC_ParenthesizedExpressionContext() {}

func NewOC_ParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ParenthesizedExpressionContext {
	var p = new(OC_ParenthesizedExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ParenthesizedExpression

	return p
}

func (s *OC_ParenthesizedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ParenthesizedExpressionContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ParenthesizedExpressionContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_ParenthesizedExpressionContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ParenthesizedExpression(s)
	}
}

func (s *OC_ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ParenthesizedExpression(s)
	}
}




func (p *CypherParser) OC_ParenthesizedExpression() (localctx IOC_ParenthesizedExpressionContext) {
	localctx = NewOC_ParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CypherParserRULE_oC_ParenthesizedExpression)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1346)
		p.Match(CypherParserT__5)
	}
	p.SetState(1348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1347)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1350)
		p.OC_Expression()
	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1351)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1354)
		p.Match(CypherParserT__6)
	}



	return localctx
}


// IOC_IdInCollContext is an interface to support dynamic dispatch.
type IOC_IdInCollContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_IdInCollContext differentiates from other interfaces.
	IsOC_IdInCollContext()
}

type OC_IdInCollContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_IdInCollContext() *OC_IdInCollContext {
	var p = new(OC_IdInCollContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_IdInColl
	return p
}

func (*OC_IdInCollContext) IsOC_IdInCollContext() {}

func NewOC_IdInCollContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_IdInCollContext {
	var p = new(OC_IdInCollContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_IdInColl

	return p
}

func (s *OC_IdInCollContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_IdInCollContext) OC_Variable() IOC_VariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_VariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_VariableContext)
}

func (s *OC_IdInCollContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_IdInCollContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_IdInCollContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *OC_IdInCollContext) OC_Expression() IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_IdInCollContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_IdInCollContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_IdInCollContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_IdInColl(s)
	}
}

func (s *OC_IdInCollContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_IdInColl(s)
	}
}




func (p *CypherParser) OC_IdInColl() (localctx IOC_IdInCollContext) {
	localctx = NewOC_IdInCollContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CypherParserRULE_oC_IdInColl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.OC_Variable()
	}
	{
		p.SetState(1357)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1358)
		p.Match(CypherParserIN)
	}
	{
		p.SetState(1359)
		p.Match(CypherParserSP)
	}
	{
		p.SetState(1360)
		p.OC_Expression()
	}



	return localctx
}


// IOC_FunctionInvocationContext is an interface to support dynamic dispatch.
type IOC_FunctionInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_FunctionInvocationContext differentiates from other interfaces.
	IsOC_FunctionInvocationContext()
}

type OC_FunctionInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_FunctionInvocationContext() *OC_FunctionInvocationContext {
	var p = new(OC_FunctionInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_FunctionInvocation
	return p
}

func (*OC_FunctionInvocationContext) IsOC_FunctionInvocationContext() {}

func NewOC_FunctionInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_FunctionInvocationContext {
	var p = new(OC_FunctionInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_FunctionInvocation

	return p
}

func (s *OC_FunctionInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_FunctionInvocationContext) OC_FunctionName() IOC_FunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_FunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_FunctionNameContext)
}

func (s *OC_FunctionInvocationContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_FunctionInvocationContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_FunctionInvocationContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *OC_FunctionInvocationContext) AllOC_Expression() []IOC_ExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem())
	var tst = make([]IOC_ExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ExpressionContext)
		}
	}

	return tst
}

func (s *OC_FunctionInvocationContext) OC_Expression(i int) IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_FunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_FunctionInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_FunctionInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_FunctionInvocation(s)
	}
}

func (s *OC_FunctionInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_FunctionInvocation(s)
	}
}




func (p *CypherParser) OC_FunctionInvocation() (localctx IOC_FunctionInvocationContext) {
	localctx = NewOC_FunctionInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CypherParserRULE_oC_FunctionInvocation)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1362)
		p.OC_FunctionName()
	}
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1363)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1366)
		p.Match(CypherParserT__5)
	}
	p.SetState(1368)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1367)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1374)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserDISTINCT {
		{
			p.SetState(1370)
			p.Match(CypherParserDISTINCT)
		}
		p.SetState(1372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1371)
				p.Match(CypherParserSP)
			}

		}

	}
	p.SetState(1393)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << CypherParserT__5) | (1 << CypherParserT__7) | (1 << CypherParserT__17) | (1 << CypherParserT__18) | (1 << CypherParserT__23) | (1 << CypherParserT__25))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || ((((_la - 82)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 82))) & ((1 << (CypherParserNULL - 82)) | (1 << (CypherParserCOUNT - 82)) | (1 << (CypherParserCASE - 82)) | (1 << (CypherParserANY - 82)) | (1 << (CypherParserNONE - 82)) | (1 << (CypherParserSINGLE - 82)) | (1 << (CypherParserEXISTS - 82)) | (1 << (CypherParserTRUE - 82)) | (1 << (CypherParserFALSE - 82)) | (1 << (CypherParserHexInteger - 82)) | (1 << (CypherParserDecimalInteger - 82)) | (1 << (CypherParserOctalInteger - 82)) | (1 << (CypherParserHexLetter - 82)) | (1 << (CypherParserExponentDecimalReal - 82)) | (1 << (CypherParserRegularDecimalReal - 82)) | (1 << (CypherParserStringLiteral - 82)))) != 0) || ((((_la - 119)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 119))) & ((1 << (CypherParserFILTER - 119)) | (1 << (CypherParserEXTRACT - 119)) | (1 << (CypherParserUnescapedSymbolicName - 119)) | (1 << (CypherParserEscapedSymbolicName - 119)))) != 0) {
		{
			p.SetState(1376)
			p.OC_Expression()
		}
		p.SetState(1378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1377)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1390)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == CypherParserT__1 {
			{
				p.SetState(1380)
				p.Match(CypherParserT__1)
			}
			p.SetState(1382)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1381)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1384)
				p.OC_Expression()
			}
			p.SetState(1386)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1385)
					p.Match(CypherParserSP)
				}

			}


			p.SetState(1392)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1395)
		p.Match(CypherParserT__6)
	}



	return localctx
}


// IOC_FunctionNameContext is an interface to support dynamic dispatch.
type IOC_FunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_FunctionNameContext differentiates from other interfaces.
	IsOC_FunctionNameContext()
}

type OC_FunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_FunctionNameContext() *OC_FunctionNameContext {
	var p = new(OC_FunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_FunctionName
	return p
}

func (*OC_FunctionNameContext) IsOC_FunctionNameContext() {}

func NewOC_FunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_FunctionNameContext {
	var p = new(OC_FunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_FunctionName

	return p
}

func (s *OC_FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_FunctionNameContext) OC_Namespace() IOC_NamespaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NamespaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NamespaceContext)
}

func (s *OC_FunctionNameContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_FunctionName(s)
	}
}

func (s *OC_FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_FunctionName(s)
	}
}




func (p *CypherParser) OC_FunctionName() (localctx IOC_FunctionNameContext) {
	localctx = NewOC_FunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CypherParserRULE_oC_FunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1397)
		p.OC_Namespace()
	}
	{
		p.SetState(1398)
		p.OC_SymbolicName()
	}



	return localctx
}


// IOC_ExistentialSubqueryContext is an interface to support dynamic dispatch.
type IOC_ExistentialSubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ExistentialSubqueryContext differentiates from other interfaces.
	IsOC_ExistentialSubqueryContext()
}

type OC_ExistentialSubqueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ExistentialSubqueryContext() *OC_ExistentialSubqueryContext {
	var p = new(OC_ExistentialSubqueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ExistentialSubquery
	return p
}

func (*OC_ExistentialSubqueryContext) IsOC_ExistentialSubqueryContext() {}

func NewOC_ExistentialSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ExistentialSubqueryContext {
	var p = new(OC_ExistentialSubqueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ExistentialSubquery

	return p
}

func (s *OC_ExistentialSubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ExistentialSubqueryContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *OC_ExistentialSubqueryContext) OC_RegularQuery() IOC_RegularQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_RegularQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_RegularQueryContext)
}

func (s *OC_ExistentialSubqueryContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_ExistentialSubqueryContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_ExistentialSubqueryContext) OC_Pattern() IOC_PatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_PatternContext)
}

func (s *OC_ExistentialSubqueryContext) OC_Where() IOC_WhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_WhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_WhereContext)
}

func (s *OC_ExistentialSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ExistentialSubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ExistentialSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ExistentialSubquery(s)
	}
}

func (s *OC_ExistentialSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ExistentialSubquery(s)
	}
}




func (p *CypherParser) OC_ExistentialSubquery() (localctx IOC_ExistentialSubqueryContext) {
	localctx = NewOC_ExistentialSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CypherParserRULE_oC_ExistentialSubquery)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1400)
		p.Match(CypherParserEXISTS)
	}
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1401)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1404)
		p.Match(CypherParserT__23)
	}
	p.SetState(1406)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1405)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1416)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserMERGE, CypherParserCREATE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserCALL, CypherParserWITH, CypherParserRETURN:
		{
			p.SetState(1408)
			p.OC_RegularQuery()
		}


	case CypherParserT__5, CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		{
			p.SetState(1409)
			p.OC_Pattern()
		}
		p.SetState(1414)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 260, p.GetParserRuleContext()) == 1 {
			p.SetState(1411)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1410)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1413)
				p.OC_Where()
			}


		}




	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1419)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1418)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1421)
		p.Match(CypherParserT__24)
	}



	return localctx
}


// IOC_ExplicitProcedureInvocationContext is an interface to support dynamic dispatch.
type IOC_ExplicitProcedureInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ExplicitProcedureInvocationContext differentiates from other interfaces.
	IsOC_ExplicitProcedureInvocationContext()
}

type OC_ExplicitProcedureInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ExplicitProcedureInvocationContext() *OC_ExplicitProcedureInvocationContext {
	var p = new(OC_ExplicitProcedureInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ExplicitProcedureInvocation
	return p
}

func (*OC_ExplicitProcedureInvocationContext) IsOC_ExplicitProcedureInvocationContext() {}

func NewOC_ExplicitProcedureInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ExplicitProcedureInvocationContext {
	var p = new(OC_ExplicitProcedureInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ExplicitProcedureInvocation

	return p
}

func (s *OC_ExplicitProcedureInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ExplicitProcedureInvocationContext) OC_ProcedureName() IOC_ProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ProcedureNameContext)
}

func (s *OC_ExplicitProcedureInvocationContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_ExplicitProcedureInvocationContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_ExplicitProcedureInvocationContext) AllOC_Expression() []IOC_ExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem())
	var tst = make([]IOC_ExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ExpressionContext)
		}
	}

	return tst
}

func (s *OC_ExplicitProcedureInvocationContext) OC_Expression(i int) IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ExplicitProcedureInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ExplicitProcedureInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ExplicitProcedureInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ExplicitProcedureInvocation(s)
	}
}

func (s *OC_ExplicitProcedureInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ExplicitProcedureInvocation(s)
	}
}




func (p *CypherParser) OC_ExplicitProcedureInvocation() (localctx IOC_ExplicitProcedureInvocationContext) {
	localctx = NewOC_ExplicitProcedureInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, CypherParserRULE_oC_ExplicitProcedureInvocation)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1423)
		p.OC_ProcedureName()
	}
	p.SetState(1425)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1424)
			p.Match(CypherParserSP)
		}

	}
	{
		p.SetState(1427)
		p.Match(CypherParserT__5)
	}
	p.SetState(1429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1428)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << CypherParserT__5) | (1 << CypherParserT__7) | (1 << CypherParserT__17) | (1 << CypherParserT__18) | (1 << CypherParserT__23) | (1 << CypherParserT__25))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || ((((_la - 82)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 82))) & ((1 << (CypherParserNULL - 82)) | (1 << (CypherParserCOUNT - 82)) | (1 << (CypherParserCASE - 82)) | (1 << (CypherParserANY - 82)) | (1 << (CypherParserNONE - 82)) | (1 << (CypherParserSINGLE - 82)) | (1 << (CypherParserEXISTS - 82)) | (1 << (CypherParserTRUE - 82)) | (1 << (CypherParserFALSE - 82)) | (1 << (CypherParserHexInteger - 82)) | (1 << (CypherParserDecimalInteger - 82)) | (1 << (CypherParserOctalInteger - 82)) | (1 << (CypherParserHexLetter - 82)) | (1 << (CypherParserExponentDecimalReal - 82)) | (1 << (CypherParserRegularDecimalReal - 82)) | (1 << (CypherParserStringLiteral - 82)))) != 0) || ((((_la - 119)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 119))) & ((1 << (CypherParserFILTER - 119)) | (1 << (CypherParserEXTRACT - 119)) | (1 << (CypherParserUnescapedSymbolicName - 119)) | (1 << (CypherParserEscapedSymbolicName - 119)))) != 0) {
		{
			p.SetState(1431)
			p.OC_Expression()
		}
		p.SetState(1433)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1432)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1445)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == CypherParserT__1 {
			{
				p.SetState(1435)
				p.Match(CypherParserT__1)
			}
			p.SetState(1437)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1436)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1439)
				p.OC_Expression()
			}
			p.SetState(1441)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1440)
					p.Match(CypherParserSP)
				}

			}


			p.SetState(1447)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1450)
		p.Match(CypherParserT__6)
	}



	return localctx
}


// IOC_ImplicitProcedureInvocationContext is an interface to support dynamic dispatch.
type IOC_ImplicitProcedureInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ImplicitProcedureInvocationContext differentiates from other interfaces.
	IsOC_ImplicitProcedureInvocationContext()
}

type OC_ImplicitProcedureInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ImplicitProcedureInvocationContext() *OC_ImplicitProcedureInvocationContext {
	var p = new(OC_ImplicitProcedureInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ImplicitProcedureInvocation
	return p
}

func (*OC_ImplicitProcedureInvocationContext) IsOC_ImplicitProcedureInvocationContext() {}

func NewOC_ImplicitProcedureInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ImplicitProcedureInvocationContext {
	var p = new(OC_ImplicitProcedureInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ImplicitProcedureInvocation

	return p
}

func (s *OC_ImplicitProcedureInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ImplicitProcedureInvocationContext) OC_ProcedureName() IOC_ProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ProcedureNameContext)
}

func (s *OC_ImplicitProcedureInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ImplicitProcedureInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ImplicitProcedureInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ImplicitProcedureInvocation(s)
	}
}

func (s *OC_ImplicitProcedureInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ImplicitProcedureInvocation(s)
	}
}




func (p *CypherParser) OC_ImplicitProcedureInvocation() (localctx IOC_ImplicitProcedureInvocationContext) {
	localctx = NewOC_ImplicitProcedureInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, CypherParserRULE_oC_ImplicitProcedureInvocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1452)
		p.OC_ProcedureName()
	}



	return localctx
}


// IOC_ProcedureResultFieldContext is an interface to support dynamic dispatch.
type IOC_ProcedureResultFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ProcedureResultFieldContext differentiates from other interfaces.
	IsOC_ProcedureResultFieldContext()
}

type OC_ProcedureResultFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ProcedureResultFieldContext() *OC_ProcedureResultFieldContext {
	var p = new(OC_ProcedureResultFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ProcedureResultField
	return p
}

func (*OC_ProcedureResultFieldContext) IsOC_ProcedureResultFieldContext() {}

func NewOC_ProcedureResultFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ProcedureResultFieldContext {
	var p = new(OC_ProcedureResultFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ProcedureResultField

	return p
}

func (s *OC_ProcedureResultFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ProcedureResultFieldContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_ProcedureResultFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ProcedureResultFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ProcedureResultFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ProcedureResultField(s)
	}
}

func (s *OC_ProcedureResultFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ProcedureResultField(s)
	}
}




func (p *CypherParser) OC_ProcedureResultField() (localctx IOC_ProcedureResultFieldContext) {
	localctx = NewOC_ProcedureResultFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, CypherParserRULE_oC_ProcedureResultField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1454)
		p.OC_SymbolicName()
	}



	return localctx
}


// IOC_ProcedureNameContext is an interface to support dynamic dispatch.
type IOC_ProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ProcedureNameContext differentiates from other interfaces.
	IsOC_ProcedureNameContext()
}

type OC_ProcedureNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ProcedureNameContext() *OC_ProcedureNameContext {
	var p = new(OC_ProcedureNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ProcedureName
	return p
}

func (*OC_ProcedureNameContext) IsOC_ProcedureNameContext() {}

func NewOC_ProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ProcedureNameContext {
	var p = new(OC_ProcedureNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ProcedureName

	return p
}

func (s *OC_ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ProcedureNameContext) OC_Namespace() IOC_NamespaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NamespaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NamespaceContext)
}

func (s *OC_ProcedureNameContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ProcedureName(s)
	}
}

func (s *OC_ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ProcedureName(s)
	}
}




func (p *CypherParser) OC_ProcedureName() (localctx IOC_ProcedureNameContext) {
	localctx = NewOC_ProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, CypherParserRULE_oC_ProcedureName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1456)
		p.OC_Namespace()
	}
	{
		p.SetState(1457)
		p.OC_SymbolicName()
	}



	return localctx
}


// IOC_NamespaceContext is an interface to support dynamic dispatch.
type IOC_NamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NamespaceContext differentiates from other interfaces.
	IsOC_NamespaceContext()
}

type OC_NamespaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NamespaceContext() *OC_NamespaceContext {
	var p = new(OC_NamespaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Namespace
	return p
}

func (*OC_NamespaceContext) IsOC_NamespaceContext() {}

func NewOC_NamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NamespaceContext {
	var p = new(OC_NamespaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Namespace

	return p
}

func (s *OC_NamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NamespaceContext) AllOC_SymbolicName() []IOC_SymbolicNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_SymbolicNameContext)(nil)).Elem())
	var tst = make([]IOC_SymbolicNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_SymbolicNameContext)
		}
	}

	return tst
}

func (s *OC_NamespaceContext) OC_SymbolicName(i int) IOC_SymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SymbolicNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_NamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_NamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Namespace(s)
	}
}

func (s *OC_NamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Namespace(s)
	}
}




func (p *CypherParser) OC_Namespace() (localctx IOC_NamespaceContext) {
	localctx = NewOC_NamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, CypherParserRULE_oC_Namespace)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1464)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 270, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1459)
				p.OC_SymbolicName()
			}
			{
				p.SetState(1460)
				p.Match(CypherParserT__22)
			}


		}
		p.SetState(1466)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 270, p.GetParserRuleContext())
	}



	return localctx
}


// IOC_VariableContext is an interface to support dynamic dispatch.
type IOC_VariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_VariableContext differentiates from other interfaces.
	IsOC_VariableContext()
}

type OC_VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_VariableContext() *OC_VariableContext {
	var p = new(OC_VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Variable
	return p
}

func (*OC_VariableContext) IsOC_VariableContext() {}

func NewOC_VariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_VariableContext {
	var p = new(OC_VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Variable

	return p
}

func (s *OC_VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_VariableContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Variable(s)
	}
}

func (s *OC_VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Variable(s)
	}
}




func (p *CypherParser) OC_Variable() (localctx IOC_VariableContext) {
	localctx = NewOC_VariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, CypherParserRULE_oC_Variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1467)
		p.OC_SymbolicName()
	}



	return localctx
}


// IOC_LiteralContext is an interface to support dynamic dispatch.
type IOC_LiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_LiteralContext differentiates from other interfaces.
	IsOC_LiteralContext()
}

type OC_LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_LiteralContext() *OC_LiteralContext {
	var p = new(OC_LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Literal
	return p
}

func (*OC_LiteralContext) IsOC_LiteralContext() {}

func NewOC_LiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_LiteralContext {
	var p = new(OC_LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Literal

	return p
}

func (s *OC_LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_LiteralContext) OC_BooleanLiteral() IOC_BooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_BooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_BooleanLiteralContext)
}

func (s *OC_LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *OC_LiteralContext) OC_NumberLiteral() IOC_NumberLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_NumberLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_NumberLiteralContext)
}

func (s *OC_LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CypherParserStringLiteral, 0)
}

func (s *OC_LiteralContext) OC_ListLiteral() IOC_ListLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ListLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ListLiteralContext)
}

func (s *OC_LiteralContext) OC_MapLiteral() IOC_MapLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_MapLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_MapLiteralContext)
}

func (s *OC_LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Literal(s)
	}
}

func (s *OC_LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Literal(s)
	}
}




func (p *CypherParser) OC_Literal() (localctx IOC_LiteralContext) {
	localctx = NewOC_LiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, CypherParserRULE_oC_Literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1475)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserTRUE, CypherParserFALSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1469)
			p.OC_BooleanLiteral()
		}


	case CypherParserNULL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1470)
			p.Match(CypherParserNULL)
		}


	case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger, CypherParserExponentDecimalReal, CypherParserRegularDecimalReal:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1471)
			p.OC_NumberLiteral()
		}


	case CypherParserStringLiteral:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1472)
			p.Match(CypherParserStringLiteral)
		}


	case CypherParserT__7:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1473)
			p.OC_ListLiteral()
		}


	case CypherParserT__23:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1474)
			p.OC_MapLiteral()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_BooleanLiteralContext is an interface to support dynamic dispatch.
type IOC_BooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_BooleanLiteralContext differentiates from other interfaces.
	IsOC_BooleanLiteralContext()
}

type OC_BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_BooleanLiteralContext() *OC_BooleanLiteralContext {
	var p = new(OC_BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_BooleanLiteral
	return p
}

func (*OC_BooleanLiteralContext) IsOC_BooleanLiteralContext() {}

func NewOC_BooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_BooleanLiteralContext {
	var p = new(OC_BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_BooleanLiteral

	return p
}

func (s *OC_BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRUE, 0)
}

func (s *OC_BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CypherParserFALSE, 0)
}

func (s *OC_BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_BooleanLiteral(s)
	}
}

func (s *OC_BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_BooleanLiteral(s)
	}
}




func (p *CypherParser) OC_BooleanLiteral() (localctx IOC_BooleanLiteralContext) {
	localctx = NewOC_BooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, CypherParserRULE_oC_BooleanLiteral)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1477)
	_la = p.GetTokenStream().LA(1)

	if !(_la == CypherParserTRUE || _la == CypherParserFALSE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IOC_NumberLiteralContext is an interface to support dynamic dispatch.
type IOC_NumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_NumberLiteralContext differentiates from other interfaces.
	IsOC_NumberLiteralContext()
}

type OC_NumberLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_NumberLiteralContext() *OC_NumberLiteralContext {
	var p = new(OC_NumberLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_NumberLiteral
	return p
}

func (*OC_NumberLiteralContext) IsOC_NumberLiteralContext() {}

func NewOC_NumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_NumberLiteralContext {
	var p = new(OC_NumberLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_NumberLiteral

	return p
}

func (s *OC_NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_NumberLiteralContext) OC_DoubleLiteral() IOC_DoubleLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_DoubleLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_DoubleLiteralContext)
}

func (s *OC_NumberLiteralContext) OC_IntegerLiteral() IOC_IntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_IntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_IntegerLiteralContext)
}

func (s *OC_NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_NumberLiteral(s)
	}
}

func (s *OC_NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_NumberLiteral(s)
	}
}




func (p *CypherParser) OC_NumberLiteral() (localctx IOC_NumberLiteralContext) {
	localctx = NewOC_NumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, CypherParserRULE_oC_NumberLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1481)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserExponentDecimalReal, CypherParserRegularDecimalReal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1479)
			p.OC_DoubleLiteral()
		}


	case CypherParserHexInteger, CypherParserDecimalInteger, CypherParserOctalInteger:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1480)
			p.OC_IntegerLiteral()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_IntegerLiteralContext is an interface to support dynamic dispatch.
type IOC_IntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_IntegerLiteralContext differentiates from other interfaces.
	IsOC_IntegerLiteralContext()
}

type OC_IntegerLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_IntegerLiteralContext() *OC_IntegerLiteralContext {
	var p = new(OC_IntegerLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_IntegerLiteral
	return p
}

func (*OC_IntegerLiteralContext) IsOC_IntegerLiteralContext() {}

func NewOC_IntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_IntegerLiteralContext {
	var p = new(OC_IntegerLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_IntegerLiteral

	return p
}

func (s *OC_IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_IntegerLiteralContext) HexInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserHexInteger, 0)
}

func (s *OC_IntegerLiteralContext) OctalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserOctalInteger, 0)
}

func (s *OC_IntegerLiteralContext) DecimalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserDecimalInteger, 0)
}

func (s *OC_IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_IntegerLiteral(s)
	}
}

func (s *OC_IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_IntegerLiteral(s)
	}
}




func (p *CypherParser) OC_IntegerLiteral() (localctx IOC_IntegerLiteralContext) {
	localctx = NewOC_IntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, CypherParserRULE_oC_IntegerLiteral)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1483)
	_la = p.GetTokenStream().LA(1)

	if !(((((_la - 95)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 95))) & ((1 << (CypherParserHexInteger - 95)) | (1 << (CypherParserDecimalInteger - 95)) | (1 << (CypherParserOctalInteger - 95)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IOC_DoubleLiteralContext is an interface to support dynamic dispatch.
type IOC_DoubleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_DoubleLiteralContext differentiates from other interfaces.
	IsOC_DoubleLiteralContext()
}

type OC_DoubleLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_DoubleLiteralContext() *OC_DoubleLiteralContext {
	var p = new(OC_DoubleLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_DoubleLiteral
	return p
}

func (*OC_DoubleLiteralContext) IsOC_DoubleLiteralContext() {}

func NewOC_DoubleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_DoubleLiteralContext {
	var p = new(OC_DoubleLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_DoubleLiteral

	return p
}

func (s *OC_DoubleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_DoubleLiteralContext) ExponentDecimalReal() antlr.TerminalNode {
	return s.GetToken(CypherParserExponentDecimalReal, 0)
}

func (s *OC_DoubleLiteralContext) RegularDecimalReal() antlr.TerminalNode {
	return s.GetToken(CypherParserRegularDecimalReal, 0)
}

func (s *OC_DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_DoubleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_DoubleLiteral(s)
	}
}

func (s *OC_DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_DoubleLiteral(s)
	}
}




func (p *CypherParser) OC_DoubleLiteral() (localctx IOC_DoubleLiteralContext) {
	localctx = NewOC_DoubleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, CypherParserRULE_oC_DoubleLiteral)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1485)
	_la = p.GetTokenStream().LA(1)

	if !(_la == CypherParserExponentDecimalReal || _la == CypherParserRegularDecimalReal) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IOC_ListLiteralContext is an interface to support dynamic dispatch.
type IOC_ListLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ListLiteralContext differentiates from other interfaces.
	IsOC_ListLiteralContext()
}

type OC_ListLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ListLiteralContext() *OC_ListLiteralContext {
	var p = new(OC_ListLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ListLiteral
	return p
}

func (*OC_ListLiteralContext) IsOC_ListLiteralContext() {}

func NewOC_ListLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ListLiteralContext {
	var p = new(OC_ListLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ListLiteral

	return p
}

func (s *OC_ListLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ListLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_ListLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_ListLiteralContext) AllOC_Expression() []IOC_ExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem())
	var tst = make([]IOC_ExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ExpressionContext)
		}
	}

	return tst
}

func (s *OC_ListLiteralContext) OC_Expression(i int) IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_ListLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ListLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ListLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ListLiteral(s)
	}
}

func (s *OC_ListLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ListLiteral(s)
	}
}




func (p *CypherParser) OC_ListLiteral() (localctx IOC_ListLiteralContext) {
	localctx = NewOC_ListLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, CypherParserRULE_oC_ListLiteral)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1487)
		p.Match(CypherParserT__7)
	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1488)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1508)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << CypherParserT__5) | (1 << CypherParserT__7) | (1 << CypherParserT__17) | (1 << CypherParserT__18) | (1 << CypherParserT__23) | (1 << CypherParserT__25))) != 0) || _la == CypherParserALL || _la == CypherParserNOT || ((((_la - 82)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 82))) & ((1 << (CypherParserNULL - 82)) | (1 << (CypherParserCOUNT - 82)) | (1 << (CypherParserCASE - 82)) | (1 << (CypherParserANY - 82)) | (1 << (CypherParserNONE - 82)) | (1 << (CypherParserSINGLE - 82)) | (1 << (CypherParserEXISTS - 82)) | (1 << (CypherParserTRUE - 82)) | (1 << (CypherParserFALSE - 82)) | (1 << (CypherParserHexInteger - 82)) | (1 << (CypherParserDecimalInteger - 82)) | (1 << (CypherParserOctalInteger - 82)) | (1 << (CypherParserHexLetter - 82)) | (1 << (CypherParserExponentDecimalReal - 82)) | (1 << (CypherParserRegularDecimalReal - 82)) | (1 << (CypherParserStringLiteral - 82)))) != 0) || ((((_la - 119)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 119))) & ((1 << (CypherParserFILTER - 119)) | (1 << (CypherParserEXTRACT - 119)) | (1 << (CypherParserUnescapedSymbolicName - 119)) | (1 << (CypherParserEscapedSymbolicName - 119)))) != 0) {
		{
			p.SetState(1491)
			p.OC_Expression()
		}
		p.SetState(1493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1492)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == CypherParserT__1 {
			{
				p.SetState(1495)
				p.Match(CypherParserT__1)
			}
			p.SetState(1497)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1496)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1499)
				p.OC_Expression()
			}
			p.SetState(1501)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1500)
					p.Match(CypherParserSP)
				}

			}


			p.SetState(1507)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1510)
		p.Match(CypherParserT__8)
	}



	return localctx
}


// IOC_MapLiteralContext is an interface to support dynamic dispatch.
type IOC_MapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_MapLiteralContext differentiates from other interfaces.
	IsOC_MapLiteralContext()
}

type OC_MapLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_MapLiteralContext() *OC_MapLiteralContext {
	var p = new(OC_MapLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_MapLiteral
	return p
}

func (*OC_MapLiteralContext) IsOC_MapLiteralContext() {}

func NewOC_MapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_MapLiteralContext {
	var p = new(OC_MapLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_MapLiteral

	return p
}

func (s *OC_MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_MapLiteralContext) AllSP() []antlr.TerminalNode {
	return s.GetTokens(CypherParserSP)
}

func (s *OC_MapLiteralContext) SP(i int) antlr.TerminalNode {
	return s.GetToken(CypherParserSP, i)
}

func (s *OC_MapLiteralContext) AllOC_PropertyKeyName() []IOC_PropertyKeyNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_PropertyKeyNameContext)(nil)).Elem())
	var tst = make([]IOC_PropertyKeyNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_PropertyKeyNameContext)
		}
	}

	return tst
}

func (s *OC_MapLiteralContext) OC_PropertyKeyName(i int) IOC_PropertyKeyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_PropertyKeyNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_PropertyKeyNameContext)
}

func (s *OC_MapLiteralContext) AllOC_Expression() []IOC_ExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem())
	var tst = make([]IOC_ExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOC_ExpressionContext)
		}
	}

	return tst
}

func (s *OC_MapLiteralContext) OC_Expression(i int) IOC_ExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOC_ExpressionContext)
}

func (s *OC_MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_MapLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_MapLiteral(s)
	}
}

func (s *OC_MapLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_MapLiteral(s)
	}
}




func (p *CypherParser) OC_MapLiteral() (localctx IOC_MapLiteralContext) {
	localctx = NewOC_MapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, CypherParserRULE_oC_MapLiteral)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1512)
		p.Match(CypherParserT__23)
	}
	p.SetState(1514)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == CypherParserSP {
		{
			p.SetState(1513)
			p.Match(CypherParserSP)
		}

	}
	p.SetState(1549)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 46)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 46))) & ((1 << (CypherParserUNION - 46)) | (1 << (CypherParserALL - 46)) | (1 << (CypherParserOPTIONAL - 46)) | (1 << (CypherParserMATCH - 46)) | (1 << (CypherParserUNWIND - 46)) | (1 << (CypherParserAS - 46)) | (1 << (CypherParserMERGE - 46)) | (1 << (CypherParserON - 46)) | (1 << (CypherParserCREATE - 46)) | (1 << (CypherParserSET - 46)) | (1 << (CypherParserDETACH - 46)) | (1 << (CypherParserDELETE - 46)) | (1 << (CypherParserREMOVE - 46)) | (1 << (CypherParserWITH - 46)) | (1 << (CypherParserRETURN - 46)) | (1 << (CypherParserDISTINCT - 46)) | (1 << (CypherParserORDER - 46)) | (1 << (CypherParserBY - 46)) | (1 << (CypherParserL_SKIP - 46)) | (1 << (CypherParserLIMIT - 46)) | (1 << (CypherParserASCENDING - 46)) | (1 << (CypherParserASC - 46)) | (1 << (CypherParserDESCENDING - 46)) | (1 << (CypherParserDESC - 46)) | (1 << (CypherParserWHERE - 46)) | (1 << (CypherParserOR - 46)) | (1 << (CypherParserXOR - 46)) | (1 << (CypherParserAND - 46)) | (1 << (CypherParserNOT - 46)) | (1 << (CypherParserSTARTS - 46)))) != 0) || ((((_la - 78)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 78))) & ((1 << (CypherParserENDS - 78)) | (1 << (CypherParserCONTAINS - 78)) | (1 << (CypherParserIN - 78)) | (1 << (CypherParserIS - 78)) | (1 << (CypherParserNULL - 78)) | (1 << (CypherParserCOUNT - 78)) | (1 << (CypherParserCASE - 78)) | (1 << (CypherParserELSE - 78)) | (1 << (CypherParserEND - 78)) | (1 << (CypherParserWHEN - 78)) | (1 << (CypherParserTHEN - 78)) | (1 << (CypherParserANY - 78)) | (1 << (CypherParserNONE - 78)) | (1 << (CypherParserSINGLE - 78)) | (1 << (CypherParserEXISTS - 78)) | (1 << (CypherParserTRUE - 78)) | (1 << (CypherParserFALSE - 78)) | (1 << (CypherParserHexLetter - 78)) | (1 << (CypherParserCONSTRAINT - 78)))) != 0) || ((((_la - 110)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 110))) & ((1 << (CypherParserDO - 110)) | (1 << (CypherParserFOR - 110)) | (1 << (CypherParserREQUIRE - 110)) | (1 << (CypherParserUNIQUE - 110)) | (1 << (CypherParserMANDATORY - 110)) | (1 << (CypherParserSCALAR - 110)) | (1 << (CypherParserOF - 110)) | (1 << (CypherParserADD - 110)) | (1 << (CypherParserDROP - 110)) | (1 << (CypherParserFILTER - 110)) | (1 << (CypherParserEXTRACT - 110)) | (1 << (CypherParserUnescapedSymbolicName - 110)) | (1 << (CypherParserEscapedSymbolicName - 110)))) != 0) {
		{
			p.SetState(1516)
			p.OC_PropertyKeyName()
		}
		p.SetState(1518)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1517)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1520)
			p.Match(CypherParserT__9)
		}
		p.SetState(1522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1521)
				p.Match(CypherParserSP)
			}

		}
		{
			p.SetState(1524)
			p.OC_Expression()
		}
		p.SetState(1526)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == CypherParserSP {
			{
				p.SetState(1525)
				p.Match(CypherParserSP)
			}

		}
		p.SetState(1546)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == CypherParserT__1 {
			{
				p.SetState(1528)
				p.Match(CypherParserT__1)
			}
			p.SetState(1530)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1529)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1532)
				p.OC_PropertyKeyName()
			}
			p.SetState(1534)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1533)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1536)
				p.Match(CypherParserT__9)
			}
			p.SetState(1538)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1537)
					p.Match(CypherParserSP)
				}

			}
			{
				p.SetState(1540)
				p.OC_Expression()
			}
			p.SetState(1542)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == CypherParserSP {
				{
					p.SetState(1541)
					p.Match(CypherParserSP)
				}

			}


			p.SetState(1548)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1551)
		p.Match(CypherParserT__24)
	}



	return localctx
}


// IOC_PropertyKeyNameContext is an interface to support dynamic dispatch.
type IOC_PropertyKeyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_PropertyKeyNameContext differentiates from other interfaces.
	IsOC_PropertyKeyNameContext()
}

type OC_PropertyKeyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_PropertyKeyNameContext() *OC_PropertyKeyNameContext {
	var p = new(OC_PropertyKeyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_PropertyKeyName
	return p
}

func (*OC_PropertyKeyNameContext) IsOC_PropertyKeyNameContext() {}

func NewOC_PropertyKeyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_PropertyKeyNameContext {
	var p = new(OC_PropertyKeyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_PropertyKeyName

	return p
}

func (s *OC_PropertyKeyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_PropertyKeyNameContext) OC_SchemaName() IOC_SchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SchemaNameContext)
}

func (s *OC_PropertyKeyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_PropertyKeyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_PropertyKeyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_PropertyKeyName(s)
	}
}

func (s *OC_PropertyKeyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_PropertyKeyName(s)
	}
}




func (p *CypherParser) OC_PropertyKeyName() (localctx IOC_PropertyKeyNameContext) {
	localctx = NewOC_PropertyKeyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, CypherParserRULE_oC_PropertyKeyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1553)
		p.OC_SchemaName()
	}



	return localctx
}


// IOC_ParameterContext is an interface to support dynamic dispatch.
type IOC_ParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ParameterContext differentiates from other interfaces.
	IsOC_ParameterContext()
}

type OC_ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ParameterContext() *OC_ParameterContext {
	var p = new(OC_ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Parameter
	return p
}

func (*OC_ParameterContext) IsOC_ParameterContext() {}

func NewOC_ParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ParameterContext {
	var p = new(OC_ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Parameter

	return p
}

func (s *OC_ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ParameterContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_ParameterContext) DecimalInteger() antlr.TerminalNode {
	return s.GetToken(CypherParserDecimalInteger, 0)
}

func (s *OC_ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Parameter(s)
	}
}

func (s *OC_ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Parameter(s)
	}
}




func (p *CypherParser) OC_Parameter() (localctx IOC_ParameterContext) {
	localctx = NewOC_ParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, CypherParserRULE_oC_Parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1555)
		p.Match(CypherParserT__25)
	}
	p.SetState(1558)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		{
			p.SetState(1556)
			p.OC_SymbolicName()
		}


	case CypherParserDecimalInteger:
		{
			p.SetState(1557)
			p.Match(CypherParserDecimalInteger)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IOC_SchemaNameContext is an interface to support dynamic dispatch.
type IOC_SchemaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SchemaNameContext differentiates from other interfaces.
	IsOC_SchemaNameContext()
}

type OC_SchemaNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SchemaNameContext() *OC_SchemaNameContext {
	var p = new(OC_SchemaNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_SchemaName
	return p
}

func (*OC_SchemaNameContext) IsOC_SchemaNameContext() {}

func NewOC_SchemaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SchemaNameContext {
	var p = new(OC_SchemaNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_SchemaName

	return p
}

func (s *OC_SchemaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SchemaNameContext) OC_SymbolicName() IOC_SymbolicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_SymbolicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_SymbolicNameContext)
}

func (s *OC_SchemaNameContext) OC_ReservedWord() IOC_ReservedWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOC_ReservedWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOC_ReservedWordContext)
}

func (s *OC_SchemaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SchemaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_SchemaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_SchemaName(s)
	}
}

func (s *OC_SchemaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_SchemaName(s)
	}
}




func (p *CypherParser) OC_SchemaName() (localctx IOC_SchemaNameContext) {
	localctx = NewOC_SchemaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, CypherParserRULE_oC_SchemaName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1562)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case CypherParserCOUNT, CypherParserANY, CypherParserNONE, CypherParserSINGLE, CypherParserHexLetter, CypherParserFILTER, CypherParserEXTRACT, CypherParserUnescapedSymbolicName, CypherParserEscapedSymbolicName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1560)
			p.OC_SymbolicName()
		}


	case CypherParserUNION, CypherParserALL, CypherParserOPTIONAL, CypherParserMATCH, CypherParserUNWIND, CypherParserAS, CypherParserMERGE, CypherParserON, CypherParserCREATE, CypherParserSET, CypherParserDETACH, CypherParserDELETE, CypherParserREMOVE, CypherParserWITH, CypherParserRETURN, CypherParserDISTINCT, CypherParserORDER, CypherParserBY, CypherParserL_SKIP, CypherParserLIMIT, CypherParserASCENDING, CypherParserASC, CypherParserDESCENDING, CypherParserDESC, CypherParserWHERE, CypherParserOR, CypherParserXOR, CypherParserAND, CypherParserNOT, CypherParserSTARTS, CypherParserENDS, CypherParserCONTAINS, CypherParserIN, CypherParserIS, CypherParserNULL, CypherParserCASE, CypherParserELSE, CypherParserEND, CypherParserWHEN, CypherParserTHEN, CypherParserEXISTS, CypherParserTRUE, CypherParserFALSE, CypherParserCONSTRAINT, CypherParserDO, CypherParserFOR, CypherParserREQUIRE, CypherParserUNIQUE, CypherParserMANDATORY, CypherParserSCALAR, CypherParserOF, CypherParserADD, CypherParserDROP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1561)
			p.OC_ReservedWord()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOC_ReservedWordContext is an interface to support dynamic dispatch.
type IOC_ReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_ReservedWordContext differentiates from other interfaces.
	IsOC_ReservedWordContext()
}

type OC_ReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_ReservedWordContext() *OC_ReservedWordContext {
	var p = new(OC_ReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_ReservedWord
	return p
}

func (*OC_ReservedWordContext) IsOC_ReservedWordContext() {}

func NewOC_ReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_ReservedWordContext {
	var p = new(OC_ReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_ReservedWord

	return p
}

func (s *OC_ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_ReservedWordContext) ALL() antlr.TerminalNode {
	return s.GetToken(CypherParserALL, 0)
}

func (s *OC_ReservedWordContext) ASC() antlr.TerminalNode {
	return s.GetToken(CypherParserASC, 0)
}

func (s *OC_ReservedWordContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserASCENDING, 0)
}

func (s *OC_ReservedWordContext) BY() antlr.TerminalNode {
	return s.GetToken(CypherParserBY, 0)
}

func (s *OC_ReservedWordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(CypherParserCREATE, 0)
}

func (s *OC_ReservedWordContext) DELETE() antlr.TerminalNode {
	return s.GetToken(CypherParserDELETE, 0)
}

func (s *OC_ReservedWordContext) DESC() antlr.TerminalNode {
	return s.GetToken(CypherParserDESC, 0)
}

func (s *OC_ReservedWordContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(CypherParserDESCENDING, 0)
}

func (s *OC_ReservedWordContext) DETACH() antlr.TerminalNode {
	return s.GetToken(CypherParserDETACH, 0)
}

func (s *OC_ReservedWordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(CypherParserEXISTS, 0)
}

func (s *OC_ReservedWordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(CypherParserLIMIT, 0)
}

func (s *OC_ReservedWordContext) MATCH() antlr.TerminalNode {
	return s.GetToken(CypherParserMATCH, 0)
}

func (s *OC_ReservedWordContext) MERGE() antlr.TerminalNode {
	return s.GetToken(CypherParserMERGE, 0)
}

func (s *OC_ReservedWordContext) ON() antlr.TerminalNode {
	return s.GetToken(CypherParserON, 0)
}

func (s *OC_ReservedWordContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(CypherParserOPTIONAL, 0)
}

func (s *OC_ReservedWordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(CypherParserORDER, 0)
}

func (s *OC_ReservedWordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(CypherParserREMOVE, 0)
}

func (s *OC_ReservedWordContext) RETURN() antlr.TerminalNode {
	return s.GetToken(CypherParserRETURN, 0)
}

func (s *OC_ReservedWordContext) SET() antlr.TerminalNode {
	return s.GetToken(CypherParserSET, 0)
}

func (s *OC_ReservedWordContext) L_SKIP() antlr.TerminalNode {
	return s.GetToken(CypherParserL_SKIP, 0)
}

func (s *OC_ReservedWordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(CypherParserWHERE, 0)
}

func (s *OC_ReservedWordContext) WITH() antlr.TerminalNode {
	return s.GetToken(CypherParserWITH, 0)
}

func (s *OC_ReservedWordContext) UNION() antlr.TerminalNode {
	return s.GetToken(CypherParserUNION, 0)
}

func (s *OC_ReservedWordContext) UNWIND() antlr.TerminalNode {
	return s.GetToken(CypherParserUNWIND, 0)
}

func (s *OC_ReservedWordContext) AND() antlr.TerminalNode {
	return s.GetToken(CypherParserAND, 0)
}

func (s *OC_ReservedWordContext) AS() antlr.TerminalNode {
	return s.GetToken(CypherParserAS, 0)
}

func (s *OC_ReservedWordContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(CypherParserCONTAINS, 0)
}

func (s *OC_ReservedWordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(CypherParserDISTINCT, 0)
}

func (s *OC_ReservedWordContext) ENDS() antlr.TerminalNode {
	return s.GetToken(CypherParserENDS, 0)
}

func (s *OC_ReservedWordContext) IN() antlr.TerminalNode {
	return s.GetToken(CypherParserIN, 0)
}

func (s *OC_ReservedWordContext) IS() antlr.TerminalNode {
	return s.GetToken(CypherParserIS, 0)
}

func (s *OC_ReservedWordContext) NOT() antlr.TerminalNode {
	return s.GetToken(CypherParserNOT, 0)
}

func (s *OC_ReservedWordContext) OR() antlr.TerminalNode {
	return s.GetToken(CypherParserOR, 0)
}

func (s *OC_ReservedWordContext) STARTS() antlr.TerminalNode {
	return s.GetToken(CypherParserSTARTS, 0)
}

func (s *OC_ReservedWordContext) XOR() antlr.TerminalNode {
	return s.GetToken(CypherParserXOR, 0)
}

func (s *OC_ReservedWordContext) FALSE() antlr.TerminalNode {
	return s.GetToken(CypherParserFALSE, 0)
}

func (s *OC_ReservedWordContext) TRUE() antlr.TerminalNode {
	return s.GetToken(CypherParserTRUE, 0)
}

func (s *OC_ReservedWordContext) NULL() antlr.TerminalNode {
	return s.GetToken(CypherParserNULL, 0)
}

func (s *OC_ReservedWordContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(CypherParserCONSTRAINT, 0)
}

func (s *OC_ReservedWordContext) DO() antlr.TerminalNode {
	return s.GetToken(CypherParserDO, 0)
}

func (s *OC_ReservedWordContext) FOR() antlr.TerminalNode {
	return s.GetToken(CypherParserFOR, 0)
}

func (s *OC_ReservedWordContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(CypherParserREQUIRE, 0)
}

func (s *OC_ReservedWordContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(CypherParserUNIQUE, 0)
}

func (s *OC_ReservedWordContext) CASE() antlr.TerminalNode {
	return s.GetToken(CypherParserCASE, 0)
}

func (s *OC_ReservedWordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(CypherParserWHEN, 0)
}

func (s *OC_ReservedWordContext) THEN() antlr.TerminalNode {
	return s.GetToken(CypherParserTHEN, 0)
}

func (s *OC_ReservedWordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(CypherParserELSE, 0)
}

func (s *OC_ReservedWordContext) END() antlr.TerminalNode {
	return s.GetToken(CypherParserEND, 0)
}

func (s *OC_ReservedWordContext) MANDATORY() antlr.TerminalNode {
	return s.GetToken(CypherParserMANDATORY, 0)
}

func (s *OC_ReservedWordContext) SCALAR() antlr.TerminalNode {
	return s.GetToken(CypherParserSCALAR, 0)
}

func (s *OC_ReservedWordContext) OF() antlr.TerminalNode {
	return s.GetToken(CypherParserOF, 0)
}

func (s *OC_ReservedWordContext) ADD() antlr.TerminalNode {
	return s.GetToken(CypherParserADD, 0)
}

func (s *OC_ReservedWordContext) DROP() antlr.TerminalNode {
	return s.GetToken(CypherParserDROP, 0)
}

func (s *OC_ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_ReservedWord(s)
	}
}

func (s *OC_ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_ReservedWord(s)
	}
}




func (p *CypherParser) OC_ReservedWord() (localctx IOC_ReservedWordContext) {
	localctx = NewOC_ReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, CypherParserRULE_oC_ReservedWord)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1564)
	_la = p.GetTokenStream().LA(1)

	if !(((((_la - 46)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 46))) & ((1 << (CypherParserUNION - 46)) | (1 << (CypherParserALL - 46)) | (1 << (CypherParserOPTIONAL - 46)) | (1 << (CypherParserMATCH - 46)) | (1 << (CypherParserUNWIND - 46)) | (1 << (CypherParserAS - 46)) | (1 << (CypherParserMERGE - 46)) | (1 << (CypherParserON - 46)) | (1 << (CypherParserCREATE - 46)) | (1 << (CypherParserSET - 46)) | (1 << (CypherParserDETACH - 46)) | (1 << (CypherParserDELETE - 46)) | (1 << (CypherParserREMOVE - 46)) | (1 << (CypherParserWITH - 46)) | (1 << (CypherParserRETURN - 46)) | (1 << (CypherParserDISTINCT - 46)) | (1 << (CypherParserORDER - 46)) | (1 << (CypherParserBY - 46)) | (1 << (CypherParserL_SKIP - 46)) | (1 << (CypherParserLIMIT - 46)) | (1 << (CypherParserASCENDING - 46)) | (1 << (CypherParserASC - 46)) | (1 << (CypherParserDESCENDING - 46)) | (1 << (CypherParserDESC - 46)) | (1 << (CypherParserWHERE - 46)) | (1 << (CypherParserOR - 46)) | (1 << (CypherParserXOR - 46)) | (1 << (CypherParserAND - 46)) | (1 << (CypherParserNOT - 46)) | (1 << (CypherParserSTARTS - 46)))) != 0) || ((((_la - 78)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 78))) & ((1 << (CypherParserENDS - 78)) | (1 << (CypherParserCONTAINS - 78)) | (1 << (CypherParserIN - 78)) | (1 << (CypherParserIS - 78)) | (1 << (CypherParserNULL - 78)) | (1 << (CypherParserCASE - 78)) | (1 << (CypherParserELSE - 78)) | (1 << (CypherParserEND - 78)) | (1 << (CypherParserWHEN - 78)) | (1 << (CypherParserTHEN - 78)) | (1 << (CypherParserEXISTS - 78)) | (1 << (CypherParserTRUE - 78)) | (1 << (CypherParserFALSE - 78)) | (1 << (CypherParserCONSTRAINT - 78)))) != 0) || ((((_la - 110)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 110))) & ((1 << (CypherParserDO - 110)) | (1 << (CypherParserFOR - 110)) | (1 << (CypherParserREQUIRE - 110)) | (1 << (CypherParserUNIQUE - 110)) | (1 << (CypherParserMANDATORY - 110)) | (1 << (CypherParserSCALAR - 110)) | (1 << (CypherParserOF - 110)) | (1 << (CypherParserADD - 110)) | (1 << (CypherParserDROP - 110)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IOC_SymbolicNameContext is an interface to support dynamic dispatch.
type IOC_SymbolicNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_SymbolicNameContext differentiates from other interfaces.
	IsOC_SymbolicNameContext()
}

type OC_SymbolicNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_SymbolicNameContext() *OC_SymbolicNameContext {
	var p = new(OC_SymbolicNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_SymbolicName
	return p
}

func (*OC_SymbolicNameContext) IsOC_SymbolicNameContext() {}

func NewOC_SymbolicNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_SymbolicNameContext {
	var p = new(OC_SymbolicNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_SymbolicName

	return p
}

func (s *OC_SymbolicNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OC_SymbolicNameContext) UnescapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(CypherParserUnescapedSymbolicName, 0)
}

func (s *OC_SymbolicNameContext) EscapedSymbolicName() antlr.TerminalNode {
	return s.GetToken(CypherParserEscapedSymbolicName, 0)
}

func (s *OC_SymbolicNameContext) HexLetter() antlr.TerminalNode {
	return s.GetToken(CypherParserHexLetter, 0)
}

func (s *OC_SymbolicNameContext) COUNT() antlr.TerminalNode {
	return s.GetToken(CypherParserCOUNT, 0)
}

func (s *OC_SymbolicNameContext) FILTER() antlr.TerminalNode {
	return s.GetToken(CypherParserFILTER, 0)
}

func (s *OC_SymbolicNameContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(CypherParserEXTRACT, 0)
}

func (s *OC_SymbolicNameContext) ANY() antlr.TerminalNode {
	return s.GetToken(CypherParserANY, 0)
}

func (s *OC_SymbolicNameContext) NONE() antlr.TerminalNode {
	return s.GetToken(CypherParserNONE, 0)
}

func (s *OC_SymbolicNameContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(CypherParserSINGLE, 0)
}

func (s *OC_SymbolicNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_SymbolicNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_SymbolicNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_SymbolicName(s)
	}
}

func (s *OC_SymbolicNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_SymbolicName(s)
	}
}




func (p *CypherParser) OC_SymbolicName() (localctx IOC_SymbolicNameContext) {
	localctx = NewOC_SymbolicNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, CypherParserRULE_oC_SymbolicName)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1566)
	_la = p.GetTokenStream().LA(1)

	if !(((((_la - 83)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 83))) & ((1 << (CypherParserCOUNT - 83)) | (1 << (CypherParserANY - 83)) | (1 << (CypherParserNONE - 83)) | (1 << (CypherParserSINGLE - 83)) | (1 << (CypherParserHexLetter - 83)))) != 0) || ((((_la - 119)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 119))) & ((1 << (CypherParserFILTER - 119)) | (1 << (CypherParserEXTRACT - 119)) | (1 << (CypherParserUnescapedSymbolicName - 119)) | (1 << (CypherParserEscapedSymbolicName - 119)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IOC_LeftArrowHeadContext is an interface to support dynamic dispatch.
type IOC_LeftArrowHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_LeftArrowHeadContext differentiates from other interfaces.
	IsOC_LeftArrowHeadContext()
}

type OC_LeftArrowHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_LeftArrowHeadContext() *OC_LeftArrowHeadContext {
	var p = new(OC_LeftArrowHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_LeftArrowHead
	return p
}

func (*OC_LeftArrowHeadContext) IsOC_LeftArrowHeadContext() {}

func NewOC_LeftArrowHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_LeftArrowHeadContext {
	var p = new(OC_LeftArrowHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_LeftArrowHead

	return p
}

func (s *OC_LeftArrowHeadContext) GetParser() antlr.Parser { return s.parser }
func (s *OC_LeftArrowHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_LeftArrowHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_LeftArrowHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_LeftArrowHead(s)
	}
}

func (s *OC_LeftArrowHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_LeftArrowHead(s)
	}
}




func (p *CypherParser) OC_LeftArrowHead() (localctx IOC_LeftArrowHeadContext) {
	localctx = NewOC_LeftArrowHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, CypherParserRULE_oC_LeftArrowHead)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1568)
	_la = p.GetTokenStream().LA(1)

	if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << CypherParserT__13) | (1 << CypherParserT__26) | (1 << CypherParserT__27) | (1 << CypherParserT__28) | (1 << CypherParserT__29))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IOC_RightArrowHeadContext is an interface to support dynamic dispatch.
type IOC_RightArrowHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_RightArrowHeadContext differentiates from other interfaces.
	IsOC_RightArrowHeadContext()
}

type OC_RightArrowHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_RightArrowHeadContext() *OC_RightArrowHeadContext {
	var p = new(OC_RightArrowHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_RightArrowHead
	return p
}

func (*OC_RightArrowHeadContext) IsOC_RightArrowHeadContext() {}

func NewOC_RightArrowHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_RightArrowHeadContext {
	var p = new(OC_RightArrowHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_RightArrowHead

	return p
}

func (s *OC_RightArrowHeadContext) GetParser() antlr.Parser { return s.parser }
func (s *OC_RightArrowHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_RightArrowHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_RightArrowHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_RightArrowHead(s)
	}
}

func (s *OC_RightArrowHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_RightArrowHead(s)
	}
}




func (p *CypherParser) OC_RightArrowHead() (localctx IOC_RightArrowHeadContext) {
	localctx = NewOC_RightArrowHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, CypherParserRULE_oC_RightArrowHead)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1570)
	_la = p.GetTokenStream().LA(1)

	if !(((((_la - 15)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 15))) & ((1 << (CypherParserT__14 - 15)) | (1 << (CypherParserT__30 - 15)) | (1 << (CypherParserT__31 - 15)) | (1 << (CypherParserT__32 - 15)) | (1 << (CypherParserT__33 - 15)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IOC_DashContext is an interface to support dynamic dispatch.
type IOC_DashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOC_DashContext differentiates from other interfaces.
	IsOC_DashContext()
}

type OC_DashContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOC_DashContext() *OC_DashContext {
	var p = new(OC_DashContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = CypherParserRULE_oC_Dash
	return p
}

func (*OC_DashContext) IsOC_DashContext() {}

func NewOC_DashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OC_DashContext {
	var p = new(OC_DashContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = CypherParserRULE_oC_Dash

	return p
}

func (s *OC_DashContext) GetParser() antlr.Parser { return s.parser }
func (s *OC_DashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OC_DashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OC_DashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.EnterOC_Dash(s)
	}
}

func (s *OC_DashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CypherListener); ok {
		listenerT.ExitOC_Dash(s)
	}
}




func (p *CypherParser) OC_Dash() (localctx IOC_DashContext) {
	localctx = NewOC_DashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, CypherParserRULE_oC_Dash)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1572)
	_la = p.GetTokenStream().LA(1)

	if !(((((_la - 19)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 19))) & ((1 << (CypherParserT__18 - 19)) | (1 << (CypherParserT__34 - 19)) | (1 << (CypherParserT__35 - 19)) | (1 << (CypherParserT__36 - 19)) | (1 << (CypherParserT__37 - 19)) | (1 << (CypherParserT__38 - 19)) | (1 << (CypherParserT__39 - 19)) | (1 << (CypherParserT__40 - 19)) | (1 << (CypherParserT__41 - 19)) | (1 << (CypherParserT__42 - 19)) | (1 << (CypherParserT__43 - 19)) | (1 << (CypherParserT__44 - 19)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


